#pragma GCC optimzize("Ofast,no-stack-protector")
#include<bits/stdc++.h>
#define int long long
#define quick ios::sync_with_stdio(0);cin.tie(0);
#define rep(x,a,b) for(int x=a;x<=b;x++)
#define repd(x,a,b) for(int x=a;x>=b;x--)
#define lowbit(x) (x&-x)
#define sz(x) (int)(x.size())
#define F first
#define S second
#define all(x) x.begin(),x.end()
#define mp make_pair
#define eb emplace_back
using namespace std;
typedef pair<int,int> pii;
void debug(){
    cout<<"\n";
}
template <class T,class ... U >
void debug(T a, U ... b){
    cout<<a<<" ",debug(b...);
}
const int N=2e3+7;
const int INF=1e18;
vector<int> v[N];//X的鄰點
int match[N]; // Y所匹配的節點
bool vis[N]; //在這次尋找中是否被走過
int dfs(int x){
	for(int y:v[x]){
		if(vis[y]) continue;
		vis[y]=true;
		if(match[y]==-1||dfs(match[y])){
			match[y]=x;
			return true;
		}
	}
	return false;
}
int bipartiteMatching(int n){
	fill(match,match+n+1,-1);
	int ans=0;
	rep(i,1,n){
		fill(vis,vis+n+1,0);
		if(dfs(i)) ans++;
	}
	return ans;
}
struct edge{
	int t,x,y;
}e[N];
signed main(){
    quick
	int n;
	cin>>n;
	while(n--){
		int m;
		cin>>m;
		rep(i,1,m){
			v[i].clear();
			cin>>e[i].t>>e[i].x>>e[i].y;
		}
		rep(i,1,m){
			rep(j,1,m){
				if(i!=j&&e[i].t+abs(e[i].x-e[j].x)+abs(e[i].y-e[j].y)<=e[j].t){
					v[i].eb(j);
				}
			}
		}
		cout<<m-bipartiteMatching(m)<<"\n";
	}
    return 0;
}
