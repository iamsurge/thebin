'''
This neural network framework nudges both weights and biases when it performs backpropagation. Only works with 1 network output. 
'''
import numpy as np
import random

class Layer:
    def __init__(self, inputNodes, outputNodes):
        self.weights = 0.1 * np.random.randn(inputNodes, outputNodes)
        #self.weights = 2 + np.zeros((inputNodes, outputNodes))
        self.biases = 1 + np.zeros((1, outputNodes))
    
    def forward(self, inputs):
        self.output = np.dot(inputs, self.weights) + self.biases

class Activation_ReLU:
    def forward(self, inputs):
        self.output = np.maximum(0, inputs)    
        
learningRate = 0.0001
def backwards(network, input_, desired):
    currentLayer = len(network) - 1
    dError = 2*(network[currentLayer].output - desired)
    
    gradients = np.zeros((len(network), 5)) 
    gradients[currentLayer][0] = dError     
                     
    currentLayer = len(network) - 1
    while currentLayer >= 0: # Per layer
        if type(network[currentLayer - 1]) == Activation_ReLU:
            pass
        else:
            if currentLayer != 0:
                
                #Nudge the weights and biases
                for neuronCurrentLayer in range(len(network[currentLayer].output[0])): # Per neuron in current layer
                    #print("Neuron ", neuronCurrentLayer + 1, ": ")
                    network[currentLayer].biases[0][neuronCurrentLayer] -= 1 * gradients[currentLayer][neuronCurrentLayer] * learningRate
                    for neuronPreviousLayer in range(len(network[currentLayer - 1].output[0])): # Per neuron in previous layer
                        network[currentLayer].weights[neuronPreviousLayer][neuronCurrentLayer] -= network[currentLayer - 1].output[0][neuronPreviousLayer] * gradients[currentLayer][neuronCurrentLayer] * learningRate
                
                
                # Calculate gradients for every neuron in the next layer you're going to adjust
                for neuronCurrentLayer in range(len(network[currentLayer].output[0])): # Per neuron in current layer
                    for neuronPreviousLayer in range(len(network[currentLayer - 1].output[0])): # Per neuron in previous layer
                        gradients[currentLayer - 1][neuronPreviousLayer] += network[currentLayer].weights[neuronPreviousLayer][neuronCurrentLayer] * gradients[currentLayer][neuronCurrentLayer]   
                    
        currentLayer -= 1 #Go to previous layer
    
    print("Error: ", (network[len(network) - 1].output[0] - desired))
        
#Create training data
#inputs = [4, 6, 1, 3, 9, 2, 3, 7, 10, 34]
#desired = [8, 12, 2, 6, 18, 4, 6, 14, 20, 68]
inputs = [3, 7, 4, 9, 1, 3, 3, 8, 5, 2]
desired = [6 + 3, 14 + 3, 8 + 3, 18 + 3, 2 + 3, 6 + 3, 6 + 3, 16 + 3, 10 + 3, 4 + 3]


#Create neural network
layer1 = Layer(1, 3)

layer2 = Layer(3, 3)

layer3 = Layer(3, 1)


#Train the network
for x in range(5000):
    for iteration in range(10):
        layer1.forward(inputs[iteration])
        layer2.forward(layer1.output)
        layer3.forward(layer2.output)
        backwards([layer1, layer2, layer3], inputs[iteration], desired[iteration])
        
#Test the network
userInput = 333
layer1.forward(userInput)
layer2.forward(layer1.output)
layer3.forward(layer2.output)
print("Guess: ", layer3.output)














