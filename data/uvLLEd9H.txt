#include <iostream>
#include <algorithm>

using std::cout;
using std::cin;
using std::max;

template<typename T>
class Node;

template<typename T>
class AVL_Tree {
public:
    Node<T> *root = nullptr;
    int treeSize;

    AVL_Tree();

    ~AVL_Tree() = default;

    void add(T x) {
        root = _add(root, x);
        treeSize++;
    }

    void remove(T x) {
        root = _remove(root, x);
    }

    bool find(T x) {
        if (_find(root, x)->_val == x)
            return true;
        return false;
    }

    void clear(){
        _clear(root);
    }

    void prefix(){
        _prefix(root);
    }

    void infix(){
        _infix(root);
    }

    void postfix(){
        _postfix(root);
    }

private:
    int height(Node<T> *);

    Node<T> *_rightRotation(Node<T> *);

    Node<T> *_leftRotation(Node<T> *);

    Node<T> *_add(Node<T> *, T);

    Node<T> *_remove(Node<T> *, T);

    void _clear(Node<T> *);

    Node<T> *_find(Node<T> *, T);

    void _prefix(Node<T>*);

    void _infix(Node<T>*);

    void _postfix(Node<T>*);
};

template<typename T>
class Node {
    T _val;
    Node *_left;
    Node *_right;
    int _height;

    explicit Node(T _val = T()) : _val(_val), _left(nullptr), _right(nullptr), _height(1) {};

    friend class AVL_Tree<T>;
};

template<typename T>
AVL_Tree<T>::AVL_Tree() {
    root = new Node<T>();
    treeSize = 0;
}

template<typename T>
int AVL_Tree<T>::height(Node<T> *vertex) {
    if (vertex == nullptr) return 0;
    return vertex->_height;
}

template<typename T>
Node<T> *AVL_Tree<T>::_rightRotation(Node<T> *vertex) {
    Node<T> *newVertex = vertex->_left;
    vertex->_left = newVertex->_right;
    newVertex->_right = vertex;
    vertex->_height = 1 + max(height(vertex->_left), height(vertex->_right));
    newVertex->_height = 1 + max(height(newVertex->_left), height(newVertex->_right));
    return newVertex;
}

template<typename T>
Node<T> *AVL_Tree<T>::_leftRotation(Node<T> *vertex) {
    Node<T> *newVertex = vertex->_right;
    vertex->_right = newVertex->_left;
    newVertex->_left = vertex;
    vertex->_height = 1 + max(height(vertex->_left), height(vertex->_right));
    newVertex->_height = 1 + max(height(newVertex->_left), height(newVertex->_right));
    return newVertex;
}

template<typename T>
Node<T> *AVL_Tree<T>::_add(Node<T> *vertex, T x) {
    if (vertex == nullptr) {
        auto *temp = new Node<T>(x);
        return temp;
    }
    if (x < vertex->_val) vertex->_left = _add(vertex->_left, x);
    else if (x > vertex->_val) vertex->_right = _add(vertex->_right, x);
    vertex->_height = 1 + max(height(vertex->_left), height(vertex->_right));
    int bal = height(vertex->_left) - height(vertex->_right);
    if (bal > 1) {
        if (x < vertex->_left->_val) {
            return _rightRotation(vertex);
        } else {
            vertex->_left = _leftRotation(vertex->_left);
            return _rightRotation(vertex);
        }
    } else if (bal < -1) {
        if (x > vertex->_right->_val) {
            return _leftRotation(vertex);
        } else {
            vertex->_right = _rightRotation(vertex->_right);
            return _leftRotation(vertex);
        }
    }
    return vertex;
}

template<typename T>
Node<T> *AVL_Tree<T>::_remove(Node<T> *vertex, T x) {
    if (vertex == nullptr) return nullptr;
    if (x < vertex->_val) {
        vertex->_left = _remove(vertex->_left, x);
    } else if (x > vertex->_val) {
        vertex->_right = _remove(vertex->_right, x);
    } else {
        Node<T> *r = vertex->_right;
        if (vertex->_right == nullptr) {
            Node<T> *l = vertex->_left;
            delete (vertex);
            vertex = l;
        } else if (vertex->_left == nullptr) {
            delete (vertex);
            vertex = r;
        } else {
            while (r->_left != nullptr) r = r->_left;
            vertex->_val = r->_val;
            vertex->_right = _remove(vertex->_right, r->_val);
        }
    }
    if (vertex == nullptr) return vertex;
    vertex->_height = 1 + max(height(vertex->_left), height(vertex->_right));
    int bal = height(vertex->_left) - height(vertex->_right);
    if (bal > 1) {
        if (height(vertex->_left) >= height(vertex->_right)) {
            return _rightRotation(vertex);
        } else {
            vertex->_left = _leftRotation(vertex->_left);
            return _rightRotation(vertex);
        }
    } else if (bal < -1) {
        if (height(vertex->_right) >= height(vertex->_left)) {
            return _leftRotation(vertex);
        } else {
            vertex->_right = _rightRotation(vertex->_right);
            return _leftRotation(vertex);
        }
    }
    return vertex;
}

template<typename T>
Node<T> *AVL_Tree<T>::_find(Node<T> *vertex, T x) {
    if (vertex == nullptr) return nullptr;
    T k = vertex->_val;
    if (k == x) return vertex;
    if (k > x) return _find(vertex->_left, x);
    if (k < x) return _find(vertex->_right, x);
}

template<typename T>
void AVL_Tree<T>::_clear(Node<T> *vertex) {
    if(vertex == nullptr){
        return;
    }
    if(vertex->_left == nullptr && vertex->_right == nullptr){
        delete(vertex);
        return;
    }
    if(vertex->_right != nullptr){
        _clear(vertex->_right);
    }
    if(vertex->_left != nullptr){
        _clear(vertex->_left);
    }
}

template<typename T>
void AVL_Tree<T>::_prefix(Node<T> * vertex) {
    if (vertex == NULL)
        return;

    /* first print data of node */
    cout << vertex->data << " ";

    /* then recur on left subtree */
    printPreorder(vertex->left);

    /* now recur on right subtree */
    printPreorder(vertex->right);
}

template<typename T>
void AVL_Tree<T>::_infix(Node<T> * vertex) {
    if (vertex == NULL)
        return;

    /* first recur on left child */
    printInorder(vertex->left);

    /* then print the data of node */
    cout << vertex->data << " ";

    /* now recur on right child */
    printInorder(vertex->right);
}

template<typename T>
void AVL_Tree<T>::_postfix(Node<T> * vertex) {
    if (vertex == NULL)
        return;

    // first recur on left subtree
    printPostorder(vertex->left);

    // then recur on right subtree
    printPostorder(vertex->right);

    // now deal with the node
    cout << vertex->data << " ";
}

int main() {
    AVL_Tree<float> t;
    t.add(1.3);
    t.add(2.4);
    t.add(3.5);
    t.add(4.6);
    t.add(5.7);
    t.add(6.8);
    t.add(7.9);
    std::cout<< t.find(7.9);

    t.remove(5.7);
    t.remove(6.8);
    t.remove(7.9);

    t.clear();


    return 0;
}