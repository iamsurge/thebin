if not turtle then
  error("Error: This can only be used by a turtle!")
end

require "/core/gui/display"
require "/core/minebot"


term_display = Display:new(term)
term_display:reset()

-- ========================
-- QUESTIONS START
-- ========================
local tunnel_length = term_display:number_input("How far do you want to go? ", { default = 3, min_number = 1 })
local tunnel_width = term_display:number_input("How wide of a tunnel do you want?", { default = 3, min_number = 1 })
local tunnel_height = term_display:number_input("How high of a tunnel do you want?", { default = 3, min_number = 1 })
local torch_spacing = term_display:number_input("How far apart do you want your torches? (-1 to skip)",
  { default = 8, min_number = 1, shutoff = -1 })
local place_torches = false
if torch_spacing ~= nil then
  place_torches = true
end
torch_spacing = torch_spacing + 1

local tunneler = Minebot:new(turtle)

term_display:reset()
term_display:text("tunnel_length" .. tunnel_length)
term_display:text("tunnel_width" .. tunnel_width)
term_display:text("tunnel_height" .. tunnel_height)
term_display:text("torch_spacing" .. torch_spacing)


local function tunnel_right()
  -- moves right
  while tunnel_width >= tunneler.x do
    tunneler:move("right")

    -- local isEdge = tunnel_width == tunneler.x
    -- if isEdge then tunnel_fix()
  end
end

local function tunnel_left()
  -- moves right
  while tunneler.x >= tunnel_width do
    tunneler:move("left")

    -- local isEdge = tunneler.x == tunnel_width
    -- if isEdge then tunnel_fix()
  end
end

local function tunnel()
  local swap_direction = false

  while tunnel_height > tunneler.y do
    if swap_direction then
      tunnel_left()
      swap_direction = false
    else
      tunnel_right()
      swap_direction = true
    end

    tunneler:move("up")
  end
end

local function tunnel_reverse()
  local swap_direction = false

  while tunneler.y > tunnel_height do
    if swap_direction then
      tunnel_right()
      swap_direction = false
    else
      tunnel_left()
      swap_direction = true
    end

    tunneler:move("up")
  end
end

-- Run the length of the tunnel
while tunnel_length >= tunneler.z do
  tunneler:move()

  local is_reverse = math.fmod(tunneler.z, 2)

  if is_reverse then
    tunnel_reverse()
  else
    tunnel()
  end
end