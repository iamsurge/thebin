#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES
#include "stdio.h"
#include "stdlib.h"
#include "time.h"
#include <cmath>
#include <math.h>
#include <algorithm>
#include <map>
#include <vector>
#include <utility>
#include <set>
#include <string>
#include <cstring>
#include <iostream>
#include <fstream>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <bitset>
#include <cassert>
#include <functional>
//#include <intrin.h>
#include <stack>
#include <thread>
using namespace std;
//typedef long long ll;
#define ll long long
#define ld long double

const long long mod = 1000000007;

#define MIN(x,y) ((x)<(y)?(x):(y))
#define MAX(x,y) ((x)>(y)?(x):(y))
#define PI 3.14159265358979323846
#define ABS(a) ((a)<0?-(a):(a))
template <typename T> inline T gcd(T a, T b) {
	while (b) { a %= b; swap(a, b); }
	return a;
}
long long fastpow(long long a, long long n)
{
	auto mult = a;
	long long res = 1;
	while (n)
	{
		if (n & 1)
			res *= mult;
		mult *= mult;
		n >>= 1;
	}
	return res;
}

void InsertSort(vector<int>& v)
{
	for (int i = 0; i < v.size() - 1; i++)
		for (int j = i + 1; j < v.size(); j++)
			if (v[j] < v[i])
				swap(v[i], v[j]);
}

void BubbleSort(vector<int>& v)
{
	for (int i = v.size() - 1; i >= 0; i--)
	{
		bool finish = true;
		for (int j = 0; j < i; j++)
			if (v[j] < v[j + 1])
			{
				swap(v[j], v[j + 1]);
				finish = false;
			}
		if (finish)
			break;
	}
}

void QSort(vector<int>& v, int l, int r)
{
	if (r - l < 1)
		return;
	int ci = (l + r) / 2;// или l + rand()%(r-l)
	int c = v[ci];
	int tl = l, tr = r;
	while (tr > tl)
	{
		while (v[tr] > c) tr--;
		while (v[tl] < c) tl++;
		if (tr <= tl)
			break;
		swap(v[tl], v[tr]);
		if (tl == ci)
		{
			ci = tr;
			tr++;
		}
		else if (tr == ci)
		{
			ci = tl;
			tl--;
		}
		tr--;
		tl++;
	}
	QSort(v, l, ci - 1);
	QSort(v, ci + 1, r);
}

void QSortStart(vector<int>& v)
{
	QSort(v, 0, v.size() - 1);
}

void MSort(vector<int>& src, vector<int>& dest, int l, int r)
{
	if (r - l < 1)
		return;
	int m = (l + r) / 2;
	MSort(dest, src, l, m);
	MSort(dest, src, m + 1, r);
	int tm = m;
	m++;
	for (int i = l; i <= r;)
	{
		while (l <= tm && (m > r || src[l] <= src[m]))
		{
			dest[i] = src[l];
			i++;
			l++;
		}
		while (m <= r && (l > tm || src[m] < src[l]))
		{
			dest[i] = src[m];
			i++;
			m++;
		}
	}
}

void MSortStart(vector<int>& v)
{
	vector<int> copy(v);
	MSort(copy, v, 0, v.size() - 1);
}

int main() {
#ifdef DEBUG
	freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
#endif
	int n;
	cin >> n;
	std::vector<int> as(n), bs(n);
	for (auto& a : as)
		cin >> a;

	for (auto& a : bs)
		cin >> a;
	InsertSort(as);
	InsertSort(bs);
	int ans = 0;
	for (int i = 0; i < n; i++)
	{
		ans += abs(as[i] - bs[i]);
	}
	cout << ans << endl;
	return 0;
}