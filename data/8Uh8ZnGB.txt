#include <bits/stdc++.h>

using namespace std;
namespace array_stack {
// шаблон элементов стека
    template<typename T>
    struct stack {
    public:

        // конструктор стека
        stack() : data(new T[data_size]) {} // инициализация динамического массива (3)

        // конструктор стека с заранее определенным размером, для создания динамического массива
        explicit stack(size_t reserve_size) : data(new T[reserve_size]),
                                                 data_size(reserve_size) {}// инициализация динамического массива (4)

        // деконструктор стека с освобождением памяти
        ~stack() { // 1
            delete[] data; // 1
        }

        // добавление элемента в конец стека
        void push(T value) { // 11 + n
            // если размер стека становится больше, чем размер динамического массива, то увеличиваем размер массива
            if (stack_size == data_size) // 1 + 6 + n
                // изменение размера массива (удваивается размер)
                resize(); // 6 + n
            // присваиваем верхнему элементу value и увеличиваем размер стека на 1
            data[stack_size++] = value; // 2 + 2
        }

        // удаление верхнего элемента стека
        void pop() { // 2
            // проверка не пустой ли стек
            if (!empty()) // 1 + 1
                // уменьшаем размер стека на 1
                --stack_size; // 1
        }

        // получение верхнего элемента стека
        T top() { // 4
            // проверка пустой ли массив
            if (empty()) // 1
                // если пустой, то падает с ошибкой
                throw out_of_range("stack is empty");
            // возвращаем верхний элемент
            return data[stack_size - 1]; // 3
        }

        // получение информации о величине
        size_t size() { // 1
            return stack_size; // 1
        }

        // возвращет true, если стек пуст, иначе false
        bool empty() { // 2
            return stack_size == 0; // 2
        }

        // очищение стека
        void clear() { // 6
            // приводим все значения к изначальным
            stack_size = 0; // 1
            data_size = 1; // 1
            // очищаем память
            delete[] data; // 1
            // создаем новый стек
            data = new T[data_size]; // 3
        }

        // изменение заранее определенного размера, для создания динамического массива
        void change_reserve_size(size_t reserve_size) { // 7 + n
            // если размер стека больше, требуемого reserve_size, то падает с ошибкой
            if (stack_size > reserve_size) // 1
                throw length_error("reserve size is smaller then stack size");
            resize(reserve_size); // 6 + n
        }

        // возвращает указатель на начало стека
        T *begin() { // 1
            return data;
        }

        // возвращает указатель на конец + 1 стека
        T *end() { // 2
            return &data[stack_size];
        }

    private:

        // создание переменных. Создаем в private, чтобы пользователь не имел к ним доступа
        size_t data_size = 1; // размер динамического массива
        size_t stack_size = 0; // размер стека
        // динамический массив, в котором будут храниться значения
        T *data;

        // изменение размера динамического массива
        void resize(size_t new_size) { // 6 + n
            // создаем новый динамичский массив, с нужным размером
            T *new_data = new T[new_size]; // 3
            // по-байтово копируем значения из data в new data
            memcpy(new_data, data, stack_size * sizeof(T)); // n, где n - это stack_size
            // изменяем переменную размера дин массива
            data_size = new_size; // 1
            // очищаем память
            delete[] data; // 1
            // приравниваем
            data = new_data; // 1
        }

        // изменение размера динамического размера (без указания размера, те увеличиваем в два раза его размер)
        void resize() { // 9 + n
            // проверка на переполнение size_t
            if (data_size < SIZE_MAX / 2) // 2
                resize(data_size * 2); // 7 + n
            else
                resize(SIZE_MAX); // 6 + n
        }
    };
}
namespace sorting{

    // шаблоны структуры сортировки и компаратора
    template<typename T, typename Compare>
    // на вход приходят начало и конец указателями (сортируем элементы, принадлежащие промежутку [t_begin, e_end)) и компаратор
    void sort(T t_begin, T t_end, Compare comp) {
        // проходим по всем элементам, начиная со второго
        for (T it = t_begin + 1; it != t_end; ++it) { // (10 + log(n) * 9 + n * 3) * (n - 1)
            // если компаратор соответствует сортировке, то ничего не делаем
            if (!comp(*it, *(it - 1))) // 4
                continue;
            // для поиска в левой части контейнера создаем left и right (границы поиска)
            T left = t_begin, right = it; // 2
            // если comp(*left, *it) == false, то it должен быть на месте left
            if (comp(*left, *it)) { // log(n) * 9 + 4
                // иначе ищем куда надо вставить it, с помощью бинарного поиска
                T mid = left + distance(left, right) / 2; // 4
                // бинарный поиск
                while (mid != left) { // log(n) * 9, где n - кол-во элементов до нашего it
                    if (comp(*mid, *it)) { // 3 + 1
                        left = mid; // 1
                    } else {
                        right = mid; // 1
                    }
                    mid = left + distance(left, right) / 2; // 4
                }
            } else
                right = left; // 1
            // свапаем все элементы до right
            for (T t = it; t != right; --t) { // n * 3, где n - кол-во элементов до нашего it
                swap(*t, *(t - 1)); // 3
            }
        }
    }

    template<typename T>
    // сортировка без указания компаратора
    void sort(T t_begin, T t_end) {
        sort(t_begin, t_end, [](auto &it1, auto &it2) { return it1 < it2; });
    }
}
int main() {
    array_stack::stack<int> s(100);
    int a;
    cin >> a;
    for (int i = 0; i < a; ++i) {
        int t;
        cin >> t;
        if (t == 0) {
            int b;
            cin >> b;
            s.push(b);
        } else if (t == 1) {
            cout << s.top() << endl;
        } else if (t == 2) {
            sorting::sort(s.begin(), s.end());
            for (auto it = s.begin(); it != s.end(); ++it) {
                cout << *it << ' ';
            }
            cout << endl;
            //cout << s.size() << endl;
        } else if (t == 3) {
            s.pop();
        }
    }
    return 0;
}
