const int maxn = 50000 + 100;
int n;
int nxt[maxn];

class Solution {
public:
    void getNext(const string &s) {
        nxt[0] = -1;
        int j = -1;
        for(int i = 1; i < n; ++i) {
            while(j != -1 && s[i] != s[j + 1]) {
                j = nxt[j];
            }
            if(s[i] == s[j + 1]) {
                ++j;
            }
            nxt[i] = j;
        }
    }

    int kmp(string &s, string &rs) {
        int j = -1;
        int ret = 0;
        for(int i = 0; i < n; ++i) {
            while(j != -1 && rs[i] != s[j + 1]) {
                j = nxt[j];
            }
            if(rs[i] == s[j + 1]) {
                ++j;
            }
            if(j == n - 1) {
                return n;
            }
        }
        return j + 1;
    }
    
    string shortestPalindrome(string s) {
        n = s.length();
        string rs = s;
        reverse(rs.begin(), rs.end());
        getNext(s);
        int maxLen = kmp(s, rs);
        return rs.substr(0, s.length() - maxLen) + s;
    }
};