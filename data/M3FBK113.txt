В .h файле есть класс
```
#pragma once
#include "BaseInteractiveObject.generated.h"
class UStaticMeshComponent;
class USceneComponent;
UCLASS(Blueprintable)
class ABaseInteractiveObject: public AActor
{
	GENERATED_UCLASS_BODY()
public:
        // эти параметры добавляются
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	USceneComponent* SceneRoot = nullptr;
	UPROPERTY(BlueprintReadWrite, EditAnywhere)
	UStaticMeshComponent* OverlapAreaNative = nullptr;
}; 
```


С++ тоже очень прост

```
#include "VehicleGame.h"
#include "Actors/BaseInteractiveObject.h"
ABaseInteractiveObject::ABaseInteractiveObject(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	SceneRoot = CreateDefaultSubobject<USceneComponent>("SceneRoot");
	SetRootComponent(SceneRoot);
	OverlapAreaNative = CreateDefaultSubobject<UStaticMeshComponent>("OverlapAreaNative");
	OverlapAreaNative->SetupAttachment(SceneRoot);
	OverlapAreaNative->SetGenerateOverlapEvents(true);
	OverlapAreaNative->SetCollisionProfileName(FName("OverlapAll"));
}
```
Есть большая и сложная иерархия наследников от С++ класса с их DefaultSceneRoot компонентами (edited) 
После добавления компонентов появляются ошибки вида
```
Template Mismatch during attachment. Attaching instanced component to template component. Parent 'SceneRoot' (Owner 'Default__BP_BaseCheckpoint_C') Self 'OverlapAreaNative' (Owner 'Challenge_Checkpoint_Common_C_1').
[2022.11.25-16.05.53:956][  0]LogOutputDevice: Error: Ensure condition failed: false [File:D:\build\++UE5\Sync\Engine\Source\Runtime\Engine\Private\Components\SceneComponent.cpp] [Line: 1924]
Template Mismatch during attachment. Attaching instanced component to template component. Parent 'SceneRoot' (Owner 'Default__BP_BaseCheckpoint_C') Self 'OverlapAreaNative' (Owner 'Challenge_Checkpoint_Common_C_1').
```

Решение вида Transient не нравится
```
UPROPERTY(BlueprintReadWrite, EditAnywhere, Transient)
SceneRoot = CreateDefaultSubobject<USceneComponent>("SceneRoot", true);
SetRootComponent(SceneRoot);
OverlapAreaNative = CreateDefaultSubobject<UStaticMeshComponent>("OverlapAreaNative", true);
```

Есть ли другие решения?
Как задать USceneComponent так, чтобы в нее автоматически скопировалась позиция из "DefaultSceneRoot" ?
Опять же, есть решение по ручному копированию на PreRegisterAllComponents, но это тоже костыль
Есть ли способ автоматически скопировать данные из BP компоненты в С++ компоненту (например, была BP OverlapArea, а мы хотим ее перенести в С++ OverlapAreaNative)?
Чтобы скопировались параметры и у Default классов и у инстансов на картах

Есть способ переноса связей в Blueprints через DefaultsEngine.ini через секцию
```
[CoreRedirects]
+PropertyRedirects=(OldName="/Game/Core/Blueprints/Exploration/MapObjective/BP_BaseInteractiveObject.OverlapArea",NewName="/Script/VehicleGame.BaseInteractiveObject.OverlapAreaNative")
```

Но во всех дефолтных классах в BP параметры приходится переносить руками, и для объектов на карте тоже
Есть ли нормальные советы по переводу проекта из BP в C++, а не "отписка" на официальной документации для начинающих
Типичные ошибки, проблемы, подводные камни и т.д.

Как правильно скопировать все Property из одной компоненты в другую?

```
TArray<uint8> NodeData;
FMemoryWriter NodeArchiveWriter(NodeData, true);
NodeArchiveWriter.ArSerializingDefaults = 1;
NodeArchiveWriter.ArNoDelta = true;
FObjectAndNameAsStringProxyArchive NodeProxyArchiveWriter(NodeArchiveWriter, true);
BPComponent->SerializeScriptProperties(NodeProxyArchiveWriter);
FMemoryReader NodeArchiveReader(NodeData, true);
NodeArchiveReader.ArSerializingDefaults = 1;
NodeArchiveReader.ArNoDelta = true;
FObjectAndNameAsStringProxyArchive NodeProxyArchiveReader(NodeArchiveReader, true);
CppComponent->SerializeScriptProperties(NodeProxyArchiveReader);
```
Решение не всегда работает, иногда (50% случаев) после копирования компонента не отображается в редакторе