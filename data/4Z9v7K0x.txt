


//creates a parent process and two child processes
//the parent process creates an array "A" of size "n>1" and fills it with random numbers
//child A calculates the sum of elements in the array "A" of size "n>1" at the odd positions
//child B calculates the sum of elements in the array "A" of size "n>1" at the even positions
//the parent process waits for the child processes to finish and then calculates the sum of elements in the array "A" of size "n>1" from the sums of child A and child B
//the parent process prints the subtotal of child A, the subtotal of child B, and the total sum





#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <fcntl.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/mman.h>



 //struct that holds the process id and sum of child A
   typedef struct childA{
        pid_t pidA;
        int sumA;
        //get process id of child A
      /* pid_t getPidA(){
            return pidA;
        }*/ 
    }childA;
    //struct that holds the process id and sum of child B
    typedef struct childB{
        pid_t pidB;
        int sumB;
    }childB;
    
    
int *createArray(int n)
{	
    int *A = (int *)malloc(n * sizeof(int));
    FILE *fptr;
    fptr = fopen("numbers.txt", "r");
    if (fptr == NULL)
    {
        printf("Error!");
       // exit(1);
    }
    for (int i = 0; i < n; i++)
    {
        fscanf(fptr, "%d", &A[i]);
    }
    fclose(fptr);
    return A;
}
   
    
    
    

int main(int argc, char *argv[])
{

	

   // int n = atoi(argv[1]);
   // int A[n];
    int i = 0;
   /* int sumA = 0; 
    int sumB = 0; */ 
    childA* childA;
    (*childA).sumA = 0;
  //  (*childA).pidA;
    childB* childB;
    (*childB).sumB = 0;
   // (*childB).pidB;
    int sumTotal = 0;
    int statusA;
    int statusB;
   /* pid_t pidA;
    pid_t pidB; */
    int num = 0;
    int total = 0;
    int n;
    
    /* the size (in bytes) of shared memory object */
	const int SIZE = 1048576;
	/* name of the shared memory object */
	const char *name = "sharedTotalSum";
	/* strings written to shared memory */
	const char *message_0 = "childA";
	const char *message_1 = "childB";
	/* shared memory file descriptor */
	int shm_fd;
	/* pointer to shared memory obect */
	/*void *childA;
	void *childB;*/
	/* create the shared memory object */
	shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);
	/* configure the size of the shared memory object */
	ftruncate(shm_fd, SIZE);
	/* memory map the shared memory object */
	childA = mmap(0, SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);
	childB = mmap(0, SIZE, PROT_WRITE, MAP_SHARED, shm_fd, 0);
    printf("Enter the size of the array: ");

    scanf("%d", &n);
    if (n < 2)
    {
        printf("Invalid size of array");
        return 0;
    }
    int *A = createArray(n);
    for (int i = 0; i < n; i++)
    {
        printf("%d \n", A[i]);
    }
   // printf("array size: %d ", n);
    

/*    for(i = 0; i < n; i++){
        A[i] = num++;
        printf("%d ", A[i]);
    }
*/

 	//gets process id of parent
    printf("pid of parent: %d\n", getpid());
    (*childA).pidA = fork();
    if((*childA).pidA == 0)
    {
        //child A
        for(i = 1; i < n; i += 2){
            (*childA).sumA += A[i];
        }
        printf("subtotal of child A: %d\n", (*childA).sumA);
        //prints process id of child A
        printf("pid of child A: %d\n", (*childA).pidA);
      // return 0;
    
    }
        else
        {

        (*childB).pidB = fork();
        if((*childB).pidB == 0)
        {
            //child B
            for(i = 0; i < n; i += 2){
                (*childB).sumB += A[i];
            }
            printf("subtotal of child B: %d\n", (*childB).sumB);
            //prints process id of child B
            printf("pid of child B: %d\n", (*childB).pidB);

        //return 0;
        
        }   
            else
            {

 		sumTotal = (*childB).sumB;
                //parent
                 waitpid((*childA).pidA, &statusA, 0);
                waitpid((*childB).pidB, &statusB, 0);
               
              //  printf("total sum: %d\n", sumTotal);

                //retrieves the sum of child A and child B from the structs and prints the total sum
                //printf("total sum: %d\n", (* + chi)ldB.sumB);
                 
   		 printf("total sum: %d\n", sumTotal);
            }
    }
   
  // return 0;

    
    
    
}





