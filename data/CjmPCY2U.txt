// Напишите функцию supersum складывающую беззнаковые "длинные" little-endian числа C = A + B.
// Программа возвращает 1 + индекс последнего ненулевого байта числа C в регистре eax (иными словами
// размер числа C).

// eax передается указатель на число A
// в ebx - указатель на B
// в ecx - указатель на С.
// В esi лежит размер числа A в байтах.
// B edi размер числа B в байтах.
    .global supersum

supersum:
    push %edi
    push %esi
    push %edx // тут будем хранить размер меньшего числа
    push %eax
    push %ecx
    push %ebx
    movl $0, %edx
    jmp take_min

take_min:
    cmp %esi, %edi // определяем какое из слов короче, а нужно ли это????
    jg A_shorter
    movl %edi, %esi
    movl $0, %edi
    jmp sum_1
A_shorter:
    movl $0, %edi
    jmp sum_1

sum_1:
    cmp %edi, %esi
    je finish_him // дозаписываем число до конца
    movl $0, %edx
    add (%eax, %edi, 1), %dh
    add (%ebx, %edi, 1), %dh
    mov %dh, (%ecx, %edi, 1)
    incl %edi
    add %dl, (%ecx, %edi, 1)
    jmp sum_1

finish_him:
    pop %edi
    movl $0, %edx
    cmp %edi, %esi
    jle B_bigger
    jg A_bigger
B_bigger:
    push %edi
    cmp %esi, %edi
    jl fin1
    movl $0, %edx
    add (%ebx, %esi, 1), %dh
    add %dh, (%ecx, %esi, 1)
    incl %esi
    jmp B_bigger
A_bigger:
    pop %esi
    push %edi
    cmp %edi, %esi
    jl fin2
    movl $0, %edx
    add (%eax, %edi, 1), %dh
    add %dh, (%ecx, %edi, 1)
    incl %edi
    jmp A_bigger

fin1:
    movl %edi, %eax
    pop %edi
    pop %esi
    jmp fin
fin2:
    movl %edi, %eax
    pop %edi
    jmp fin

fin:
    pop %edx
    movl %eax, %edx
    pop %eax
    pop %ecx
    pop %ebx
    movl %edx, %eax
    ret
