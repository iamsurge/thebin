#include <iostream>

struct A
{
    A() { std::cout << "A"; }
};

struct B
{
    B() { std::cout << "B"; }
};


template<int i, typename ...Ts>
struct Holder {};

// Your current implementation:
template<int i, typename ...Ts>
void f( Holder<i, Ts...> )
{
    std::cout << i;
    ( Ts{}, ... );
}

template<typename T>
struct Trait{};

template<int i, typename ...Ts>
struct Trait<Holder<i, Ts...>>
{
    static void g()
    {
        std::cout << i;
        ( Ts{}, ... );
    }
};

// Updated version with no argument
template<typename HolderT>
void g()
{
    Trait<HolderT>::g();
}

int main()
{
    f( Holder<1, A, B, A>{} );
    std::cout << "\n";
    g<Holder<1, A, B, A>>();
    return 0;
}