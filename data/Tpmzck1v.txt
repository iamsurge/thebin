#include <cctype>
#include <iostream>
#include <stdexcept>
#include <string>

#define sz(x) (int)x.size()

using namespace std;

const char hex_digits[] = "0123456789ABCDEF";

string string_to_hex(const string &input) {

	string output;
	output.reserve(sz(input) * 2);
	for (int i = 0; i < sz(input); i++) {
		output.push_back(hex_digits[input[i] >> 4]);
		output.push_back(hex_digits[input[i] & 15]);
	}
	return output;
}

int hex_value(unsigned char hex_digit) {
	static const signed char hex_values[256] = {
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,  1,  2,  3,  4,  5,
	    6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	    -1, -1, -1, -1,
	};
	int value = hex_values[hex_digit];
	if (value == -1)
		throw invalid_argument("invalid hex digit");
	return value;
}

string hex_to_string(const string &input) {
	const int len = sz(input);
	if (len & 1)
		throw invalid_argument("odd length");

	string output;
	output.reserve(len / 2);
	for (int i = 0; i < len; i += 2) {
		int hi = hex_value(input[i]);
		i++;
		int lo = hex_value(input[i]);
		output.push_back(hi << 4 | lo);
	}
	return output;
}

int convert(char item) {
	if (!isalpha(item))
		return int(item - '0');
	switch (item) {
	case 'A':
		return 10;
		break;
	case 'B':
		return 11;
		break;
	case 'C':
		return 12;
		break;
	case 'D':
		return 13;
		break;
	case 'E':
		return 14;
		break;
	case 'F':
		return 15;
		break;
	}
}

bool is_valid(const string &text) {
	for (int i = 0; i < sz(text); i++) {
		if (!isupper(text[i]))
			return false;
	}
	return true;
}

void apply_vignere_cipher(string &text, const string &key) {
	if (is_valid(text)) {
		for (int i = 0; i < 4; i++)
			text[i] =
			    char(int(text[i] - 'A' + key[i % sz(key)] - 'A') % 26 + 'A');
	} else {
		string hex_key = string_to_hex(key);
		for (int i = 0; i < 8; i++) {
			int temp = (convert(text[i]) + convert(hex_key[i])) % 16;
			text[i] = hex_digits[temp];
		}
	}
}

void apply_xor_operation(string &text1, const string &text2) {
	if (is_valid(text1))
		text1 = string_to_hex(text1);
	string text3;
	if (is_valid(text2))
		text3 = string_to_hex(text2);
	int temp1, temp2, xor_value;
	for (int i = 0; i < 8; i++) {
		temp1 = convert(text1[i]);
		temp2 = convert(text3[i]);
		xor_value = temp1 ^ temp2;
		text1[i] = hex_digits[xor_value];
	}
}

int main() {
	string plain_text, key1, key2;
	getline(cin, plain_text);
	getline(cin, key1);
	getline(cin, key2);

	string l_str = plain_text.substr(0, 4), r_str = plain_text.substr(4, 4);
	for (int i = 0; i < 2; i++) {
		swap(l_str, r_str);
		apply_vignere_cipher(l_str, (i == 0 ? key1 : key2));
		apply_xor_operation(l_str, r_str);
		cout << l_str << ' ' << r_str << endl;
	}

	return 0;
}