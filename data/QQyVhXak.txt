#include<bits/stdc++.h>
using namespace std;
struct Treap
{
	struct Node
	{
		Node *l,*r;
		int key,pr,sz;
		bool rev;
		Node(){l=r=NULL;}
		Node(int _key)
		{
			key=_key;
			pr=rand();
			sz=1;
			l=r=NULL;
		}
		void con()
		{
			sz=1;
			if(l)sz+=l->sz;
			if(r)sz+=r->sz;
		}
	};

	Node *root;
	Treap(){root=NULL;}

	void push(Node *T)
	{
	    if(T&&T->rev)
        {
            T->rev=false;
            swap(T->l,T->r);
            if(T->l)T->l->rev^=true;
            if(T->r)T->r->rev^=true;
        }
	}

	void Split(Node *T,Node *&L,Node *&R,int key)
	{

		if(T==NULL)
		{
			L=R=NULL;
			return;
		}
		//push(T);
		if(key>=T->key)
		{
			L=T;
			Split(T->r,L->r,R,key);
		}
		else
		{
			R=T;
			Split(T->l,L,R->l,key);
		}
		T->con();
	}

	void Merge(Node *&T,Node *L,Node *R)
	{
	    //push(L);push(R);
		if(L==NULL)
		{
			T=R;
			return;
		}
		if(R==NULL)
		{
			T=L;
			return;
		}
		if(L->pr > R->pr)
		{
			T=L;
			Merge(T->r,L->r,R);
		}
		else
		{
			T=R;
			Merge(T->l,L,R->l);
		}
		T->con();
	}

	void Split_sz(Node *T,Node *&L,Node *&R,int sz)
	{
		if(T==NULL)
		{
			L=R=NULL;
			return;
		}
		//push(T);
		int tsz=1;
		if(T->l)tsz+=T->l->sz;
		if(tsz>sz)
		{
			R=T;
			Split_sz(T->l,L,R->l,sz);
		}
		else
		{
			L=T;
			Split_sz(T->r,L->r,R,sz-tsz);
		}
		T->con();
	}

	void Insert(int key)
	{
		Node *L,*R,*N=new Node(key);
		Split(root,L,R,key);
		Merge(L,L,N);
		Merge(root,L,R);
		//delete L;
		//delete R;
	}

	void Delete(int key)
	{
		Node *L,*R,*N;
		Split(root,L,R,key);
		Split(L,L,N,key-1);
		delete N;
		Merge(root,L,R);
		//delete L;
		//delete R;
	}

	void Walkthrough(Node *T)
	{
	    if(T==NULL)return;
	    Walkthrough(T->l);
	    cout<<T->key<<' ';
	    Walkthrough(T->r);
	}

	int How_many_small(int key)
	{
	    Node *L,*R;
	    Split(root,L,R,key);
	    int ans=0;
	    if(L)ans=L->sz;
	    Merge(root,L,R);
	    //delete L;
	    //delete R;
	    return ans;
	}

	int Insert_with_query(int key)
	{
	    Node *L,*R,*N=new Node(key);
	    Split(root,L,R,key-1);
	    int ans=0;
	    if(L)ans=L->sz;
	    Merge(L,L,N);
	    Merge(root,L,R);
	    return ans;
	}

	void heapify(Node *T)
    {
        if(T==NULL)return;
        Node *maxi=T;
        if(T->l!=NULL && T->l->pr > maxi->pr)
            maxi=T->l;
        if(T->r!=NULL && T->r->pr > maxi->pr)
            maxi=T->r;
        if(T!=maxi)
        {
            swap(T->pr,maxi->pr);
            heapify(maxi);
        }
    }

    Node* fast_build(int *a,int a_sz)///O(N)
    {
        ///a[0]...a[a_sz-1]
        if(a_sz==0)return NULL;
        int mid=a_sz/2;
        Node *T=new Node(a[mid]);
        printf("T->key=%d, a_sz==%d, mid==%d and a[mid]==%d\n\n",T->key,a_sz,mid,a[mid]);
        T->l=fast_build(a,mid);
        T->r=fast_build(a+mid+1,a_sz-mid-1);
        heapify(T);
        T->con();
        return T;
    }

    void reverse_seg(Node *T,int l,int r)
    {
        Node *L,*R,*N;
        Split_sz(root,L,R,r);
        Split_sz(L,L,N,l-1);
        N->rev^=true;
        Megre(L,L,N);
        Merge(root,L,R);
    }
};
int main()
{

	return 0;
}
	/*T.Insert(23);
	T.Walkthrough(T.root);cout<<endl;
	T.Insert(34);
	T.Walkthrough(T.root);cout<<endl;
	T.Insert(56);
	T.Walkthrough(T.root);cout<<endl;
	T.Delete(23);
	T.Walkthrough(T.root);cout<<endl;
	T.Insert(128);
	T.Walkthrough(T.root);cout<<endl;
	T.Insert(2);
	T.Walkthrough(T.root);cout<<endl;
	T.Delete(128);
	T.Walkthrough(T.root);cout<<endl;
	T.Delete(2);
	T.Walkthrough(T.root);cout<<endl;*/
