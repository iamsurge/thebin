class Solution:
        
    # Version shared by okitsme_Parth:
    def commonElements0(self,A, B, C, n1, n2, n3):
        a = 0
        b = 0
        c = 0
        r = []
        while a < n1 and b < n2 and c < n3:
            if A[a] == B[b] == C[c]:
                if A[a] not in r:
                    r.append(A[a])
                a += 1
                b += 1
                c += 1
            elif A[a] < B[b]:
                a += 1
            elif B[b] < C[c]:
                b += 1
            else:
                c += 1
                
        return sorted(r) if r else [-1]

    # My refactored version based on okitsme_Parth's:
    def commonElements1(self,A, B, C, n1, n2, n3):
        i1 = i2 = i3 = 0
        result = []
        while i1 < n1 and i2 < n2 and i3 < n3:
            if A[i1] < B[i2]:
                i1 +=1
            elif B[i2] < C[i3]:
                i2 += 1
            elif C[i3] < A[i1]:
                i3 += 1
            else:
                result.append(A[i1])
                i1 += 1
                i2 += 1
                i3 += 1
                
        return result

    # I didn't like doing 3 comparisons every time one index value changed,
    # or indexing the array when the index value hadn't changed.
    # This is my stab at using iterators to rememdy that and get out of the
    # main loop as soon as any list hits the end.
    
    # I also added while loops in the "else:" clause to eliminate duplicate
    # values.  The statement is (IMHO) not clear about whether duplicates are
    # possible within the lists, but the reference solution appears to
    # return only unique values.

    def commonElements2(self, A, B, C, n1, n2, n3):
        result = []
        i1, i2, i3 = iter(A), iter(B), iter(C)
        
        try:
            x1, x2, x3 = next(i1), next(i2), next(i3)
            while True:
                if x1 < x2: 
                    x1 = next(i1)
                elif x2 < x3: 
                    x2 = next(i2)
                elif x3 < x1: 
                    x3 = next(i3)
                else:
                    result.append(x1)
                    while x2 == x1: x2 = next(i2)
                    while x3 == x1: x3 = next(i3)
                    while x1 < x2: x1 = next(i1)

        except StopIteration:
            pass
    
        return result

    commonElements = commonElements1 ### Reference solution

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Test code

import timeit
import random

def random_select(seq, p=0.5):
    R = random.random
    return filter(lambda x: R()<p, seq)

A = list(random_select(range(100000), .1))
B = list(random_select(range(100000), .1))
C = list(random_select(range(100000), .1))
nA = len(A)
nB = len(B)
nC = len(C)
S = Solution()

result = S.commonElements(A, B, C, nA, nB, nC)
r0 = S.commonElements0(A, B, C, nA, nB, nC)
r1 = S.commonElements1(A, B, C, nA, nB, nC)
r2 = S.commonElements2(A, B, C, nA, nB, nC)
assert r0 == result, 'mismatch in r0'
assert r1 == result, 'mismatch in r1'
assert r2 == result, 'mismatch in r2'


t0 = timeit.timeit(
        stmt='S.commonElements0(A, B, C, nA, nB, nC)',
        setup='from __main__ import S, A, B, C, nA, nB, nC',
        number=100)
t1 = timeit.timeit(
        stmt='S.commonElements1(A, B, C, nA, nB, nC)',
        setup='from __main__ import S, A, B, C, nA, nB, nC',
        number=100)
t2 = timeit.timeit(
        stmt='S.commonElements2(A, B, C, nA, nB, nC)',
        setup='from __main__ import S, A, B, C, nA, nB, nC',
        number=100)

print('Time (in seconds) to run 100 times on list sizes', (nA,nB,nC))
print('  with', len(result), 'items in common:')
print('Original:       ', round(t0, 3))
print('Refactored:     ', round(t1, 3))
print('Using iterators:', round(t2, 3))

