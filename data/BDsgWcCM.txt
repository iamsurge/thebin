//The function
	Void HandleTargetPrediction (Actor Projectile, Vector2 SpreadHorz, Vector2 SpreadVert)
	{
		Vector3 OldVel;
		If (!Projectile || !Target) Return;
		
		//Target has no velocity for VelIntercept to work with. This is almost always the case for normal NPCs, which move using small teleport steps, instead of actual movement.
		If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0))
		{
			OldVel = Target.Vel;
			//Temporarily change the zero velocity actors' vel to the difference between their current and last ticks' position.
			//If (TicsSinceLastMove)
			//{	Target.Vel = Level.Vec3Diff (Target.Pos,LastEnemyPosition) / TicsSinceLastMove;a_log ("divided");}
			//Else
				Target.Vel = Level.Vec3Diff (Target.Pos,LastEnemyPosition);
			If ((Target.Vel.X == 0 && Target.Vel.Y == 0 && Target.Vel.Z == 0)) //Still no velocity
			{a_log ("no velocity still, falling back to normal aiming");
				Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
				Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
				//Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
				Target.Vel = OldVel;
				Return; //Just add in the projectile spread and finish.
			}
			Console.Printf ("The targets' current pos is: %f, %f, %f",Target.Pos.X,Target.Pos.Y,Target.Pos.Z);
			Console.Printf ("The targets' last pos was: %f, %f, %f",LastEnemyPosition.X,LastEnemyPosition.Y,LastEnemyPosition.Z);
			Console.Printf ("The targets' velocity is now: %f, %f, %f",Target.Vel.X,Target.Vel.Y,Target.Vel.Z);
			Console.Printf ("TicsSinceLastMove is: %d",TicsSinceLastMove);
			Console.Printf ("==============================================");
			Projectile.VelIntercept (Target);
			//Projectile.Angle += FRandom (SpreadHorz.X,SpreadHorz.Y);
			//Projectile.Pitch += FRandom (SpreadVert.X,SpreadVert.Y);
			Projectile.Vel3DFromAngle (Projectile.Speed,Projectile.Angle,Projectile.Pitch);
			Target.Vel = OldVel;
		}
		//Target has velocity, like if it's a player or a custom actor with velocity-based movement.
		Else
			Projectile.VelIntercept (Target);
	}

//The Tick() override on the shooter.

	Override Void Tick()
	{
		Actor.Tick();
		
		/*If (Target && Target.Pos == LastEnemyPosition)
			TicsSinceLastMove++;
		Else
			TicsSinceLastMove = 0;
		*/
		If (Target && Target.Pos != LastEnemyPosition) LastEnemyPosition = Target.Pos;
		
		//Unrelated stuff.
		If (!Master || IsFrozen() || IsDead(Self) && bFallOnDeath) Return;
		
		SetOrigin (Master.Vec3Offset(TurretOffsets.X,TurretOffsets.Y,Master.Height+TurretOffsets.Z),True);
	}
