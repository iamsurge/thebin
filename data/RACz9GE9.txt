# Exam Review Nov 19 2022

# LABS
# Ch 2-14... all Labs!
# Ch 21-34 just ADDITIONAL LABS, but important practice!
# Use Submit Mode!!!

# Watch your string input and output
# 1
# myVar = input().strip()
# # 2
# print("some stuff", end=" ") # if you ever override end...
# print() # print(end="\n")

# print("Clean new line!")

# Comp 1: Basic syntax and knowledge: operators, data types, etc
# Comp 2: Control Flow
# Comp 3: Modules and Files

# Comp 1: Basic syntax and knowledge: operators, data types, etc

# # Common Data Types
# str
# int
# floats
# list # []
# tuple # () immutable... Python sees any x,y,z as (x,y,z)... return x,y --> return (x,y)
# set # {} no order, no duplicate (all unique)
# dict # {k:v}
#
# # important modules
# math
# csv

# OPERATORS
# = # assigns a value
# == # asking a question: are they equal? for a CONDITION
# +
# -
# *
# /
# % # modulo, int remainder... "How many whole things didn't fit?"
# // # floor division... the last even division, same as math.floor(x/y)
# <
# >
# <=
# >=
# ** # raise to a power... math.pow(x, y)
# += # increment
# -= # decrement
# != # asking for a condition... NOT EQUAL
# # keyword used like operators
# in # if _someValue_ in _someContainer_
# not # if not _someValue in _someContainer_
# and
# or # any one True means whole condition is True... limit OR to 2 conditions

# COMP 2 CONTROL FLOW
# the HOW stuff
# IF... if, if/else, if/elif, if/elif/else, etc
# LOOPS
# WHILE - an IF that repeats
# FOR - looping over a container... or a known number of times
# for _item_ in _container_:
# for item in myList:
# for key in myDict: # value for "key" ... myDict[key]
# for n in range(5): # range(0, 5) --> [0, 1, 2, 3, 4]
# for i in range(len(myList)): # myList[i]

# FUNCTIONS
# defining/writing vs calling
# parameter are special "variables"... they don't work like regular "outside" variables
# parameters vs arguments
# a function has ONE particular job
# return vs print() vs... write a file, whatever its job is
# functions that are asked for in a question will BE TESTED
# method are functions that belong to a particular type/class

# def someFunction(x, y):
#     return x + y
#
# if __name__ == "__main__":
#     myInput = int(input())
#     myOtherInput = int(input())
#     num = someFunction(myInput, myOtherInput)
#     print(num)

# See "tasks" in the last section of Ch 10, 11, 13, 14 for function writing practice
# # CodingBat also has good function-based Python questions:
# # https://codingbat.com/python

# # BUILT-IN FUNCTIONS
# input()
# print()
# len()
# range()
# sum()
# min()
# max()
# round() # is a built-in, cousins math.ceil() and math.floor()
# type() # type(5).__name__ --> int
# list()
# set()
# tuple()
# dict()
# open() # IO/file... .read(), .readlines(), .write()
# reversed() # returns reversed list... list.reverse() modifies in place, so it DOES NOT return a list
# sorted() # same, returns sorted list... list.sort() doesn't

# help(str)
# print(dir(str))
# help(str.isspace)


# STRINGS
# be able to slice like it's 2nd nature: myStr[start:stop:step]
myStr = "abc"
revStr = myStr[::-1]
print(revStr)

# KNOW YOUR WHITESPACE
# " " # # ... and a lot of other Unicode spaces
# "\n"
# "\r"
# "\t"
# "\f"

# STRING METHODS
# "stuff I want to put together {}".format(var) # or similar f strings
# myString.strip() # input().strip()
# myString.split() # RETURNS a list of smaller strings
# ",".join(listOfStrings)
# myString.replace(oldStr, newStr) # remove... myString.replace(oldStr, "")
# myString.find(subStr) # returns INT index, or -1 if it doesn't, compares to .index(subStr)
# myString.count(subStr) # return INT count of num times occurs
# case: myString.lower(), myString.upper()...
# is/Boolean: isupper(), islower(), isalpha(), isdigit(), isalnum(), isspace()

# LISTS
# again be able to slice

# LIST METHODS
# # +
# myList.append(item)
# myList.insert(i, item)
# myList.extend(anotherList)
# # -
# myList.pop(0) # by index
# myList.remove(item) # by value
# # other mods
# myList.sort()
# myList.reverse()
# myList.count(item)
# # also rans
# myList.clear()
# myList.copy()
# myList.index(item)

# DICTS
# use the key like an index
# myDict[key] # retrieve the value for that key, so like get()
# myDict[key] = value # assign (new) value for that key, so like update({k:v})
# myDict.keys()
# myDict.values()
# myDict.items() # for k, v in myDict.items():

# # MODULES
# # math and csv
# # remember there are different import styles that change how you reference them

# MATH MODULE
# import math # <-- full import
# math.factorial(x)
# math.ceil(x.yz)
# math.floor(x.yz)
# math.pow(x, y) # not to be confused with math.exp(x), which math.e to a power
# math.sqrt(x)
# math.fabs() # similar to built-in abs()
# math.pi
# math.e
#
# # PARTIAL IMPORT
# from math import factorial # --> not math.factorial() but factorial()
# from math import ceil, floor # --> ceil() and floor()
#
# # ALIAS IMPORT
# import math as m # m.sqrt() not math.sqrt()


# FILES!!!
# with open("test.txt", "r") as f:
#     contents = f.readlines() # a list of line-by-line strings
# print(contents)
# for line in contents:
#     line = line.strip()
#     print(line)

# CSV module
import csv
with open("mock_data.csv", "r") as f1:
    contents = list(csv.reader(f1)) # csv.reader(f1, delimiter="\t")
# print(contents) # [ ['1', 'Remington', 'Shilling', 'rshilling0@wsj.com', 'Male', '1.71.141.52'], [another list]... ]

with open("output_data7.csv", "w") as f2:
    for line in contents:
        # let's get every line where the email address ends in "au"
        if line[3][-3:] == ".au": # line[3].endswith(".au):
            # the write() method takes a SINGLE string as its arg
            f2.write(",".join(line) + "\n")
            # f2.write("{}{}".format(",".join(line), "\n"))
            # f2.write(f"{','.join(line)}{'\n'}")

# APPEND MODE
# reading to check last line return...
with open("append_to_this.txt", "r") as f3:
    contents = f3.readlines()
print(contents) # ['Frodo\n', 'Sam\n', 'Merry\n']

with open("append_to_this.txt", "a") as f3:
    f3.write("Pippin\n")


































