napisz mi kod w języku rust który rysuje sześcian 3d z teksturą podaną z pliku. zawrzyj wszystkie niezbędne importy, użyj biblioteki wgpu

use wgpu::{
    Adapter, Device, Instance, Texture, TextureFormat, TextureViewDescriptor,
    TextureViewDimension,
};
use wgpu_glyph::{ab_glyph::FontArc, GlyphBrushBuilder};
use winit::{
    dpi::LogicalSize,
    event::{Event, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    window::{Window, WindowBuilder},
};

fn main() {
    // Tworzenie instancji i adaptera
    let instance = Instance::new();
    let adapter = Adapter::request(&instance, &wgpu::RequestAdapterOptions {
        power_preference: wgpu::PowerPreference::Default,
        compatible_surface: None,
    }).unwrap();

    // Tworzenie okna
    let event_loop = EventLoop::new();
    let window = WindowBuilder::new()
        .with_title("Sześcian 3D z teksturą")
        .build(&event_loop)
        .unwrap();

    // Tworzenie urządzenia i kontekstu
    let (device, queue) = adapter.request_device(&wgpu::DeviceDescriptor {
        extensions: wgpu::Extensions {
            anisotropic_filtering: false,
        },
        limits: wgpu::Limits::default(),
    });

    // Ładowanie tekstury z pliku
    let texture_bytes = include_bytes!("texture.png");
    let texture_rgba = image::load_from_memory(texture_bytes).unwrap().to_rgba();
    let texture_dimensions = texture_rgba.dimensions();
    let texture_data = texture_rgba.into_raw();
    let texture = Texture::from_data(
        &device,
        &TextureDescriptor {
            size: texture_dimensions,
            mip_level_count: 1,
            sample_count: 1,
            dimension: TextureDimension::D2,
            format: TextureFormat::Rgba8UnormSrgb,
            usage: TextureUsage::SAMPLED | TextureUsage::COPY_DST,
        },
        &texture_data,
    );
    let texture_view = texture.create_view(&TextureViewDescriptor::default());

    // Tworzenie bufora wierzchołków
    let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: None,
        contents: bytemuck::cast_slice(&VERTICES),
        usage: wgpu::BufferUsage::VERTEX,
    });

    // Tworzenie bufora indeksów
    let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: None,
        contents: bytemuck::cast_slice(&INDICES),
        usage: wgpu::BufferUsage::INDEX,
    });

    // Tworzenie bufora macierzy
    let uniform_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: None,
        contents: bytemuck::cast_slice(&[Matrix4::identity()]),
        usage: wgpu::BufferUsage::UNIFORM | wgpu::BufferUsage::COPY_DST,
    });

    // Tworzenie paska tekstur
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Nearest,
        mipmap_filter: wgpu::FilterMode::Nearest,
        ..Default::default()
    });

    // Tworzenie paska tekstur
    let bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        bindings: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStage::FRAGMENT,
                ty: wgpu::BindingType::Sampler { comparison: false },
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStage::FRAGMENT,
                ty: wgpu::BindingType::SampledTexture {
                    multisampled: false,
                    component_type: wgpu::TextureComponentType::Uint,
                    dimension: wgpu::TextureViewDimension::D2,
                },
            },
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStage::VERTEX,
                ty: wgpu::BindingType::UniformBuffer {
                    dynamic: false,
                    min_binding_size: None,
                },
            },
        ],
        label: None,
    });

    // Tworzenie grupy wiązań
    let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
        layout: &bind_group_layout,
        bindings: &[
            wgpu::Binding {
                binding: 0,
                resource: wgpu::BindingResource::Sampler(&sampler),
            },
            wgpu::Binding {
                binding: 1,
                resource: wgpu::BindingResource::TextureView(&texture_view),
            },
            wgpu::Binding {
                binding: 2,
                resource: wgpu::BindingResource::Buffer(uniform_buffer.slice(..)),
            },
        ],
        label: None,
    });

    // Tworzenie pipeline'u
    let render_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        bind_group_layouts: &[&bind_group_layout],
    });
    let render_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        layout: &render_pipeline_layout,
        vertex_stage: wgpu::ProgrammableStageDescriptor {
            module: &device.create_shader_module(wgpu::include_spirv!("shader.vert.spv")),
            entry_point: "main",
        },
        fragment_stage: Some(wgpu::ProgrammableStageDescriptor {
            module: &device.create_shader_module(wgpu::include_spirv!("shader.frag.spv")),
            entry_point: "main",
        }),
        rasterization_state: Some(wgpu::RasterizationStateDescriptor {
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: wgpu::CullMode::Back,
            depth_bias: 0,
            depth_bias_slope_scale: 0.0,
            depth_bias_clamp: 0.0,
        }),
        primitive_topology: wgpu::PrimitiveTopology::TriangleList,
        color_states: &[wgpu::ColorStateDescriptor {
            format: wgpu::TextureFormat::Bgra8UnormSrgb,
            color_blend: wgpu::BlendDescriptor::REPLACE,
            alpha_blend: wgpu::BlendDescriptor::REPLACE,
            write_mask: wgpu::ColorWrite::ALL,
        }],
        depth_stencil_state: None,
        vertex_state: wgpu::VertexStateDescriptor {
            index_format: wgpu::IndexFormat::Uint16,
            vertex_buffers: &[Vertex::descriptor()],
        },
        sample_count: 1,
        sample_mask: !0,
        alpha_to_coverage_enabled: false,
    });

    // Tworzenie bufora komend
    let mut encoder =
        device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: None });

    // Tworzenie bufora komend
    let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
        color_attachments: &[wgpu::RenderPassColorAttachmentDescriptor {
            attachment: &frame.view,
            resolve_target: None,
            load_op: wgpu::LoadOp::Clear,
            store_op: wgpu::StoreOp::Store,
            clear_color: wgpu::Color {
                r: 0.1,
                g: 0.2,
                b: 0.3,
                a: 1.0,
            },
        }],
        depth_stencil_attachment: None,
    });

    // Ustawienie pipeline'u
    render_pass.set_pipeline(&render_pipeline);

    // Ustawienie grupy wiązań
    render_pass.set_bind_group(0, &bind_group, &[]);

    // Ustawienie bufora wierzchołków
    render_pass.set_vertex_buffer(0, vertex_buffer.slice(..));

    // Ustawienie bufora indeksów
    render_pass.set_index_buffer(index_buffer.slice(..));

    // Rysowanie sześcianu
    render_pass.draw_indexed(0..INDICES.len() as u32, 0, 0..1);

    // Koniec bufora komend
    drop(render_pass);

    // Wyślij bufor komend do urządzenia
    queue.submit(&[encoder.finish()]);
}