// This is where our functions' definitions are stored
// Created by emre on 14.10.22.

#include "functions.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// This function is to validate user input, we reject anything that is not an integer with up to 3 digits.
int validate_input() {

    char input[500] = {};          //input buffer
    int temp = 0;
    int converted_input = 0;

    do {
        int not_all_number = 0;

        fgets(input, sizeof(input), stdin);
        for (int i = 0; i < strlen(input) - 1; i++) {
            if (isdigit(input[i]) == 0) {
                not_all_number = 1;
                break;
            }
        }

        if (not_all_number == 0) {
            temp = atoi(input);

            if (temp < 2) {
                printf("The number is too small, please enter a number between 2-10\n");
                continue;
            } else if (temp > 10) {
                printf("The number is too big, please enter a number between 2-10\n");
                continue;
            } else {
                converted_input = temp;
                return converted_input;
            }
        }

        else {
            printf("Invalid input, please try again.\n");
        }
    } while(converted_input == 0);


}

int DFS(my_cell** matrix, int current_row, int current_col, int row_size, int col_size) {

    static int found = 0;

    int current_dir[2] = {};

    int directions[4][2] = {
            {0, 1},     // moving right
            {-1, 0},    // moving up
            {0, -1},    // moving left
            {1, 0}      // moving down
            };

    for (int i = 0; i < 4; i++) {     // this loop iterates through the directions in the given order

        if (found != 1) {
            current_dir[0] = directions[i][0];    // temp value to add to row
            current_dir[1] = directions[i][1];    // temp value to add to col

            int future_row = current_row + current_dir[0];
            int future_col = current_col + current_dir[1];

            // safecheck to see whether cell is inside the matrix, also to see whether it was visited
            if (future_row < 0 || future_col < 0 || future_row >= row_size || future_col >= col_size) {
                continue;
            } else {

                if (matrix[future_row][future_col].value == 'M') {
                    found = 1;
                    return 1;

                } else if (matrix[future_row][future_col].value == ' ' && matrix[future_row][future_col].visited != 1) {

                    matrix[future_row][future_col].visited = 1;          // we visited this cell
                    matrix[future_row][future_col].value = '.';          // we mark our path

                    // the comment below prints each individual step, in case we want to see what is going on
                    //print_maze(matrix, row_size, col_size);

                    DFS(matrix, future_row, future_col, row_size, col_size);
                }
            }
        }
        else return 1;
    }

    if (found == 0) {
        matrix[current_row][current_col].value = ' ';
    }

    return 0;
}




struct map_data map_init() {

    /* map_init takes in user input and creates a dynamic matrix with the desired dimensions,
    * it also generates the maze using rand() with srand() seed from main and finally puts a starting point to it.
    * This function returns a pointer to the generated matrix
    */

    int rows, cols;

    struct map_data data;

    printf("Welcome to our minotaur maze, if you are ready to start please enter a number between 2 and 10 for our rows:\n");
    rows = validate_input();
    data.row_size = rows;

    printf("Thank you, now please enter a number between 2 and 10 for our columns:\n");
    cols = validate_input();
    data.col_size = cols;

    my_cell** matrix = calloc(rows, sizeof(my_cell*)); // allocating space for an array of pointers

    for (int i = 0; i < rows; i++) {
        matrix[i] = calloc(cols, sizeof(my_cell));  // the array of pointers point to these dynamic arrays
    }

    char tiles[2] = {' ', '-'};     // empty space for valid path and "-" for invalid path

    // filling the matrix with tiles randomly
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j].value = tiles[rand() % 2];
        }
    }

    matrix[1][1].value = '.';  // setting the starting position
    matrix[1][1].visited = 1;

    matrix[rand() % rows][rand() % cols].value = 'M';   // spawning the minotaur on a random location

    // The code below is a primitive check to see whether the minotaur was spawned at the starting point,
    while (matrix[1][1].value == 'M'){
        matrix[1][1].value = '.';
        matrix[rand() % rows][rand() % cols].value = 'M';
    }

    data.map = matrix;

    return data;
}

void map_free(my_cell** matrix, int rows, int cols) {
// this function is to free the memory allocated using our init function

    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
        matrix[i] = NULL;
    }
    free(matrix);
    matrix = NULL;

}

// function to print the maze/map
void print_maze(my_cell** map_pointer, int rows, int cols) {

    for (int i = 0; i < rows; i++) {
        printf("|");
        for (int j = 0; j < cols; j++) {

            printf("%c|", map_pointer[i][j].value);

        }
        printf("\n");             // for better readability
    }
    printf("\n");

}