#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <set>
#include <stack>
#include <regex>

string prepareReg(const string& regExp){
    auto countBrackets = 0;
    bool isCorrect = true;
    for (auto sym:regExp){
        if (sym=='(')
            countBrackets++;
        else if (sym == ')')
            countBrackets--;
        if (countBrackets<0) {
            isCorrect = false;
            break;
        }
    }
    if (countBrackets!=0)
        isCorrect = false;
    if (!isCorrect)
        return "Error Brackets";

    string ans;
    set<int> bracketSkipper;
    for (int it = regExp.size()-1; it >=0; --it){
        if (regExp[it]=='(')
            countBrackets++;
        else if (regExp[it] == ')')
            countBrackets--;

        if (regExp[it] ==')' && it == regExp.size()-1 || regExp[it] ==')' && regExp[it+1]!='*') {
            bracketSkipper.insert(countBrackets+1);
            continue;
        }
        if (regExp[it] ==')')
            ans.pop_back();
        if (regExp[it] =='('){
            if (bracketSkipper.count(countBrackets)) {
                            bracketSkipper.erase(countBrackets);
                            continue;
                        }
            else{
                ans+="(.";
                continue;
            }
        }
        ans+=regExp[it];
    }
    std::reverse(ans.begin(), ans.end());
    return ans;
}

using Rule = char;

vector<string> calcGrammar(const string& expr){

    std::set<char> operation{'+', '*', '(', ')','.'};
    const vector<char> mayBeRules{'S','A','B','C','D','E','F','G','H','I','J', 'K', 'L', 'M'};
    char curExprInsert = 'S';
    stack<char> delay;
    int curNumber = 0;

    map<Rule, string> result;
    //string curExpr(expr);
    string curOperand;
    for (auto& elem:expr){
        if (operation.count(elem)==0) {
            curOperand += elem;
            //curExpr.erase(elem);
        }
        else{
            auto oper = elem;
            //if (curOperand)
            //curExpr.erase(elem);
            if (oper == '+'){
                if (!curOperand.empty())
                    result[curExprInsert]+=curOperand+"|";
            }
            if (oper == '.'){
                if (!result[curExprInsert].empty() || !curOperand.empty()) {
                    result[curExprInsert] += curOperand + mayBeRules[++curNumber];
                    curExprInsert = mayBeRules[curNumber];
                }
            }
            if (oper == '('){
                result[curExprInsert]+=mayBeRules[curNumber+1];
                result[curExprInsert]+=curExprInsert;
                curNumber++;
                //result[curExprInsert]+=mayBeRules[curNumber++];
                result[curExprInsert]+="|";
                result[curExprInsert]+=mayBeRules[curNumber+1];
                curExprInsert = mayBeRules[curNumber++];
                delay.push(curExprInsert+1);
            }
            if (oper == '*'){
                result[curExprInsert]+=curOperand+curExprInsert+"|"+mayBeRules[++curNumber];
                curExprInsert = mayBeRules[curNumber];
            }
            if (oper == ')'){
                result[curExprInsert]+=curOperand;
                curExprInsert = delay.top();
                result[curExprInsert];
                delay.pop();
            }
            curOperand.clear();
        }
    }

    if (!curOperand.empty())
            result[curExprInsert] += curOperand;

    for (auto rule:mayBeRules){
            result[rule];
            if (rule == curExprInsert)
                break;
        }

    vector<string> grammar;
    for (auto num:mayBeRules){
        if (result.count(num)){
            if (result[num].empty())
                grammar.push_back("^");
            else
                grammar.push_back(result[num]);
            //cout << num << " --> " << result[num] << endl;
        }
    }
    return grammar;
}

void MainWindow::clearVars() {
    rules.clear();
    alphabet.clear();
}



void MainWindow::clearFields() {
    // Очистка всех полей
    ui->labelRuleA->setVisible(false); ui->lEditRuleA->setVisible(false);
    ui->labelRuleB->setVisible(false); ui->lEditRuleB->setVisible(false);
    ui->labelRuleC->setVisible(false); ui->lEditRuleC->setVisible(false);
    ui->labelRuleD->setVisible(false); ui->lEditRuleD->setVisible(false);
    ui->labelRuleE->setVisible(false); ui->lEditRuleE->setVisible(false);
    ui->labelRuleF->setVisible(false); ui->lEditRuleF->setVisible(false);
    ui->labelRuleG->setVisible(false); ui->lEditRuleG->setVisible(false);
    ui->labelRuleH->setVisible(false); ui->lEditRuleH->setVisible(false);
    ui->labelRuleI->setVisible(false); ui->lEditRuleI->setVisible(false);
    clearVars();

    ui->lEditTerminal->clear();
    ui->lEditRuleS->clear();
    ui->lEditRuleA->clear();
    ui->lEditRuleB->clear();
    ui->lEditRuleC->clear();
    ui->lEditRuleD->clear();
    ui->lEditRuleE->clear();
    ui->lEditRuleF->clear();
    ui->lEditRuleG->clear();
    ui->lEditRuleH->clear();
    ui->lEditRuleI->clear();
    ui->lEditLog->setText("");
    ui->spinBoxRules->setValue(1);
    ui->spinBoxMin->setValue(0);
    ui->spinBoxMax->setValue(1);
    ui->tEditChains->clear();
    ui->rdBtnLeft->setChecked(true);
    ui->spinBoxExample->setValue(1);
}

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    clearFields();
    EMPTY_SYMBOL = '^';
    SEPARATE_SYMBOL = '|';
}

MainWindow::~MainWindow()
{
    delete ui;
}

bool MainWindow::isTerminal(char symb)
{
    if ((symb >= '0' && symb <= '9') ||
            (symb >= 'a' && symb <= 'z') ||
//            (symb >= 'а' && symb <= 'я') ||
            symb == '(' || symb == ')' ||
            symb == '+' || symb == '-' || symb == '=' || symb == '*' || symb == '/' || symb == '%' ||
            symb == '.' || symb == ',' ||
            symb == EMPTY_SYMBOL) {
        return true;
    }
    return false;
}

void MainWindow::on_lEditTerminal_textChanged(const QString &newAlphabet)
{
    // форматирование допустимых, повторяющихся и верхнерегистровых символов
    QString alph = newAlphabet.toLower(), alph2;
//    qDebug() << QString::fromStdString(alph);
    for (int i = 0; i < alph.size(); i++) {
        if (alph[i] == alph[i + 1]) {
            ui->lEditLog->setText("Повторяющийся символ!");
            alph.remove(i, 1);
        } else if (!isTerminal(alph.toStdString()[i])) {
            ui->lEditLog->setText("Введён неверный символ!");
            alph.remove(i, 1);
        }
    }
//    qDebug() << QString::fromStdString(alph);
    alph2 = alph;
    for (int i = 0; i < alph.size(); i++)
        for (int j = i + 1; j < alph2.size() + 1; j++)
            if (alph[i] == alph2[j]) {
                ui->lEditLog->setText("Повторяющийся символ!");
                alph2.remove(j, 1);
            }
//    qDebug() << QString::fromStdString(alph2) << "\n\n";

    ui->lEditTerminal->setText(alph2);
}

void MainWindow::on_spinBoxRules_valueChanged(int newRCount)
{
    if (newRCount > 1) {
        ui->labelRuleA->setVisible(true); ui->lEditRuleA->setVisible(true);
    } else {
        ui->labelRuleA->setVisible(false); ui->lEditRuleA->setVisible(false);
    }
    if (newRCount > 2) {
        ui->labelRuleB->setVisible(true); ui->lEditRuleB->setVisible(true);
    } else {
        ui->labelRuleB->setVisible(false); ui->lEditRuleB->setVisible(false);
    }
    if (newRCount > 3) {
        ui->labelRuleC->setVisible(true); ui->lEditRuleC->setVisible(true);
    } else {
        ui->labelRuleC->setVisible(false); ui->lEditRuleC->setVisible(false);
    }
    if (newRCount > 4) {
        ui->labelRuleD->setVisible(true); ui->lEditRuleD->setVisible(true);
    } else {
        ui->labelRuleD->setVisible(false); ui->lEditRuleD->setVisible(false);
    }
    if (newRCount > 5) {
        ui->labelRuleE->setVisible(true); ui->lEditRuleE->setVisible(true);
    } else {
        ui->labelRuleE->setVisible(false); ui->lEditRuleE->setVisible(false);
    }
    if (newRCount > 6) {
        ui->labelRuleF->setVisible(true); ui->lEditRuleF->setVisible(true);
    } else {
        ui->labelRuleF->setVisible(false); ui->lEditRuleF->setVisible(false);
    }
    if (newRCount > 7) {
        ui->labelRuleG->setVisible(true); ui->lEditRuleG->setVisible(true);
    } else {
        ui->labelRuleG->setVisible(false); ui->lEditRuleG->setVisible(false);
    }
    if (newRCount > 8) {
        ui->labelRuleH->setVisible(true); ui->lEditRuleH->setVisible(true);
    } else {
        ui->labelRuleH->setVisible(false); ui->lEditRuleH->setVisible(false);
    }
    if (newRCount > 9) {
        ui->labelRuleI->setVisible(true); ui->lEditRuleI->setVisible(true);
    } else {
        ui->labelRuleI->setVisible(false); ui->lEditRuleI->setVisible(false);
    }
}

void MainWindow::declareAlphabet()
{
    ui->tEditChains->clear();
    string tmp = ui->lEditTerminal->text().toStdString();
    for (uint i = 0; i < tmp.size(); i++) {
        alphabet.insert(make_pair(tmp[i], 1));
    }
}

vector<string> sepRules(string const str, const char delim)
{
    size_t start;
    size_t end = 0;
    vector<string> branches;
    while ((start = str.find_first_not_of(delim, end)) != std::string::npos)
    {
        end = str.find(delim, start);
        branches.push_back(str.substr(start, end - start));
    }
    return branches;
}

bool MainWindow::checkMakeRules(char rule, string ruleDesc)
{
    for (uint i = 0; i < ruleDesc.size(); i++) {
        if (isTerminal(ruleDesc[i]) && alphabet[ruleDesc[i]] != 1 && ruleDesc[i] != SEPARATE_SYMBOL && ruleDesc[i] != EMPTY_SYMBOL)
            return false;
    }
    vector<string> branches = sepRules(ruleDesc, SEPARATE_SYMBOL);
    for (uint i = 0; i < branches.size(); i++) {
            rules.insert(make_pair(rule, branches[i]));
    }
    return true;
}

bool MainWindow::declareRules()
{

    if (!checkMakeRules('S', ui->lEditRuleS->text().toStdString()))
        return false;

    if (ui->lEditRuleA->isVisible()) {
        if (!checkMakeRules('A', ui->lEditRuleA->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleB->isVisible()) {
        if (!checkMakeRules('B', ui->lEditRuleB->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleC->isVisible()) {
        if (!checkMakeRules('C', ui->lEditRuleC->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleD->isVisible()) {
        if (!checkMakeRules('D', ui->lEditRuleD->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleE->isVisible()) {
        if (!checkMakeRules('E', ui->lEditRuleE->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleF->isVisible()) {
        if (!checkMakeRules('F', ui->lEditRuleF->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleG->isVisible()) {
        if (!checkMakeRules('G', ui->lEditRuleG->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleH->isVisible()) {
        if (!checkMakeRules('H', ui->lEditRuleH->text().toStdString()))
            return false;
    }
    if (ui->lEditRuleI->isVisible()) {
        if (!checkMakeRules('I', ui->lEditRuleI->text().toStdString()))
            return false;
    }
    return true;
}

void MainWindow::on_pBtnClear_clicked()
{
    clearFields();
}

void MainWindow::on_pBtnExample_clicked()
{
    // Загрузка примеров

    if (ui->spinBoxExample->value() == 1) { // чётные 0 и 1
        ui->spinBoxRules->setValue(4);
        ui->lEditTerminal->setText("01");
        ui->lEditRuleS->setText("0A|1B|^");
        ui->lEditRuleA->setText("0S|1C");
        ui->lEditRuleB->setText("0C|1S");
        ui->lEditRuleC->setText("0B|1A");
    } else if (ui->spinBoxExample->value() == 2) { // скобки
        ui->spinBoxRules->setValue(1);
        ui->lEditTerminal->setText("()");
        ui->lEditRuleS->setText("()S|(S)|^");
    } else if (ui->spinBoxExample->value() == 3) { // конец 01a
        ui->spinBoxRules->setValue(4);
        ui->lEditTerminal->setText("01ab");
        ui->lEditRuleS->setText("0A|1S|aS|bS");
        ui->lEditRuleA->setText("0S|1B|aS|bS");
        ui->lEditRuleB->setText("0S|1S|aC|bS");
        ui->lEditRuleC->setText("0A|1S|aS|bS|^");
    } else if (ui->spinBoxExample->value() == 4) { // что-то сложное
        ui->spinBoxRules->setValue(4);
        ui->lEditTerminal->setText("01abc");
        ui->lEditRuleS->setText("ABC|0A|1B");
        ui->lEditRuleA->setText("111B|aC");
        ui->lEditRuleB->setText("000A|bC");
        ui->lEditRuleC->setText("ccc|cS");
    }
}

void MainWindow::on_pBtnMinChain_clicked()
{
    declareAlphabet();
    if (!declareRules()) {
        ui->lEditLog->setText("Правило с недопустимыми символами!");
        clearVars();
        return;
    }
    chains.clear();
    results.clear();

    solveChainsCond("", 'S', "", "S", 0);

    if (results.size() == 0) {
        ui->tEditChains->setText("Нет подходящих комбинаций строк");
        return;
    }

    int minSize = ui->spinBoxMax->value()+1;
    string minChain;
    for (uint i = 0; i < results.size(); i++) {
        if (results[i] == "^") {
            minSize = 0;
            minChain = results[i];
        } else if ((int)results[i].size() < minSize && (int)results[i].size() >= ui->spinBoxMin->value()) {
            minSize = results[i].size();
            minChain = results[i];
        }
    }
    ui->tEditChains->append(QString::fromStdString("Минимальная цепочка - " + minChain + " размер - " + to_string(minSize) + "."));

    clearVars();
}

void MainWindow::solveChainsRule(string tmpRule, string output, int depth)
{
    int chainSize = 0;
    for (uint i = 0; i < tmpRule.size(); i++) {
        if (isTerminal(tmpRule[i])) {
            chainSize++;
        }
    }
    if (chainSize > ui->spinBoxMax->value() || (depth > 5 && chainSize == 0) || depth > 20) {
        return;
    }
    if (ui->rdBtnLeft->isChecked()) {
        for (uint i = 0; i < tmpRule.size(); i++) {
            if (!isTerminal(tmpRule[i])) {
                solveChainsCond(tmpRule.substr(0, i), tmpRule[i], tmpRule.substr(i+1, tmpRule.length()-i), output, depth+1);
                return;
            }
        }
    } else if (ui->rdBtnRight->isChecked()) {
        for (int i = (int)tmpRule.size()-1; i >= 0; i--) {
            if (!isTerminal(tmpRule[i])) {
                solveChainsCond(tmpRule.substr(0, i), tmpRule[i], tmpRule.substr(i+1, tmpRule.length()-i), output, depth+1);
                return;
            }
        }
    }
    if (tmpRule == "" && ui->spinBoxMin->value() <= 0) {
        chains.push_back(output);
        results.push_back(tmpRule);
    } else if (!(chainSize < ui->spinBoxMin->value()) && chainSize == (int)tmpRule.size()) {
        chains.push_back(output);
        results.push_back(tmpRule);
    }
}

void MainWindow::solveChainsCond(string before, char tmpRuleChar, string after, string output, int depth)
{
    pair<Mr::iterator, Mr::iterator> pr = rules.equal_range(tmpRuleChar);
    for (auto it = pr.first; it != pr.second; it++) {
        string tmpOutput = output;
        string tmpRule = it->second;
        if (tmpRule.find(EMPTY_SYMBOL) != string::npos) {
            tmpRule.erase(std::remove(tmpRule.begin(), tmpRule.end(), EMPTY_SYMBOL), tmpRule.end());
        }
        tmpOutput += " -> " + before + tmpRule + after;
        solveChainsRule(before+tmpRule+after, tmpOutput, depth);
    }
}

void MainWindow::on_pBtnSolve_clicked()
{
    auto regExp = ui->lEditTerminal_2->text().toStdString();
    string terminalsFromReg;
    for (auto sym:regExp){
        if (sym >= '0' && sym <= '9' || sym >= 'a' && sym <= 'z')
            terminalsFromReg+=sym;
    }
    on_spinBoxRules_valueChanged(10);
    ui->lEditTerminal->setText(terminalsFromReg.c_str());
    auto prepairedRegExp = prepareReg(regExp);
    auto grammar = calcGrammar(prepairedRegExp);
    grammar.resize(10);

    ui->lEditRuleS->setText(grammar[0].c_str());
    ui->lEditRuleA->setText(grammar[1].c_str());
    ui->lEditRuleB->setText(grammar[2].c_str());
    ui->lEditRuleC->setText(grammar[3].c_str());
    ui->lEditRuleD->setText(grammar[4].c_str());
    ui->lEditRuleE->setText(grammar[5].c_str());
    ui->lEditRuleF->setText(grammar[6].c_str());
    ui->lEditRuleG->setText(grammar[7].c_str());
    ui->lEditRuleH->setText(grammar[8].c_str());
    ui->lEditRuleI->setText(grammar[9].c_str());

    declareAlphabet();
    if (!declareRules()) {
        ui->lEditLog->setText("Правило с недопустимыми символами!");
        clearVars();
        return;
    }

    chains.clear();
    results.clear();

    solveChainsCond("", 'S', "", "S", 0);

    if (chains.size() == 0) {
        ui->tEditChains->setText("Нет подходящих комбинаций строк");
    }

    set<string> sequences;
    for (auto& v:chains){
        string curSeq;
        for (auto rIt = v.rbegin(); rIt!=v.rend(); ++rIt){
            if (*rIt == ' ')
                break;
            curSeq+=*rIt;
        }
        std::reverse(curSeq.begin(), curSeq.end());
        sequences.insert(curSeq);
    }
    ui->tEditChains_2->clear();
    for (auto& seq:sequences){
        ui->tEditChains_2->append(seq.c_str());
    }
    for (uint i = 0; i < chains.size(); i++) {
        ui->tEditChains->append(QString::fromStdString(chains[i]));
    }

    clearVars();
}

void MainWindow::lEditFormat(QLineEdit* edit)
{
    // форматирование допустимых символов
    QString alph = edit->text();
    for (int i = 0; i < alph.size(); i++) {
        if (alph.toStdString()[i] == 'S') {
            continue;
        } else if (alph.toStdString()[i] <= 'Z' && alph.toStdString()[i] > 'A' + (ui->spinBoxRules->value()-2)) {
            ui->lEditLog->setText("Такого правила не существует!");
            alph.remove(i, 1);
        } else if (!(isTerminal(alph.toStdString()[i]) || (alph.toStdString()[i] >= 'A' && alph.toStdString()[i] <= 'Z') ||
                     alph.toStdString()[i] == SEPARATE_SYMBOL)) {
            ui->lEditLog->setText("Введён неверный символ!");
            alph.remove(i, 1);
        }
    }
    edit->setText(alph);
}

void MainWindow::on_lEditRuleS_textChanged()
{
    lEditFormat(ui->lEditRuleS);
}

void MainWindow::on_lEditRuleA_textChanged()
{
    lEditFormat(ui->lEditRuleA);
}

void MainWindow::on_lEditRuleB_textChanged()
{
    lEditFormat(ui->lEditRuleB);
}

void MainWindow::on_lEditRuleC_textChanged()
{
    lEditFormat(ui->lEditRuleC);
}

void MainWindow::on_lEditRuleD_textChanged()
{
    lEditFormat(ui->lEditRuleD);
}

void MainWindow::on_lEditRuleE_textChanged()
{
    lEditFormat(ui->lEditRuleE);
}

void MainWindow::on_lEditRuleF_textChanged()
{
    lEditFormat(ui->lEditRuleF);
}

void MainWindow::on_lEditRuleG_textChanged()
{
    lEditFormat(ui->lEditRuleG);
}

void MainWindow::on_lEditRuleH_textChanged()
{
    lEditFormat(ui->lEditRuleH);
}

void MainWindow::on_lEditRuleI_textChanged()
{
    lEditFormat(ui->lEditRuleI);
}

void MainWindow::on_spinBoxMin_valueChanged(int arg1)
{
    if (arg1 > ui->spinBoxMax->value()) {
        ui->spinBoxMin->setValue(ui->spinBoxMax->value());
    }
}

void MainWindow::on_spinBoxMax_valueChanged(int arg1)
{
    if (arg1 < ui->spinBoxMin->value()) {
        ui->spinBoxMax->setValue(ui->spinBoxMin->value());
    }
}

void MainWindow::on_lEditLog_textChanged()
{
    QTimer::singleShot(2000, this, SLOT(slotTimerAlarm()));
}

void MainWindow::slotTimerAlarm()
{
    ui->lEditLog->setText("");
}

void MainWindow::on_pBtnExample_2_clicked()
{
   auto regExp = ui->lEditTerminal_2->text().toStdString();
   for (auto& v:regExp){
       if (v=='+')
           v = '|';
   }
   //regex regExpPosix(regExp, std::regex::extended);
   regex regExpPosix(regExp);
   std::smatch m;
   auto txt = ui->tEditChains_2->toPlainText();
   QStringList strList = txt.split('\n');
   vector<string> vec;
   for (QString str:strList){
       vec.push_back(str.toStdString());
   }


   ui->tEditChains_3->clear();
   for (auto curStr:vec){


       if (!std::regex_match(curStr, m, regExpPosix)){
           string ans = m[0];
           ui->tEditChains_3->append(curStr.c_str());
           ans.clear();
           for (int i=0; i<curStr.size(); ++i)
               ans+=to_string(m[i].matched);
           for (auto& elem:ans)
               elem = (elem=='1')? '=': '_';
           ui->tEditChains_3->append(ans.c_str());
       }
       //std::cout << " POSIX (leftmost longest) match: " << m[0] << '\n';
   }
}
