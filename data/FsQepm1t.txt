#pragma once

#include <unordered_map>
#include <mutex>
#include <functional>
#include <vector>
#include <thread>
#include <list>

template<class K, class V, class Hash = std::hash<K>>
class ConcurrentHashMap {
public:
    ConcurrentHashMap(const Hash &hasher = Hash()) : hasher_(hasher) {
        capacity_ = 100;
        size_ = 0;
    }

    explicit ConcurrentHashMap(int expected_size, const Hash &hasher = Hash()) : hasher_(hasher) {
        capacity_ = expected_size;
        size_ = 0;
    }

    ConcurrentHashMap(int expected_size, int expected_threads_count, const Hash &hasher = Hash()) : hasher_(hasher) {
        capacity_ = expected_size;
        size_ = 0;
    }

    bool ConcurentInsert(const K &key, const V &value) {
        auto index = hasher_(key) % table_.size();
        std::scoped_lock<std::mutex> lock(mutex_[index]);
        table_[index].emplace_back(key, value);
        return true;
    }

    bool Insert(const K &key, const V &value) {
        if (ConcurentInsert(key, value)) {
            if (size_ > capacity_) {
                Rehash();
            }
            return true;
        } else {
            return false;
        }
    }

    void BasicInsert(const K &key, const V &value) {
        auto index = hasher_(key) % table_.size();
        table_[index].emplace_back(key, value);
    }

    bool Erase(const K &key) {
        auto index = hasher_(key) % table_.size();
        std::scoped_lock<std::mutex> lock(mutex_[index]);
        auto it = table_[index].begin();
        for (; it != table_[index].end(); ++it) {
            if (it->first == key) {
                break;
            }
        }
        if (it == table_[index].end()) {
            return false;
        }
        table_[index].erase(it);
        return true;
    }

    void Clear() {
        LockAll_();
        for (auto &i : table_) {
            i.clear();
        }
        size_ = 0;
        UnlockAll_();
    }

    std::pair<bool, V> Find(const K &key) const {
        auto index = hasher_(key) % table_.size();
        std::scoped_lock<std::mutex> lock(mutex_[index]);
        auto it = table_[index].begin();
        for (; it != table_[index].end(); ++it) {
            if (it->first == key) {
                return {true, it->second};
            }
        }
        return {false, V{}};
    }

    const V At(const K &key) const {
        auto index = hasher_(key) % table_.size();
        std::scoped_lock<std::mutex> lock(mutex_[index]);
        auto it = table_[index].begin();
        for (; it != table_[index].end(); ++it) {
            if (it->first == key) {
                return it->second;
            }
        }
        throw std::runtime_error("bad at!");
    }

    size_t Size() const {
        return size_;
    }

private:
    std::vector<std::list<std::pair<K, V> > > table_;
    std::vector<std::mutex> mutex_;
    int capacity_ = 1000;
    std::atomic<int> size_;
    Hash hasher_;

    void LockAll_() {
        for (auto &i: mutex_) {
            i.lock();
        }
    }

    void UnlockAll_() {
        for (auto &i: mutex_) {
            i.unlock();
        }
    }

    void Rehash() {
        LockAll_();
        capacity_ *= 10;
        std::vector<std::list<std::pair<K, V> > > newtable(capacity_);
        for (const auto &i : table_) {
            for (const auto &[k, v]: i) {
                newtable[hasher_(k) % capacity_].emplace_back(k, v);
            }
        }
        std::swap(table_, newtable);
        std::vector<std::mutex> newmutex(capacity_);
        std::swap(newmutex, mutex_);
    }
};
