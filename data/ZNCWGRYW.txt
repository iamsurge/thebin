class Solution {
    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {
        int n = 0;
        for (int[] edge : edges) {
            n = Math.max(n, edge[0]);
            n = Math.max(n, edge[1]);
        }
        ++n;
        ArrayList<Integer>[] G = new ArrayList[n];
        for (int i = 0; i < n; ++i) {
            G[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            G[edge[0]].add(edge[1]);
            G[edge[1]].add(edge[0]);
        }
        int[] step = new int[n];
        Arrays.fill(step, Integer.MAX_VALUE >> 1);
        dfs1(0, 0, G, step, bob);
        return dfs2(0, 0, G, step, 0, amount);
    }

    private int dfs2(int pos, int fa, ArrayList<Integer>[] G, int[] step, int depth, int[] amount) {
        int ret = amount[pos];
        if (step[pos] == depth) {
            ret /= 2;
        }
        if (step[pos] < depth) {
            ret = 0;
        }
        int tmp = 0;
        for (int i = 0; i < G[pos].size(); ++i) {
            if (G[pos].get(i) == fa) {
                continue;
            }
            tmp = Math.max(tmp, dfs2(G[pos].get(i), pos, G, step, depth + 1, amount));
        }
        return ret + tmp;
    }

    private int dfs1(int pos, int fa, ArrayList<Integer>[] G, int[] step, int bob) {
        if (pos == bob) {
            step[pos] = 0;
            return 0;
        }
        for (int i = 0; i < G[pos].size(); ++i) {
            if (G[pos].get(i) == fa) {
                continue;
            }
            int s = dfs1(G[pos].get(i), pos, G, step, bob);
            if (s != -1) {
                step[pos] = s + 1;
                return step[pos];
            }
        }
        return -1;
    }
}