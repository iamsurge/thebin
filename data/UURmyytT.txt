#pragma once

#include <string>
using namespace std;

template<typename T>
class Stackk
{
private:
	T* mem;
	int szie;
	int count;
public:
	Stackk(int _size = 0)
	{
		size = _size;
		count = 0;
		mem = newT[size];
		for (int i = 0; i < size; i++)
		{
			mem[i] = T(0);
		}
	}
	Stackk(const Stackk& tmp)
	{
		size = tmp.size;
		count = tmp.count;
		mem = newT[size];
		for (int i = 0; i < size; i++)
		{
			mem[i] = tmp.mem[i];
		}
	}
	~Stackk()
	{
		if (size != 0)
		{
			delete[]mem;
		}
	}
	Stackk<T>& operator=(const Stackk<T> &tmp)
	{
		if (size != tmp.size)
		{
			if (size != 0)
			{
				delete[]mem;
			}
			size = tmp.size
			mem = newT[size];
		}
		count = tmp.count;
		for (int i = 0; i < size; i++)
		{
			mem[i] = tmp.mem[i];
		}
		return *this;
	}
	void add(T tmp)
	{
		if (count < size)
		{
			mem[count++] = tmp;
		}
	}
	T get()
	{
		if (count > 0)
		{
			return mem[--count]
		}
	}
	T top()
	{
		if (count > 0)
		{
			return mem[count - 1];
		}
	}
	T IsEmpty()
	{
		if (count == 0)
		{
			return 1 //Стек пуст
		}
		else
		{
			return 0 //Стек не пуст
		}
	}
	T IsFull()
	{
		if (count == size)
		{
			return 1 //Стек полон
		}
		else
		{
			return 0 //Стек не полон
		}
	}
};