struct Node {
    int sum = 0;
    //Used and Unused
};

struct SegTree {
    vector <Node> t;
    int n;
    SegTree(int _n) {
        n = 4 * _n;
        t.resize(n);
    }
    void unite(const Node& l, const Node& r, Node& m) {
        m.sum = l.sum + r.sum;
    }
    void build(vector <int>& a, int v, int L, int R) {
        if (L == R) {
            t[v].sum = a[L];
        }
        else {
            int M = (L + R) / 2;
            build(a, 2 * v, L, M);
            build(a, 2 * v + 1, M + 1, R);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
        }
    }
    void update(int v, int L, int R, int l, int r, int boost) {
        if (l > R || r < L) {
            return;
        }
        else if (l >= L && r <= R) {
            t[v].sum = boost;
        }
        else {
            int M = (L + R) / 2;
            update(2 * v, L, M, l, r, boost);
            update(2 * v + 1, M + 1, R, l, r, boost);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
        }
    }
    int query(int v, int L, int R, int l, int r) {
        if (l > R || r < L) {
            return 0;
        }
        else if (l <= L && r >= R) {
            return t[v].sum;
        }
        else {
            int M = (L + R) / 2;
            return query(2 * v, L, M, l, r) + query(2 * v + 1, M + 1, R, l, r);
        }
    }
};

void solve() {
    int n, m, i, j, x, l, r;
    cin >> n;
    vector <int> a, b;
    for (i = 0; i < n; i++) {
        cin >> x;
        if (i % 2 == 0) {
            a.push_back(x);
            a.push_back(0);
        }
        else {
            b.push_back(0);
            b.push_back(x);
        }
    }
    b.resize(n);
    a.resize(n);
    SegTree ch(n), ne(n);
    ch.build(a, 1, 0, n - 1);
    ne.build(b, 1, 0, n - 1);
    cin >> m;
    while (m--) {
        cin >> j;
        if (j == 0) {
            cin >> l >> r;
            if ((l - 1) % 2 == 0) {
                ch.update(1, 0, n - 1, l - 1, l - 1, r);
            }
            else {
                ne.update(1, 0, n - 1, l - 1, l - 1, r);
            }
        }
        else {
            cin >> l >> r;
            l--;
            r--;
            if (l % 2 == 0) {
                cout << ch.query(1, 0, n - 1, l, r) - ne.query(1, 0, n - 1, l, r) << endl;
            }
            else {
                cout << ne.query(1, 0, n - 1, l, r) - ch.query(1, 0, n - 1, l, r) << endl;
            }
        }
    }
}