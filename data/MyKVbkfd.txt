if game:GetService("RunService"):IsClient() then error("Script must be server-side in order to work; use h/ and not hl/") end
local Player,game,owner = owner,game
local RealPlayer = Player
do
    print("FE Compatibility code V2 by Mokiros")
    local RealPlayer = RealPlayer
    script.Parent = RealPlayer.Character
 
    --Fake event to make stuff like Mouse.KeyDown work
    local Disconnect_Function = function(this)
        this[1].Functions[this[2]] = nil
    end
    local Disconnect_Metatable = {__index={disconnect=Disconnect_Function,Disconnect=Disconnect_Function}}
    local FakeEvent_Metatable = {__index={
        Connect = function(this,f)
            local i = tostring(math.random(0,10000))
            while this.Functions[i] do
                i = tostring(math.random(0,10000))
            end
            this.Functions[i] = f
            return setmetatable({this,i},Disconnect_Metatable)
        end
    }}
    FakeEvent_Metatable.__index.connect = FakeEvent_Metatable.__index.Connect
    local function fakeEvent()
        return setmetatable({Functions={}},FakeEvent_Metatable)
    end
 
    --Creating fake input objects with fake variables
    local FakeMouse = {Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent(),Button2Up=fakeEvent(),Button2Down=fakeEvent()}
    FakeMouse.keyUp = FakeMouse.KeyUp
    FakeMouse.keyDown = FakeMouse.KeyDown
    local UIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
    local CAS = {Actions={},BindAction=function(self,name,fun,touch,...)
        CAS.Actions[name] = fun and {Name=name,Function=fun,Keys={...}} or nil
    end}
    --Merged 2 functions into one by checking amount of arguments
    CAS.UnbindAction = CAS.BindAction
 
    --This function will trigger the events that have been :Connect()'ed
    local function TriggerEvent(self,ev,...)
        for _,f in pairs(self[ev].Functions) do
            f(...)
        end
    end
    FakeMouse.TriggerEvent = TriggerEvent
    UIS.TriggerEvent = TriggerEvent
 
    --Client communication
    local Event = Instance.new("RemoteEvent")
    Event.Name = "UserInput_Event"
    Event.OnServerEvent:Connect(function(plr,io)
        if plr~=RealPlayer then return end
        FakeMouse.Target = io.Target
        FakeMouse.Hit = io.Hit
        if not io.isMouse then
            local b = io.UserInputState == Enum.UserInputState.Begin
            if io.UserInputType == Enum.UserInputType.MouseButton1 then
                return FakeMouse:TriggerEvent(b and "Button1Down" or "Button1Up")
            end
            if io.UserInputType == Enum.UserInputType.MouseButton2 then
                return FakeMouse:TriggerEvent(b and "Button2Down" or "Button2Up")
            end
            for _,t in pairs(CAS.Actions) do
                for _,k in pairs(t.Keys) do
                    if k==io.KeyCode then
                        t.Function(t.Name,io.UserInputState,io)
                    end
                end
            end
            FakeMouse:TriggerEvent(b and "KeyDown" or "KeyUp",io.KeyCode.Name:lower())
            UIS:TriggerEvent(b and "InputBegan" or "InputEnded",io,false)
        end
    end)
    Event.Parent = NLS([==[local Event = script:WaitForChild("UserInput_Event")
    local Mouse = owner:GetMouse()
    local UIS = game:GetService("UserInputService")
    local input = function(io,RobloxHandled)
        if RobloxHandled then return end
        --Since InputObject is a client-side instance, we create and pass table instead
        Event:FireServer({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
    end
    UIS.InputBegan:Connect(input)
    UIS.InputEnded:Connect(input)
 
    local h,t
    --Give the server mouse data every second frame, but only if the values changed
    --If player is not moving their mouse, client won't fire events
    local HB = game:GetService("RunService").Heartbeat
    while true do
        if h~=Mouse.Hit or t~=Mouse.Target then
            h,t=Mouse.Hit,Mouse.Target
            Event:FireServer({isMouse=true,Target=t,Hit=h})
        end
        --Wait 2 frames
        for i=1,2 do
            HB:Wait()
        end
    end]==],script)
 
    ----Sandboxed game object that allows the usage of client-side methods and services
    --Real game object
    local RealGame = game
 
    --Metatable for fake service
    local FakeService_Metatable = {
        __index = function(self,k)
            local s = rawget(self,"_RealService")
            if s then
                return typeof(s[k])=="function"
                and function(_,...)return s[k](s,...)end or s[k]
            end
        end,
        __newindex = function(self,k,v)
            local s = rawget(self,"_RealService")
            if s then s[k]=v end
        end
    }
    local function FakeService(t,RealService)
        t._RealService = typeof(RealService)=="string" and RealGame:GetService(RealService) or RealService
        return setmetatable(t,FakeService_Metatable)
    end
 
    --Fake game object
    local FakeGame = {
        GetService = function(self,s)
            return rawget(self,s) or RealGame:GetService(s)
        end,
        Players = FakeService({
            LocalPlayer = FakeService({GetMouse=function(self)return FakeMouse end},Player)
        },"Players"),
        UserInputService = FakeService(UIS,"UserInputService"),
        ContextActionService = FakeService(CAS,"ContextActionService"),
        RunService = FakeService({
            _btrs = {},
            RenderStepped = RealGame:GetService("RunService").Heartbeat,
            BindToRenderStep = function(self,name,_,fun)
                self._btrs[name] = self.Heartbeat:Connect(fun)
            end,
            UnbindFromRenderStep = function(self,name)
                self._btrs[name]:Disconnect()
            end,
        },"RunService")
    }
    rawset(FakeGame.Players,"localPlayer",FakeGame.Players.LocalPlayer)
    FakeGame.service = FakeGame.GetService
    FakeService(FakeGame,game)
    --Changing owner to fake player object to support owner:GetMouse()
        game,owner = FakeGame,FakeGame.Players.LocalPlayer
    end
 
pingudecal = "http://www.roblox.com/asset/?id=382332426"
 
local didpingu = false
 
local ScreenGui = Instance.new("ScreenGui",owner.PlayerGui)
 
ScreenGui.Name = "nooties"
 
local asd = Instance.new("TextButton",ScreenGui)
 
asd.BackgroundColor3 = Color3.new(0,0,0)
 
asd.BorderColor3 = Color3.new(0,0,0)
 
asd.Name = "nooties"
 
asd.Position = UDim2.new(1,-150,1,-90)
 
asd.Size = UDim2.new(0,150,0,45)
 
asd.Font = "SourceSansBold"
 
asd.FontSize = "Size32"
 
asd.Text = "Noot Noot!"
 
asd.TextColor3 = Color3.new(255,255,255)
 
asd.MouseButton1Down:connect(function()
 
if didpingu == false then
 
didpingu = true
 
for i,v in pairs(game.Players:GetChildren()) do
 
if v:IsA("Player") then
 
local nooties = Instance.new("Sound",workspace)
 
nooties.SoundId = "http://www.roblox.com/asset/?id=142912516"
 
nooties.Volume = 1
 
nooties.Looped = true
 
nooties:Play()
 
end
 
end
 
wait(12)
 
local Sky = Instance.new("Sky",game.Lighting)
 
Sky.SkyboxBk = pingudecal
 
Sky.SkyboxDn = pingudecal
 
Sky.SkyboxFt = pingudecal
 
Sky.SkyboxLf = pingudecal
 
Sky.SkyboxRt = pingudecal
 
Sky.SkyboxUp = pingudecal
 
local function modelasd()
 
for i,v in pairs(workspace:GetChildren()) do
 
if v:IsA("Model") then
 
for i,a in pairs(v:GetChildren()) do
 
local top = Instance.new("Decal",a)
 
top.Face = "Top"
 
top.Texture = pingudecal
 
local btm = Instance.new("Decal",a)
 
btm.Face = "Bottom"
 
btm.Texture = pingudecal
 
local lft = Instance.new("Decal",a)
 
lft.Face = "Left"
 
lft.Texture = pingudecal
 
local rft = Instance.new("Decal",a)
 
rft.Face = "Right"
 
rft.Texture = pingudecal
 
local frnt = Instance.new("Decal",a)
 
frnt.Face = "Front"
 
frnt.Texture = pingudecal
 
local bk = Instance.new("Decal",a)
 
bk.Face = "Back"
 
bk.Texture = pingudecal
 
local VTest = Instance.new("ParticleEmitter")
 
VTest.Parent = a
 
VTest.Texture = pingudecal
 
VTest.Speed = NumberRange.new(200)
 
VTest.Rate = 200
 
VTest.Size = NumberSequence.new(10000,10000)
 
VTest.Lifetime = NumberRange.new(1000)
 
local pepe = coroutine.create(function()
 
while wait() do
 
local Explosion = Instance.new("Explosion",a)
 
Explosion.BlastRadius = 10000
 
end
 
end)
 
coroutine.resume(pepe)
 
end
 
end
 
end
 
end
 
local function partasd()
 
for i,a in pairs(workspace:GetChildren()) do
 
local top = Instance.new("Decal",a)
 
top.Face = "Top"
 
top.Texture = pingudecal
 
local btm = Instance.new("Decal",a)
 
btm.Face = "Bottom"
 
btm.Texture = pingudecal
 
local lft = Instance.new("Decal",a)
 
lft.Face = "Left"
 
lft.Texture = pingudecal
 
local rft = Instance.new("Decal",a)
 
rft.Face = "Right"
 
rft.Texture = pingudecal
 
local frnt = Instance.new("Decal",a)
 
frnt.Face = "Front"
 
frnt.Texture = pingudecal
 
local bk = Instance.new("Decal",a)
 
bk.Face = "Back"
 
bk.Texture = pingudecal
 
local VTest = Instance.new("ParticleEmitter")
 
VTest.Parent = a
 
VTest.Texture = pingudecal
 
VTest.Speed = NumberRange.new(200)
 
VTest.Rate = 200
 
VTest.Lifetime = NumberRange.new(1000)
 
VTest.Size = NumberSequence.new(10000,10000)
 
local pepe = coroutine.create(function()
 
while wait() do
 
if a.Name ~= "Head" or "Torso" or "Left Arm" or "Right Arm" or "Left Leg" or "Right Leg" then
 
local Explosion = Instance.new("Explosion",a)
 
Explosion.BlastRadius = 10000
 
end
 
end
 
end)
 
coroutine.resume(pepe)
 
end
 
end
 
partasd()
 
modelasd()
 
else
 
warn("Already Ran! Did not execute the script!")
 
end
end)