const int maxn = 50000 + 100;
int n;
char str[maxn << 1];
int p[maxn << 1];

void manacher(string &s) {
    n = s.length();
    int len = n << 1 | 1;
    str[0] = '$';
    str[1] = '#';
    for(int i = 1; i <= n; ++i) {
        str[i << 1] = s[i - 1];
        str[i << 1 | 1] = '#';
    }
    str[len + 1] = '\0';
    p[1] = 1;
    int id = 1;
    int mx = 1 + p[1];
    for(int i = 2; i <= len; ++i) {
        int j = (i < mx ? min(p[2 * id - i], mx - i): 1);
        while(str[i + j] == str[i - j]) {
            ++j;
        }
        p[i] = j;
        if(i + p[i] > mx) {
            id = i;
            mx = i + p[i];
        }
    }
}

class Solution {
public:
    bool judge(int index) {
        return index - p[index] == 0;
    }
    
    string shortestPalindrome(string s) {
        manacher(s);
        int maxLen = 0;
        for (int i = 1; i <= n; ++i) {
            if (judge(i << 1)) {
                maxLen = max(p[i << 1] - 1, maxLen);
            }
            if (judge(i << 1 | 1)) {
                maxLen = max(p[i << 1 | 1] - 1, maxLen);
            }
        }
        string sub = s.substr(maxLen);
        reverse(sub.begin(), sub.end());
        return sub + s;
    }
};