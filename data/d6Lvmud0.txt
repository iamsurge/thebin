import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import math

# Выборка
nums = """0.54  0.43  0.41  1.40  0.17  0.50  0.25  0.24  0.21  0.03  0.71  0.63  0.27  0.59  1.03  0.25  2.02  0.60  2.35  0.10  0.32  3.14  1.75  0.47  1.28 1.67  0.01  0.04  1.39  0.86  1.01  0.34  1.30  0.02  0.13  0.86  0.76  0.18  0.74  2.10  0.94  0.19  0.67  0.61  0.33  1.48  1.08  1.13  0.39  1.42 0.26  0.26  0.31  0.14  0.11  0.31  1.07  0.08  2.22  3.50  0.69  1.56  0.64  0.63  0.52  0.19  0.19  0.02  0.29  1.04  0.05  0.11  0.77  1.53  0.20 0.94  0.81  0.49  1.23  0.18  0.01  0.63  0.92  3.57  0.81  1.77  2.05  1.42  0.61  0.40  1.47  1.13  1.02  1.36  0.12  0.86  2.25  0.57  0.34  0.20"""
# nums = """ -1.13  1.13  0.63 -1.67 -0.80 -1.45  1.25 -2.69 -0.36 -0.69 -0.14 -2.60 -0.75 -1.54 -1.19 -0.06 -2.46 -1.48 -1.11  1.20 -2.10 -1.39  1.04 -0.23 -1.73 0.13 -2.16 -0.79  1.35  0.28 -0.55 -2.96 -0.05 -2.08 -0.99 -0.17 -1.81 -2.11 -0.19 -1.26 -0.24  1.41 -1.58  1.18 -1.22 -1.74 -3.79 -0.20 -0.38  1.31 1.03  0.21  1.74 -0.93 -0.26 -0.19 -2.38 -0.09 -1.63  0.78 -0.13 -0.82 -0.15 -2.50 -1.16 -2.09 -1.53 -0.09 -0.01 -0.90 -1.03 -2.62 -0.67 -0.18 -0.17 -1.65 -1.22 -1.77  0.66 -1.11 -1.03  1.54 -1.67 -3.47 -2.70 -1.10 -1.16 -2.21  0.80 -0.37 -2.83 -1.22 -1.13  0.02 -1.61 -3.02 -0.32 -1.33  1.20 -0.39"""

# Количество значений в выборке
n = 100

M = int(math.sqrt(n))


def empiric(nums):
    arr = []
    for i in range(1, len(nums) + 1):
        if nums[i - 1] < nums[0]:
            arr.append(.0)
        elif nums[i - 1] > nums[-1]:
            arr.append(1.)
        else:
            arr.append((i) / len(nums))
    return arr

def count_int(nums, A, B):
    counter = 0
    for i in nums:
        if A <= i <= B:
            counter += 1
    return counter


def exp(numsx):
    lam = 1 / (sum(nums) / n)
    arr = [1 - math.exp(-x * lam) for x in numsx]
    return arr


def exp_teor(A, B):
    arr = []
    lam = 1 / (sum(nums) / n)
    for i in range(M):
        arr.append(round(100 * (1 - math.exp(-B[i] * lam) - (1 - math.exp(-A[i] * lam)))) / 100)
    return arr


nums = nums.split()
nums = sorted([float(x) for x in nums])

print("max:", nums[-1], "min:", nums[0])

plt.grid(which='major', linewidth=1)
plt.xlabel("x")
plt.ylabel("F(x)")
plt.plot(nums, empiric(nums))
plt.plot(nums, exp(nums))
plt.show()

h = (nums[-1] - nums[0]) / M
equ_intJ = [x for x in range(1, 11)]
equ_intA = [round(1000 * (nums[0] + (j - 1) * h)) / 1000 for j in range(1, M + 2)]
equ_intB = [equ_intA[x + 1] for x in range(M)]
equ_intH = [round(1000 * (equ_intB[x] - equ_intA[x])) / 1000 for x in range(M)]
equ_intV = [count_int(nums, equ_intA[x], equ_intB[x]) for x in range(M)]
equ_intPs = [x / n for x in equ_intV]
equ_intF = [round(1000 * (equ_intPs[x] / equ_intH[x])) / 1000 for x in range(M)]

bf = equ_intPs

equ_intPT = exp_teor(equ_intA, equ_intB)


equ_intA.pop()
equ_int = [["j", "A", "B", "h", "V", "P*", "F*"]]

for zxc in range(1, M + 1):
    equ_int.append([])
    equ_int[zxc].append(str(equ_intJ[zxc - 1]))
    equ_int[zxc].append(str(equ_intA[zxc - 1]))
    equ_int[zxc].append(str(equ_intB[zxc - 1]))
    equ_int[zxc].append(str(equ_intH[zxc - 1]))
    equ_int[zxc].append(str(equ_intV[zxc - 1]))
    equ_int[zxc].append(str(equ_intPs[zxc - 1]))
    equ_int[zxc].append(str(equ_intF[zxc - 1]))

fig, ax = plt.subplots()

fig.patch.set_visible(False)
ax.axis('off')

table = ax.table(cellText=equ_int, loc='center')

fig.tight_layout()
plt.show()

ax.axis('off')
fig.patch.set_visible(True)
plt.grid(which='major', linewidth=1, axis='y')
plt.xlabel("x")
plt.ylabel("f(x)")

equ_intAstr = [str(x) for x in equ_intA]

plt.bar(equ_intAstr, equ_intF, edgecolor='black', width=1)
plt.show()

equ_intV = [int(round(1000 * (n / M)) / 1000) for x in range(M)]
equ_intPs = [round(1000 * (1 / M)) / 1000 for x in range(M)]
equ_intA = [round(1000 * (nums[(j - 1) * equ_intV[0] - 1] + nums[(j - 1) * equ_intV[0]]) / 2) / 1000 for j in range(2, M + 1)]
equ_intA.insert(0, nums[0])
equ_intB = [equ_intA[x] for x in range(1, M)]
equ_intB.append(nums[-1])
equ_intH = [round(1000 * (equ_intB[x] - equ_intA[x])) / 1000 for x in range(M)]
equ_intF = [round(1000 * (equ_intPs[x] / equ_intH[x])) / 1000 for x in range(M)]


equ_int = [["j", "A", "B", "h", "V", "P*", "F*"]]

for zxc in range(1, M + 1):
    equ_int.append([])
    equ_int[zxc].append(str(equ_intJ[zxc - 1]))
    equ_int[zxc].append(str(equ_intA[zxc - 1]))
    equ_int[zxc].append(str(equ_intB[zxc - 1]))
    equ_int[zxc].append(str(equ_intH[zxc - 1]))
    equ_int[zxc].append(str(equ_intV[zxc - 1]))
    equ_int[zxc].append(str(equ_intPs[zxc - 1]))
    equ_int[zxc].append(str(equ_intF[zxc - 1]))

fig, ax = plt.subplots()

fig.patch.set_visible(False)
ax.axis('off')

table = ax.table(cellText=equ_int, loc='center')

fig.tight_layout()
plt.show()

ax.axis('off')
fig.patch.set_visible(True)
plt.grid(which='major', linewidth=1, axis='y')
plt.xlabel("x")
plt.ylabel("f(x)")

equ_intAstr = [str(x) for x in equ_intA]

plt.bar(equ_intAstr, equ_intF, edgecolor='black', width=1)
plt.show()

mat = sum(nums) / n
a = [((x - mat) ** 2) for x in nums]
summa = 0
for x in range(n):
    summa += a[x]
disp = (1 / (n - 1) * summa)
ot = math.sqrt(disp)
t = 1.984
zy = 1.96
left_mat = sum(nums) / n - ot * zy / M
right_mat = sum(nums) / n + ot * zy / M

left_disp = disp * (1 - math.sqrt(2 / (n - 1)))
right_disp = disp * (1 + math.sqrt(2 / (n - 1)))

print("Мат ожидание:", mat, "\tДисперсия:", disp, "\tСКО:", ot)
print(left_mat, "< mx < ", right_mat)
print(left_disp, "< Dx < ", right_disp)

equ_intPs = bf

equ_int = [["j", "A", "B", "F0(A)", "F0(B)", "P*", "P", "X"]]

equ_intF0A = exp(equ_intA[:-1])
equ_intF0A = [round(10000 * x) / 10000 for x in equ_intF0A]
equ_intF0B = exp(equ_intB[1:])
equ_intF0B = [round(10000 * x) / 10000 for x in equ_intF0B]
equ_intF0A.insert(0, 0)
equ_intF0B.append(1)
equ_intA[0] = -np.inf
equ_intB[-1] = +np.inf
equ_intX = [round(100000 * ((equ_intPT[j] - equ_intPs[j]) ** 2) / equ_intPT[j]) / 100000 for j in range(M)]

for zxc in range(1, M + 1):
    equ_int.append([])
    equ_int[zxc].append(str(equ_intJ[zxc - 1]))
    equ_int[zxc].append(str(equ_intA[zxc - 1]))
    equ_int[zxc].append(str(equ_intB[zxc - 1]))
    equ_int[zxc].append(str(equ_intF0A[zxc - 1]))
    equ_int[zxc].append(str(equ_intF0B[zxc - 1]))
    equ_int[zxc].append(str(equ_intPs[zxc - 1]))
    equ_int[zxc].append(str(equ_intPT[zxc - 1]))
    equ_int[zxc].append(str(equ_intX[zxc - 1]))

fig, ax = plt.subplots()

fig.patch.set_visible(False)
ax.axis('off')

table = ax.table(cellText=equ_int, loc='center')

fig.tight_layout()
plt.show()

persson = n * sum([((equ_intPT[j] - equ_intPs[j]) ** 2) / equ_intPT[j] for j in range(M)])
s = 1
k = M - 1 - s
print("k:", k)
print("persson:", round(100 * persson) / 100)

lam = math.sqrt(n)
teor = exp(nums)
emp = empiric(nums)
Z = max([abs(emp[i] - teor[i]) for i in range(n)])
print(teor)
print(emp)
print("Коэф Колмогорова", Z * math.sqrt(n))