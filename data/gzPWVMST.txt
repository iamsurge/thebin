//misaka and elaina will carry me to red

#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2,bmi,bmi2,lzcnt,popcnt")

#include <iostream>
#include <cmath>
#include <utility>
#include <cassert>
#include <algorithm>
#include <vector>
#include <array>
#include <cstdio>
#include <cstring>
#include <functional>
#include <numeric>
#include <set>
#include <queue>
#include <map>
#include <chrono>
#include <random>

#define sz(x) ((int)(x.size()))
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back
#define kill(x, s) {if(x){ cout << s << "\n"; return ; }}

#ifndef LOCAL
#define cerr while(0) cerr
#endif

using ll = long long;
using lb = long double;

const lb eps = 1e-9;
const ll mod = 1e9 + 7, ll_max = 1e18;
//const ll mod = (1 << (23)) * 119 +1, ll_max = 1e18;
const int MX = 5e3 +10, int_max = 0x3f3f3f3f;

struct {
  template<class T>
  operator T() {
    T x; std::cin >> x; return x;
  }
} in;

using namespace std;

pair<int, int> dp[MX][MX*2];
//smallest j such that first i neg and first j pos can sum to k if needed

int arr[MX];
int sign[MX];
int n, m, t;

const int zero = 5e3;

void solve(){
    n = in, m =in, t = in;
    int greedy = 0;
    for(int i = 1; i<=n; i++){
        arr[i] = in;
        if(greedy + arr[i] <= t){
            greedy += arr[i];
            sign[i] = -1;
        }else{
            sign[i] = 1;
        }
    }
    vector<int> pos, neg;
    for(int i = 1; i<=n; i++){
        if(sign[i] > 0){
            pos.pb(arr[i]);
        }else{
            neg.pb(arr[i]);
        }
    }
    if(greedy == t){
        cout << sz(neg) << "\n";
        for(int x : neg) cout << x << " "; cout << "\n";
        return ;
    }
    if(sz(pos) == 0 || sz(neg) == 0){
        cout << -1 << "\n";
        return ;
    }
    
    for(int i = 0; i<=sz(neg); i++){
        for(int k = -m; k<=m; k++){
            dp[i][k + zero] = {n+1, 0};
        }
    }
    dp[0][greedy - t + zero] = {0, 0};
    for(int j = 0; j<sz(pos); j++){
        for(int k = -m; k<=m; k++){
            if(j < sz(pos) && k + pos[j] <= m && dp[0][k + zero].first <= j){
                dp[0][k + pos[j] + zero] = min(dp[0][k + pos[j]+ zero], {j+1, j+1});
            }
        }
    }
    for(int i = 0; i<sz(neg); i++){
        for(int k = -m; k<=m; k++){
            dp[i+1][k + zero] = min(pair(dp[i][k + zero].first, 0), (k + neg[i] <= m ? pair(dp[i][k + neg[i] + zero].first, -(i+1)) : pair((n+1), 0)));
        }
        for(int k = -m; k<=m; k++){
            for(int j = dp[i+1][k + zero].first; j<=dp[i][k + zero].first; j++){
                if(j < sz(pos) && k + pos[j] <= m && dp[i+1][k + zero].first <= j){
                    dp[i+1][k + pos[j] + zero] = min(dp[i+1][k + pos[j] + zero], {j+1, j+1});
                }
            }
        }
    }
    int wo = 0;
    for(int i = 0; i<=sz(neg); i++){
        if(dp[i][zero].first <= n){
            wo = i+1;
        }
    }
    cerr << wo << "\n";
    kill(wo == 0, "-1");
    int i = wo-1, k = 0;
    vector<int> res = neg, rem;
    cerr << wo << " " << k << "\n";
    while(i != 0 || k != greedy - t){
        cerr << i << " " << k << "\n";
        int v = dp[i][k + zero].second;
        if(v > 0){
            res.pb(pos[v-1]);
            k -= pos[v-1];
        }else if(v < 0){
            v = -v;
            rem.pb(neg[v-1]);
            k += neg[v-1];
            i--;
        }else{
            i--;
        }
    }
    vector<int> oup(sz(res));
    sort(all(res)); sort(all(rem));
    auto it = set_symmetric_difference(all(res), all(rem), oup.begin());
    oup.resize(it - oup.begin());
    cout << sz(oup) << "\n";
    for(int x : oup) cout << x << " "; cout << "\n";     
}

signed main(){
  cin.tie(0) -> sync_with_stdio(0);

  int T = 1;
  //cin >> T;
  for(int i = 1; i<=T; i++){
        //cout << "Case #" << i << ": ";
        solve();
    }
  return 0;
}