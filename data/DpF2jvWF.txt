## Standard library types
> `std` library provides custom types to expand `primitives`.

### `Box`
> A box is a smart pointer to heap allocated value of type `T`
> 
- Stack allocated values can be *boxed*(allocated on heap) by creating `Box<T>`
- When box go out of scope, its destructor is called. Memory is freed.
- Boxed values can be dereferenced by `*` operator; remove 1 indirection layer.


### `Vec`tors
- Re-sizable arrays. size unknown at compile, can grow/shrink at any time
- Has 3 parameters:
  - pointer to the data
  - length
  - capacity
    > reserved memory. rellocated with larger capacity when needs to expand.

```rust
use std::mem::{size_of_val};

struct Point { x: f64, y: f64, }
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

/// Box
fn origin() -> Point
{
    Point { x: 0.0, y: 0.0 }
}
fn boxed_origin() -> Box<Point> 
{
    // Allocate this point on the heap and return point to it.
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() 
{
    /// ## `Box`
    // Stack allocated variables
    let point: Point = origin();
    println!("Point: {} bytes on stack", size_of_val(&point));      // 16 bytes
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };
    println!("R: {} bytes on stack", size_of_val(&rectangle));      // 32 bytes
    // Heap allocated rectangle // box size == pointer size
    let boxed_point: Box<Point> = Box::new(origin()); // fn output can be boxed
    println!("Boxes: {} bytes on heap",size_of_val(&boxed_point)); // 8 bytes
    let boxed_rectangle: Box<Rectangle> = Box::new(rectangle);     // 8 bytes
    let unboxed_point: Point = *boxed_point; // Copy data in `boxed_point` to
    println!("Unboxed: {} bytes on stack", size_of_val(&unboxed_point)); // 16 B
    
    // Double indirection
    let box_in_a_box: Box<Box<Point>> = Box::new(boxed_origin());
    
    /// ## `Vec`
    // Iterators can be collected into vectors
    let collected_iterator: Vec<i32> = (0..10).collect(); // [0, .., 9]

    // The `vec!` macro can be used to initialize a vector
    let mut xs =  vec![1i32, 2, 3]; // indexing `vec`; xs[0]
    let xslen = xs.len(); 
    xs.push(4); 
    xs.pop();   // println!("{:?}", xs.pop()); // Some(4)
    
    /* // `Vector`s can be easily iterated over
     * for x in xs.iter() 
     * for (i, x) in xs.iter().enumerate()
     */
    for x in xs.iter_mut() { *x *= 3 }; // [3, 6, 9]
}
```