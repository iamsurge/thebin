// Task 3
func summ<T: Numeric>(params: T...) -> T {
    params.reduce(0, +)
}

print(summ(params: 1, 4, 3, 4))

class Stack<T> {
    private var storage = [T]()

    func push(_ element: T) {
        storage.append(element)
    }

    func pop() -> T? {
        if storage.isEmpty {
            return nil
        }
        return storage.removeLast()
    }

    func printf() {
        print(storage)
    }
}

var someStack = Stack<Int>()
someStack.push(3)
someStack.push(5)
someStack.pop()
someStack.printf()

enum Result<T> {
    case success(T)
    case error
}

let serverResponse: Result = .success("res.json")

// Task 4
var storage: [Any] = []

func saveItems<T>(_ items: T...) {
    items.forEach { item in
        storage.append(item)
    }
}

saveItems("hi", "there")
print(storage)

// Tasks 5 & 6
struct Storage<T: StringProtocol> {
    enum SortOrder {
        case ascending, descending, byLength
    }

    private var storage = [T]()

    mutating func append(_ elements: T...) {
        elements.forEach { element in
            storage.append(element)
        }
    }

    func printStorage(sortOrder: SortOrder = .ascending) {
        switch sortOrder {
        case .ascending: print(storage.sorted(by: <))
        case .descending: print(storage.sorted(by: >))
        case .byLength: print(storage.sorted { lhs, rhs in
            lhs.count < rhs.count
            })
        }
    }
}

var swiftSong = Storage<String>()
swiftSong.append("Haters", "gonna", "hate")
swiftSong.printStorage(sortOrder: .byLength)

extension Storage {
    subscript(index: Int) -> T? {
        return (0..<storage.count).contains(index) ? storage[index] : nil
    }
}

print(swiftSong[1])
