#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

const char key[10][5] = {
        {'0', '+', 0, 0, 0},
        {'1', 0, 0, 0, 0},
        {'2', 'a', 'b', 'c', 0},
        {'3', 'd', 'e', 'f', 0},
        {'4', 'g', 'h', 'i', 0},
        {'5', 'j', 'k', 'l', 0},
        {'6', 'm', 'n', 'o', 0},
        {'7', 'p', 'q', 'r', 's'},
        {'8', 't', 'u', 'v', 0},
        {'9', 'w', 'x', 'y', 'z'} };

//the 2 very important arrays into which the number and name are loaded
char buffer_1[100];
char buffer_2[100];

//definicion of 2 functions that will be used other then main
bool check(char* data, char* pattern);
int get_line(char* buffer, unsigned int size);
bool checkFromThis(char* data, char* pattern);

int main(int argc, char* argv[]){

    //declaration of variable which will be used for estetic and semi-functional purposes
    int count = 0;
    int result_1;
    int result_2;

    while (true) {
        // printf("lll\n");
        //here are 2 variable which determine which scenario will be played out, in them specific function is called
        result_1 = get_line(buffer_1, sizeof(buffer_1));
        result_2 = get_line(buffer_2, sizeof(buffer_2));

        //this switch decides weather the program is done or it has any mistakes in the input, if the result_1 is 0 it will go through unharmmed
        switch (result_1) {
            case 1:
                if (count == 0){
                    printf("not found\n");
                }
                return 0;
            case 2:
                //if the input is too long it will not be printed
                continue;
        }

        //this exacly the same as the previous switch but it is for the second result which could be either a number or name
        switch (result_2) {
            case 1:
                if (count == 0){
                    printf("not found\n");
                }
                return 0;
            case 2:
                continue;
        }

        //this line checks for any and all missing information
        if (buffer_1[0] == '\n' || buffer_1[0] == '\0' || buffer_2[0] == '\n' || buffer_2[0] == '\0') {
            continue;
        }

        //in this condition it checks if the buffer meets the pattern in any way
        //if either buffer meets the demands it will continue in

        if (check(buffer_1, argv[1]) || check(buffer_2, argv[1])) {

            //this condition checks for the order of the contact and number and if necessity requires, it will swap them upon printing
            if ((buffer_2[0] >= '0') && (buffer_2[0] <= '9')) {
                printf("%s, %s\n", buffer_1, buffer_2);

                //the variable count is here in order to capture the number of matches
                count++;
            }
            else {
                printf("%s, %s\n", buffer_2, buffer_1);
                count++;
            }
        }
    }
    (void)argc;
}

bool check(char* data, char* pattern){
    if(data == NULL || pattern == NULL || data == 0 || pattern == 0)
        return true;
    for(unsigned int i = 0; i < strlen(data) - strlen(pattern); i++){
        if(checkFromThis(&data[i], pattern))
            return true;
    }
    return false;
}

bool checkFromThis(char* data, char* pattern){
    char helper = tolower(data[0]);
    if(pattern == NULL || data  == NULL || data[0] == 0 || pattern[0] == 0)
        return true;
    for(int i = 0; i < 5; i++){
        if((helper == key[pattern[0] - '0'][i])){
            return checkFromThis(&data[1], &pattern[1]);
        }
    }
    return false;
}

int get_line(char* buffer, unsigned int size) {

    //the next line check weather or not the program reach the end of the file, if so it will return the number 1
    if (fgets(buffer, size, stdin) == NULL) {
        return 1;
    }
    
    //the next line check for the length of input into the array to determine if it is viable for considarion in the pattern search
    //if the condition is met the program will go in and decide which function output does it use
    if ((strlen(buffer) + 1) < size) {
        

        //the next is here specificly for the last line in the file, so that it would know to include it in the pattern decision
        if (!(buffer[strlen(buffer) - 1] == '\n' || buffer[strlen(buffer) - 2] == '\r')) {
            return 0;
        }

        if (buffer[strlen(buffer) - 1] == '\n') {
            buffer[strlen(buffer) - 1 ] = 0;
            if (buffer[strlen(buffer) - 1] == '\r') {
                buffer[strlen(buffer) - 1] = 0;
                return 0;
            }
            return 0;
        }
        return 0;
    }
    //this very specific variable is basicly a trash can for the chracters which come after the too long input, so that the cursor muves to the next line
    char buffer_x[100];

    //this while reads the rest of the line in case it is too long to meet project's requirements
    while ((fgets(buffer_x, sizeof(buffer_x), stdin) != NULL) && (strlen(buffer_x) == sizeof(buffer_x) - 1) && (buffer_x[sizeof(buffer_x) - 1] != '\n')) {}

    //at this point in the code there is no other way then retunr the number 2 so that it writes that the input is too long
    return 2;

}