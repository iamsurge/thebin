template<typename T>
struct LoggerType {
    LoggerType(T val) : val_(val) {}
    LoggerType(const LoggerType&) = default;
    LoggerType() = default;

    LoggerType&
        operator+=(const LoggerType& rhs) {
        ++count_plus_;
        val_ += rhs.val_;
        return *this;
    }

    LoggerType
        operator+(const LoggerType& rhs) const {
        LoggerType temp(*this);
        temp += rhs;
        return temp;
    }

    LoggerType&
        operator*=(const LoggerType& rhs) {
        ++count_multiply_;
        val_ *= rhs.val_;
        return *this;
    }

    LoggerType
        operator*(const LoggerType& rhs) const {
        LoggerType temp(*this);
        temp *= rhs;
        return temp;
    }

    bool
        operator<(const LoggerType& rhs) const {
        ++count_compare_;
        return val_ < rhs.val_;
    }

    bool
        operator<=(const LoggerType& rhs) const {
        return !(rhs < *this);
    }

    bool
        operator>(const LoggerType& rhs) const {
        return rhs < *this;
    }

    bool
        operator>=(const LoggerType& rhs) const {
        return !(*this < rhs);
    }

    friend bool operator==(const LoggerType& lhs, const T& rhs) {
        return lhs.val_ == rhs;
    }
    friend bool operator==(const LoggerType& lhs, const LoggerType& rhs) {
        return lhs.val_ == rhs.val_;
    }
    friend ostream& operator<<(ostream& out, const LoggerType& rhs) {
        out << rhs.val_;
        return out;
    }


    static int count_plus_;
    static int count_multiply_;
    static int count_compare_;
private:
    T val_ = T(0);
};

template<typename T>
int LoggerType<T>::count_plus_ = 0;
template<typename T>
int LoggerType<T>::count_multiply_ = 0;
template<typename T>
int LoggerType<T>::count_compare_ = 0;

using TYPE = LoggerType<int>;

void TestOnlySum() {
    vector<TYPE> v1;
    v1.reserve(3);
    v1.emplace_back(100);
    v1.emplace_back(-100);
    v1.emplace_back(20);
    TYPE sum;

    ComputeStatistics(v1.begin(), v1.end(), sum, nullopt, nullopt); 
    assert(sum == 20);
    assert(TYPE::count_plus_, 2);
    assert(TYPE::count_multiply_, 0);
    assert(TYPE::count_compare_, 0);

}
