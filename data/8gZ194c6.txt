
#pragma GCC optimzize("Ofast,no-stack-protector")
#include<bits/stdc++.h>
#define int long long
#define quick ios::sync_with_stdio(0);cin.tie(0);
#define rep(x,a,b) for(int x=a;x<=b;x++)
#define repd(x,a,b) for(int x=a;x>=b;x--)
#define lowbit(x) (x&-x)
#define sz(x) (int)(x.size())
#define F first
#define S second
#define all(x) x.begin(),x.end()
#define mp make_pair
#define eb emplace_back
using namespace std;
typedef pair<int,int> pii;
void debug(){
    cout<<"\n";
}
template <class T,class ... U >
void debug(T a, U ... b){
    cout<<a<<" ",debug(b...);
}
const int N=1e3+7;
const int INF=1e18;
vector<int> v[N];//X的鄰點
int match[N]; // Y所匹配的節點
bool vis[N]; //在這次尋找中是否被走過
int dfs(int x){
	for(int y:v[x]){
		if(vis[y]) continue;
		vis[y]=true;
		if(match[y]==-1||dfs(match[y])){
			match[y]=x;
			return true;
		}
	}
	return false;
}
int bipartiteMatching(int n){
	fill(match,match+n+1,-1);
	int ans=0;
	rep(i,1,n){
		fill(vis,vis+n+1,0);
		if(dfs(i)) ans++;
	}
	return ans;
}
vector<int> v2[2*N];
int tag[2*N];
vector<pii> e;
void paint(int x){
	tag[x]=true;
	for(int i:v2[x]){
		if(!tag[i]){
			paint(i);
		}
	}
}
void getce(int n){
	int ans=bipartiteMatching(n);
	cout<<ans<<"\n";
	for(pii p2:e){
		if(match[p2.S]!=p2.F){
			v2[p2.S+n].eb(p2.F);
		}
		else v2[p2.F].eb(p2.S+n);
	}
	rep(i,1,n){
		if(match[i]==-1){
			paint(i+n);
		}
	}
	rep(i,1,n){
		if(tag[i]) cout<<1<<" "<<i<<"\n";
	}
	rep(i,n+1,2*n){
		if(!tag[i]) cout<<2<<" "<<i-n<<"\n";
	}
}
char c[N][N];
signed main(){
    quick
	int n;
	cin>>n;
	rep(i,1,n){
		rep(j,1,n){
			cin>>c[i][j];
			if(c[i][j]=='o') v[i].eb(j),e.eb(mp(i,j));
		}
	}
	getce(n);
    return 0;
}
