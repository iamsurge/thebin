#include <stdio.h>
#include <string.h>
#include <regex.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <unistd.h>
#include <dirent.h>

// o functie care returneaza doar ce este pana la '.', adica doar numele fisierului
char *filename_without_extension(char *filename)
{
    char *filename_without_ext = strtok(filename, ".");
    // filename_without_ext[strlen(filename_without_ext)] = '\0';
    return filename_without_ext;
}

// o functie care returneaza ce este dupa '.' adica extensia fisierului
char *get_c_ext(char filename[])
{
    char *punct = strrchr(filename, '.');
    if (!punct || punct == filename)
        return "";
    return punct + 1;
}

int main(int argc, char **argv)
{
    DIR *folder;
    struct dirent *entry;
    struct stat filestat;
    int value;

    if (argc != 3)
    {
        perror("Numar gresit de argumente!");
        exit(1);
    }

    stat(argv[1], &filestat);

    // S_ISDIR verifica daca argumentul este un director sau nu, filestat.st_mode ne da tipul fisierului
    if (!S_ISDIR(filestat.st_mode))
    {
        perror("Nu este director!");
        exit(1);
    }

    int pid1;
    int status1;

    // opendir descihde directorul al carui path il dam ca prim parametru ( argv[1] )
    folder = opendir(argv[1]);

    if (folder == NULL)
    {
        perror("Unable to read directory");
        return (1);
    }

    char comm[200] = "gcc -o";

    // cat timp se poate citi din acest director prelucram fisierele din el
    while ((entry = readdir(folder)))
    {
        // functia stat ofera diferite statusuri/proprietati ale fisierului cu numele ( entry -> d_name ) sub forma variabilei date ca al doilea parametru functiei stat numit (filestat).
        stat(entry->d_name, &filestat);

        // pastrez in second_arg ca un sir de caractere comenzile date in al doilea parametru
        char *second_arg = argv[2];

        // apelez functia get_c_ext si memorez ce returneaza in variabila get_c_extension
        // char *get_c_extension = get_c_ext(entry->d_name);
        char get_c_extension[500];
        strcpy(get_c_extension, get_c_ext(entry->d_name));

        // cu strcmp verific daca get_c_extension e "c" si daca raspunsul e true atunci "prelucrez" acest fisier altfel trec la fisierul urmator.
        if (strcmp(get_c_extension, "c") == 0)
        {
            strcat(comm, " ");
            strcat(comm, filename_without_extension(entry->d_name));
            strcat(comm, " ");
            strcat(comm, realpath(entry->d_name, NULL));
            printf("%s\n", comm);
            // folosesc acest for pentru a "decoda" al doilea parametru si sa fac ce mi se cere la fiecare pas al comenzii
            for (int i = 1; i < strlen(second_arg); i++)
            {

                if (second_arg[i] == 'n')
                {
                    printf("\n");
                    printf("Nume: %s \n", entry->d_name);
                }

                if (second_arg[i] == 'u')
                {
                    printf("\n");
                    // filestat.st_uid da user identifier ul fisierului
                    printf("user identifier: %d \n", filestat.st_uid);
                }

                if (second_arg[i] == 'a')
                {
                    printf("\n");
                    printf("Pentru fisierul: %s \n", entry->d_name);
                    // pentru User
                    printf("Utilizator: Read - %s || Write - %s || Execute - %s \n", (((filestat.st_mode) & S_IRUSR) ? "Da" : "Nu"), (((filestat.st_mode) & S_IWUSR) ? "Da" : "Nu"), (((filestat.st_mode) & S_IXUSR) ? "Da" : "Nu"));

                    // pentru Grup
                    printf("Grup: Read - %s || Write - %s || Execute - %s \n", (((filestat.st_mode) & S_IRGRP) ? "Da" : "Nu"), (((filestat.st_mode) & S_IWGRP) ? "Da" : "Nu"), (((filestat.st_mode) & S_IXGRP) ? "Da" : "Nu"));

                    // pentru Others
                    printf("Others: Read - %s || Write - %s || Execute - %s \n", (((filestat.st_mode) & S_IROTH) ? "Da" : "Nu"), (((filestat.st_mode) & S_IWOTH) ? "Da" : "Nu"), (((filestat.st_mode) & S_IXOTH) ? "Da" : "Nu"));
                }

                if (second_arg[i] == 'd')
                {
                    printf("\n");
                    // filestat.st_size ne da dimensiunea in kb a fisierului
                    printf("Dimensiunea in octeti este: %ld Kb \n", filestat.st_size);
                }

                if (second_arg[i] == 'c')
                {
                    printf("\n");
                    // filestat.st_nlink ne da numarul de hard linkuri al fisierului
                    printf("Numarul de linkuri al fisierului este: %ld \n", filestat.st_nlink);
                }

                if (second_arg[i] == 'g')
                {
                    // lansezi procesul
                    pid1 = fork();
                    if (pid1 < 0)
                    {
                        perror("Eroare lansare proces!");
                        exit(1);
                    }
                    // intri pe procesul copil
                    if (pid1 == 0)
                    {
                        // system(comm);
                        printf("da--");
                        exit(0);
                    }
                    // in procesul parinte astepti terminarea proceseului copil
                    pid1 = wait(&status1);
                    if (pid1 < 0)
                    {
                        perror("Eroare!");
                        exit(1);
                    }
                    else
                    {
                        printf("Procesul cu fiu PID %d s-a terminat cu codul %d\n", pid1, status1);
                    }
                }
            }

            // daca dimensiunea este mai mica de 100 de KB atunci se face o legatura simbolica care sa aiba acelasi nume
            if (filestat.st_size < 1000000)
            {
                printf("\n");
                // realpath returneaza path ul real in variabila pth
                char *pth = realpath(entry->d_name, NULL);
                // in value se pastreaza 0 daca se creeaza o legatura simbolica si un alt numar daca nu se poate crea, sau NULL
                int value = symlink(pth, filename_without_extension(entry->d_name));
                if (value == 0)
                {
                    printf("A fost creata o legatura simbolica pentru fisierul: %s.c, cu numele %s \n", entry->d_name, filename_without_extension(entry->d_name));
                }
                else
                {
                    printf("\n\nlegatura simbolica a fost deja creata sau nu poate fi creata\n\n");
                }
            }
        }
    }

    closedir(folder);

    return (0);
}