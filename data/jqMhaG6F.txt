package reghzy.api.utils.text;

import gnu.trove.list.array.TIntArrayList;
import reghzy.api.linq.Linq;
import reghzy.api.utils.Maths;

import javax.annotation.Nonnull;
import java.util.ArrayList;

public class TextGrid {
    // Rows<Columns<contents>>
    // Outer list contains the rows. These contain the "column" parts inside
    private final ArrayList<ArrayList<String>> rows;

    private boolean centerTopLeft = true;
    private boolean centerContents = true;

    private char fillChar = ' ';
    private String emptyCellString = "";

    public TextGrid() {
        this.rows = new ArrayList<ArrayList<String>>();
    }

    public boolean centerTopLeft() {
        return this.centerTopLeft;
    }

    public TextGrid centerTopLeft(boolean centerTopLeft) {
        this.centerTopLeft = centerTopLeft;
        return this;
    }

    public boolean centerContents() {
        return this.centerContents;
    }

    public TextGrid centerContents(boolean center) {
        this.centerContents = center;
        return this;
    }

    public char getFillChar() {
        return this.fillChar;
    }

    public TextGrid setFillChar(char fillChar) {
        this.fillChar = fillChar;
        return this;
    }

    public String getEmptyCellString() {
        return this.emptyCellString;
    }

    public TextGrid setEmptyCellString(@Nonnull String emptyCellString) {
        this.emptyCellString = StringUtils.nullToEmpty(emptyCellString);
        return this;
    }

    public TextGrid line(String... columns) {
        ArrayList<String> list = nextList();
        list.addAll(Linq.of(columns).map(StringUtils::nullToEmpty).toList());
        return this;
    }

    private int getTotalColumnCount() {
        return Linq.wrap(this.rows).aggregate(-1, (a, b) -> Math.max(a.size(), b));
    }

    private ArrayList<String> nextList() {
        ArrayList<String> list = new ArrayList<String>();
        this.rows.add(list);
        return list;
    }

    public String format(String rowSeparator, String columnSeparator) {
        int columns = getTotalColumnCount();
        if (columns == -1) {
            return StringUtils.repeat('\n', this.rows.size());
        }

        StringBuilder output = new StringBuilder();

        int[] column_sizes = getColumnSizeArray(columns);

        for (int i = 0, rowEnd = this.rows.size() - 1; i <= rowEnd; i++) {
            StringBuilder row = formatRow(null, null, columnSeparator, columns, column_sizes, i);
            output.append(row);
            if (i != rowEnd) {
                output.append(rowSeparator);
            }
        }

        return output.toString();
    }

    private int[] getColumnSizeArray(int columns) {
        int[] column_sizes = new int[columns];
        for (int i = 0; i < this.rows.size(); i++) {
            ArrayList<String> row = this.rows.get(i);
            for (int j = 0; j < columns; j++) {
                column_sizes[j] = Math.max(column_sizes[j], getCellAt(row, j).length());
            }
        }

        return column_sizes;
    }

    private StringBuilder formatRow(String prefix, String postfix, String cellSeparator, int columns, int[] column_sizes, int rowIndex) {
        StringBuilder sb = new StringBuilder();
        if (prefix != null) {
            sb.append(prefix);
        }

        boolean centered = this.centerContents || (rowIndex == 0 && this.centerTopLeft);

        ArrayList<String> row = this.rows.get(rowIndex);
        for (int j = 0, colEnd = columns - 1; j <= colEnd; j++) {
            // append padding between the gaps
            // if (j > 0) sb.append(' ');

            // allow fine control over centered parts
            boolean center = (rowIndex == 0 || j == 0) ? this.centerTopLeft : this.centerContents;

            String cell = getCellAt(row, j);
            int cellWidth = column_sizes[j];
            int emptySpace = cellWidth - cell.length();

            if (center && StringUtils.isNotEmpty(cell)) {
                double half = (double) emptySpace / 2d;
                StringUtils.repeatInto(sb, this.fillChar, Maths.ifastfloor(half));
                sb.append(cell);
                StringUtils.repeatInto(sb, this.fillChar, Maths.ifastceil(half));
            }
            else {
                sb.append(cell);
                if (emptySpace > 0) {
                    StringUtils.repeatInto(sb, this.fillChar, emptySpace);
                }
            }

            // append padding between the gaps
            // if (j != colEnd) sb.append(' ');

            if (j != colEnd) {
                // don't append separator to last column
                sb.append(cellSeparator);
            }
        }

        if (postfix != null) {
            sb.append(postfix);
        }

        return sb;
    }

    private String getCellAt(int row, int col) {
        if (col < 0 || row < 0 || row >= this.rows.size()) {
            return null;
        }

        return getCellAt(this.rows.get(col), col);
    }

    private String getCellAt(ArrayList<String> row, int column) {
        return (column < 0 || column >= row.size()) ? this.emptyCellString : row.get(column);
    }

    private static void set(TIntArrayList list, int index, int value) {
        list.set(index, value);
    }
}
