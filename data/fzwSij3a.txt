void checkHigher() {
	if (isGameWithBot)
		if (highestCards[0] > highestCards[1]) {
			winnerName = "Вы";
			return;
		} else if (highestCards[0] == highestCards[1]) {
			for (int i = 0; i < AMOUNT_OF_HAND_CARDS; i++) {
				if (playersCards[0][i].value > playersCards[1][i].value) {
                    winnerName = "Вы";
					return;
				} else if (playersCards[0][i].value < playersCards[1][i].value) {
                    winnerName = "Бот";
					return;
				}
			}
			winnerName = "Отсутствует (Ничья)";

		} else {
            winnerName = "Бот";
			return;
        }
	else {
		int maxI = 0;
		int max = highestCards[maxI];
		for (int i = 1; i < amountOfPlayers; i++) {
			if (highestCards[i] > max) {
				max = highestCards[i];
				maxI = i;
			} else if (highestCards[i] == max) {
				for (int j = 0; j < AMOUNT_OF_HAND_CARDS; j++) {
					if (playersCards[i][j].value > playersCards[maxI][j].value) {
						max = highestCards[i];
						maxI = i;
						break;
					}
				}
			}
		}
		winnerName = playersNames[maxI];
		combinationName = combinations[playersCombinations[maxI]];
    }
}

//-------------------------Winner Finder-----------------------------------------

void insertionSort(Card arr[],const int n) {
	for(int i = 1; i < n; i++) {
		int j = i - 1;
		while(j > -1 && arr[j].value < arr[j + 1].value) {
			swap(arr[j], arr[j + 1]);
			j--;
		}
	}
}

void findCombinationForPlayer(Card сards[], int n, int index) {
	Card savedCards[n];
	for (int i = 0; i < n; i++)
		savedCards[i] = сards[i];

	if (isRoyalFlush(сards, n, index))
		playersCombinations[index] = 9;
	else if (isStraightFlush(сards, n, index))
		playersCombinations[index] = 8;
	else if (isFour(сards, n, index))
		playersCombinations[index] = 7;
	else if (isFullHouse(сards, n, index))
		playersCombinations[index] = 6;
	else if (isFlush(сards, n, index))
		playersCombinations[index] = 5;
	else if (isStraight(сards, n, index))
		playersCombinations[index] = 4;
	else if (isSet(сards, n, index))
		playersCombinations[index] = 3;
	else if (isTwoPair(сards, n, index))
		playersCombinations[index] = 2;
	else if (isPair(сards, n, index))
		playersCombinations[index] = 1;
    else
		playersCombinations[index] = 0;
}

void setVicroryWithBot(Card playerCards[], Card botCards[]) {
	if (playersCombinations[0] > playersCombinations[1]) {
		winnerName = "Вы";
		combinationName = combinations[playersCombinations[0]];
	} else if (playersCombinations[0] == playersCombinations[1]) {
		checkHigher();
		combinationName = combinations[playersCombinations[0]];
	} else {
		winnerName = "Бот";
		combinationName = combinations[playersCombinations[1]];
	}
}

void TMainForm::ConfigureChips() {
	if (winnerName == "Вы") {
		playersChips[0] += bank;
		ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
	} else if (winnerName == "Бот") {
		playersChips[1] += bank;
		BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
	} else {
		playersChips[0] += bank / 2;
		playersChips[1] += bank / 2;
        ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
		BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
	}
    bank = 0;
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
}

void TMainForm::FindWinnerWithBot() {
	Card* playerCards = new Card[AMOUNT_OF_CARDS_FOR_COMBINATION];
	Card* botCards = new Card[AMOUNT_OF_CARDS_FOR_COMBINATION];

	for (int i = 0; i < AMOUNT_OF_CARDS_FOR_COMBINATION; i++) {
		if (i < 2) {
			playerCards[i] = playersCards[0][i];
			botCards[i] = playersCards[1][i];
		} else {
			playerCards[i] = tableCards[i - 2];
			botCards[i] = tableCards[i - 2];
		}
	}

	insertionSort(playerCards, AMOUNT_OF_CARDS_FOR_COMBINATION);
	insertionSort(botCards, AMOUNT_OF_CARDS_FOR_COMBINATION);
	for (int i = 0; i < amountOfPlayers; i++)
		insertionSort(playersCards[i], 2);

	findCombinationForPlayer(playerCards, AMOUNT_OF_CARDS_FOR_COMBINATION, 0);
	findCombinationForPlayer(botCards, AMOUNT_OF_CARDS_FOR_COMBINATION, 1);

	setVicroryWithBot(playerCards, botCards);

	ConfigureChips();
}

//------------------------Game Buttons Methods-----------------------------------

void __fastcall TMainForm::FoldBtnClick(TObject *Sender) {
	if (!isGameWithBot)
		ConfigureFoldWithPlayers();
	else
		ConfigureFoldWithBot();
}

void __fastcall TMainForm::CallBtnClick(TObject *Sender) {
	if (!isGameWithBot)
		ConfigureCallWithPlayers();
	else
		ConfigureCallWithBot();
}

void __fastcall TMainForm::RaiseBtnClick(TObject *Sender) {
	if (!isGameWithBot)
		ConfigureRaiseWithPlayers();
	else
        ConfigureRaiseWithBot();
}

void __fastcall TMainForm::HideCardsBtnClick(TObject *Sender) {
	DistributeTableCards();
	ChangePlayers();
}

//------------------------Bot Methods-----------------------------------

void __fastcall TMainForm::PlayWithBotBtnClick(TObject *Sender) {
	isGameWithBot = true;
	HideMainMenuButtons();
	BotPreparingForm -> ShowModal();
    BackToMenu -> Visible = true;
}

void TMainForm::PrepareGameTableWithBot(const int chips) {
	FirstBotCard -> Picture -> LoadFromFile("cards/back_of_card.png");
	SecondBotCard -> Picture -> LoadFromFile("cards/back_of_card.png");
    amountOfChips = chips;
	amountOfPlayers = 2;
    BotPreparingForm -> Close();
	randomize();
	for (int i = 1; i < amountOfPlayers + 1; i++) {
		GiveCardsToPlayer(i);
	}
	GenerateTableCards();
	Background -> Picture -> LoadFromFile("background_game.png");
	FirstHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[0][0].value) + "_of_" + playersCards[0][0].suit + ".png");
	SecondHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[0][1].value) + "_of_" + playersCards[0][1].suit + ".png");
	ShowBotCards();
	ShowHandCards();
	ShowButtons();
	HideCardsBtn -> Visible = false;
	ShowLabels();
	PlayerNameLabel -> Visible = false;
	PrepareChips();
	isFirstGame = false;
}

void TMainForm::PrepareNewTableWithBot() {
	FirstBotCard -> Picture -> LoadFromFile("cards/back_of_card.png");
	SecondBotCard -> Picture -> LoadFromFile("cards/back_of_card.png");
	amountOfPlayers = 2;
	randomize();
    isInGame[1] = true;
	for (int i = 1; i < amountOfPlayers + 1; i++) {
		GiveCardsToPlayer(i);
        GenerateTableCards();
	}
	FirstHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[0][0].value) + "_of_" + playersCards[0][0].suit + ".png");
	SecondHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[0][1].value) + "_of_" + playersCards[0][1].suit + ".png");
    NextRoundBtn -> Visible = false;
}

void __fastcall TMainForm::NextRoundBtnClick(TObject *Sender) {
	EnableButtons();
	createArrayOfCards();
	if (isGameWithBot)
		PrepareNewTableWithBot();
	else
		PrepareNewTableWithPlayers();

	HideCards();
	initFlops();
	changeBlinds();

	WinnerLabel -> Visible = false;
	CombinationLabel -> Visible = false;
	ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);

	int minBlind = amountOfChips / DIVIDER_FOR_SMALL_BLIND;
	FirstHandCard -> Visible = true;
	SecondHandCard -> Visible = true;

	PrepareChips();

	if (isGameWithBot) {
		BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
        FirstBotCard -> Visible = true;
		SecondBotCard -> Visible = true;
	} else {
		hideCardsAndLabelsFormArrays();
        CrownImage -> Visible = false;
	}

}

void TMainForm::FoldForBot() {
    FirstBotCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[1][0].value) + "_of_" + playersCards[1][0].suit + ".png");
	SecondBotCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[1][1].value) + "_of_" + playersCards[1][1].suit + ".png");
	playersChips[0] += bank;
	ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
	bank = 0;
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
	WinnerLabel -> Visible = true;
	WinnerLabel -> Caption = WINNER_LABEL + "Вы";
	NextRoundBtn -> Visible = true;
    isInGame[1] = false;
	TurnOffButtons();
}

void TMainForm::CallForBot() {
	if (bid >= playersChips[1]) {
		FoldForBot();
	} else {
		bank += bid;
		BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
		playersChips[1] -= bid;
		BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
		if (bid == 0)
			CallBtn -> Caption = CHECK_CAPTION;
		EnableButtons();
	}
    isRaised = false;
	bid = 0;
}

void TMainForm::RaiseForBot(int amount) {
	if (isInAllIn)
		CallForBot();
	else {
		bid = amount;
		bank += bid;
		BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
		playersChips[1] -= bid;
		BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
		isRaised = true;
		if (bid >= playersChips[0]) {
			CallBtn -> Caption = ALL_IN_CAPTION;
			bid = playersChips[0];
			isInAllIn = true;
			RaiseBtn -> Enabled = false;
		} else
			CallBtn -> Caption = CALL_CAPTION + IntToStr(bid) + ")";
		isOnceRaised = true;
	}
}

//-------------------Analyzation Methods-------------------------------

void TMainForm::AnalyzePreFlop() {
	int randomNumber;
	randomize;
	if (isFirstTimeOnThisStage)
		if (!isRaised) { //нет повышения от игрока
			if (playersCards[1][0].value == playersCards[1][1].value && !isOnceRaised) { //если у бота пара
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) { //10% не повысить ставку
					CallForBot();
				} else { //90% на большое/небольшое повышение
					int amount;
					randomNumber = random(2);
					if (randomNumber == 0) //рандом много/мало
						amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
					else
						amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
					RaiseForBot(amount);
				}
			} else if (!isOnceRaised) { //блеф
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) { //10% блефануть
					int amount;
					randomNumber = random(2);
					if (randomNumber == 0) //рандом много/мало
						amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
					else
						amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
					RaiseForBot(amount);
				}
			}
		} else if (bid >= playersChips[1] / DIVIDER_FOR_BIG_BID) { //повышение от игрока с большой ставкой
			if (playersCards[1][0].value == playersCards[1][1].value) { //если у бота пара
				CallForBot();
			} else {
                randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) //10% блефануть
					CallForBot();
				else //90% сбросить
					FoldForBot();
            }
		} else //небольшая ставка
			CallForBot();
	if (!isRaised) {
		CallBtn -> Caption = CHECK_CAPTION;
        bid = 0;
		isPreFlop = false;
		isFlop = true;
		if (isInGame[1])
			ShowTableCards(3);
	}
	isFirstTimeOnThisStage = false;
}

void TMainForm::AnalyzeFlop() {
	const int AMOUNT_OF_SHOWN_CARDS = AMOUNT_OF_HAND_CARDS + 3;
	int randomNumber;

	Card botCards[AMOUNT_OF_SHOWN_CARDS];

	for (int i = 0; i < AMOUNT_OF_SHOWN_CARDS; i++)
		if (i < 2)
			botCards[i] = playersCards[1][i];
		else
			botCards[i] = tableCards[i - 2];

	randomize;
	if (isFirstTimeOnThisStage) {
		findCombinationForPlayer(botCards, AMOUNT_OF_SHOWN_CARDS, 1); //нынешняя комбинация бота
		if (!isRaised) { //нет повышения от игрока
			if (playersCombinations[1] > 1 && !isOnceRaised) { //если у бота уже есть комбинация выше пары
				int amount;
				randomNumber = random(2);
				if (randomNumber == 0) //рандом много/мало
					amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
				else
					amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
				RaiseForBot(amount); //повышает
			} else if (!isOnceRaised) { //блеф
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) { //10% блефануть
					int amount;
					randomNumber = random(2);
					if (randomNumber == 0) //рандом много/мало
						amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
					else
						amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
					RaiseForBot(amount);
				}
			}
		} else if (bid >= playersChips[1] / DIVIDER_FOR_BIG_BID) { //повышение от игрока с большой ставкой
			if (playersCombinations[1] > 1) { //если у бота комбинация выше пары
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) { //10% не поддержать ставку
					FoldForBot();
				} else { //90% поддержать ставку
					CallForBot();
				}
			} else {
                randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 80) //20% блефануть
					CallForBot();
				else //80% сбросить
					FoldForBot();
			}
		} else { //небольшая ставка
			if (playersCombinations[1] > 0) { //если у бота пара или выше
				CallForBot(); //поддерживает
			} else {
                randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 50) { //50% не поддержать ставку
					FoldForBot();
				} else { //50% поддержать ставку
					CallForBot();
				}
            }

		}
	}
	if (!isRaised) {
		CallBtn -> Caption = CHECK_CAPTION;
		isFlop = false;
		isTurn = true;
		isOnceRaised = false;
		bid = 0;
		if (isInGame[1]) //если бот не сбросил
			ShowTableCards(4);
	}
	isFirstTimeOnThisStage = false;
}

void TMainForm::AnalyzeTurn() {
	const int AMOUNT_OF_SHOWN_CARDS = AMOUNT_OF_HAND_CARDS + 4;
	int randomNumber;

	Card botCards[AMOUNT_OF_SHOWN_CARDS];

	for (int i = 0; i < AMOUNT_OF_SHOWN_CARDS; i++)
		if (i < 2)
			botCards[i] = playersCards[1][i];
		else
			botCards[i] = tableCards[i - 2];

	randomize;
	if (isFirstTimeOnThisStage) {
		findCombinationForPlayer(botCards, AMOUNT_OF_SHOWN_CARDS, 1); //нынешняя комбинация бота
		if (!isRaised) { //нет повышения от игрока
			if (playersCombinations[1] > 3 && !isOnceRaised) { //если у бота комбинация выше сета
				int amount;
				randomNumber = random(2);
				if (randomNumber == 0) //рандом много/мало
					amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
				else
					amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
				RaiseForBot(amount); //повышает
			} else if (!isOnceRaised) { //блеф
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 80) { //20% блефануть
					int amount;
					randomNumber = random(2);
					if (randomNumber == 0) //рандом много/мало
						amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
					else
						amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
					RaiseForBot(amount);
				}
			}
		} else if (bid >= playersChips[1] / DIVIDER_FOR_BIG_BID) { //повышение от игрока с большой ставкой
			if (playersCombinations[1] > 3) { //если у бота комбинация выше сета
				CallForBot(); //поддерживает
			} else {
                randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 70) //30% блефануть
					CallForBot();
				else //70% сбросить
					FoldForBot();
			}
		} else { //небольшая ставка
			if (playersCombinations[1] > 0) { //если у бота пара или выше
				CallForBot(); //поддерживает
			} else {
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 50) { //50% не поддержать ставку
					FoldForBot();
				} else { //50% поддержать ставку
					CallForBot();
				}
			}
		}
    }
	if (!isRaised) {
		CallBtn -> Caption = CHECK_CAPTION;
		isTurn = false;
		isRiver = true;
		isOnceRaised = false;
		bid = 0;
		if (isInGame[1]) //если бот не сбросил
			ShowTableCards(5);
	}
	isFirstTimeOnThisStage = false;
}

void TMainForm::AnalyzeRiver() {
	const int AMOUNT_OF_SHOWN_CARDS = AMOUNT_OF_HAND_CARDS + AMOUNT_OF_TABLE_CARDS;
	int randomNumber;

	Card botCards[AMOUNT_OF_SHOWN_CARDS];

	for (int i = 0; i < AMOUNT_OF_SHOWN_CARDS; i++)
		if (i < 2)
			botCards[i] = playersCards[1][i];
		else
			botCards[i] = tableCards[i - 2];

	randomize;
	if (isFirstTimeOnThisStage) {
		findCombinationForPlayer(botCards, AMOUNT_OF_SHOWN_CARDS, 1); //нынешняя комбинация бота
		if (!isRaised) { //нет повышения от игрока
			if (playersCombinations[1] > 4 && !isOnceRaised) { //если у бота комбинация выше стрита
				int amount;
				randomNumber = random(3);
				if (randomNumber == 0) //33.3% на маленькую ставку
					amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
				else //66.6% на высокую
					amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
				RaiseForBot(amount); //повышает
			} else if (!isOnceRaised) { //блеф
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 80) { //20% блефануть
					int amount;
					randomNumber = random(3);
					if (randomNumber > 0) //66.6% на мальнкую ставку
						amount = playersChips[1] / DIVIDER_FOR_SMALL_BID;
					else //33.3% на высокую
						amount = playersChips[1] / DIVIDER_FOR_BIG_BID;
					RaiseForBot(amount);
				}
			}
		} else if (bid >= playersChips[1] / DIVIDER_FOR_BIG_BID) { //повышение от игрока с большой ставкой
			if (playersCombinations[1] > 3) { //если у бота комбинация выше сета
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 90) { //10% не поддержать ставку
					FoldForBot();
				} else { //90% поддержать ставку
					CallForBot();
				}
			} else {
                randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 80) //20% блефануть
					CallForBot();
				else //80% сбросить
					FoldForBot();
			}
		} else { //небольшая ставка
			if (playersCombinations[1] > 0) { //если у бота пара или выше
				CallForBot(); //поддерживает
			} else {
				randomNumber = random(MAX_PERCENTAGE) + 1;
				if (randomNumber > 50) { //50% не поддержать ставку
					FoldForBot();
				} else { //50% поддержать ставку
					CallForBot();
				}
			}
		}
    }
	if (!isRaised) {
        OpenBotCards();
		FindWinnerWithBot();
		PrintWinner();
		PrintCombination();
		TurnOffButtons();
		NextRoundBtn -> Visible = true;
		if (playersChips[0] == 0 || playersChips[1] == 0) {
			NextRoundBtn -> Visible = false;
			playersChips[0] = amountOfChips;
			playersChips[1] = amountOfChips;
			EndForm -> ShowModal();
		}
	}
	isFirstTimeOnThisStage = false;
}

void TMainForm::AnalyzeSituation() {
	if (isPreFlop) {
		AnalyzePreFlop();
		isOnceRaised = false;
	} else if (isFlop) {
		isFirstTimeOnThisStage = true;
		AnalyzeFlop();
	} else if (isTurn) {
		isFirstTimeOnThisStage = true;
		AnalyzeTurn();
	} else if (isRiver) {
		isFirstTimeOnThisStage = true;
		AnalyzeRiver();
	}
}

//-------------------------Player Actions With Bot-------------------------------

void TMainForm::ConfigureFoldWithBot() {
	FirstBotCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[1][0].value) + "_of_" + playersCards[1][0].suit + ".png");
	SecondBotCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[1][1].value) + "_of_" + playersCards[1][1].suit + ".png");
	playersChips[1] += bank;
	BotChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[1]);
	bank = 0;
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
	WinnerLabel -> Visible = true;
	WinnerLabel -> Caption = WinnerLabel -> Caption + "Бот";
	NextRoundBtn -> Visible = true;
	TurnOffButtons();
}

void TMainForm::ConfigureCallWithBot() {
	bank += bid;
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
	playersChips[0] -= bid;
	ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
	if (isPreFlop)
		bid = 0;
	if (isInAllIn)
        bid = 0;
	isRaised = false;
	AnalyzeSituation();
}

void TMainForm::ConfigureRaiseWithBot() {
	if (isShown) {
		bid = ChipsTrackBar -> Position;
		ChipsTrackBar -> Visible = false;
		CurrChipsLabel -> Visible = false;
		CurrChipsLabel -> Caption = SELECTED_LABEL + IntToStr(ChipsTrackBar -> Min);
		ChipsTrackBar -> Position = amountOfChips / DIVIDER_FOR_SMALL_BLIND;
		bank += bid;
		BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
		playersChips[0] -= bid;
		ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
		RaiseBtn -> Enabled = true;
		isRaised = true;
		isShown = false;
		AnalyzeSituation();
	 } else {
        ChipsTrackBar -> Min = amountOfChips / DIVIDER_FOR_SMALL_BLIND * 2 + 1;
		ChipsTrackBar -> Max = playersChips[0];
		ChipsTrackBar -> Visible = true;
		FoldBtn -> Enabled = false;
		CallBtn -> Enabled = false;
		CurrChipsLabel -> Visible = true;
		isShown = true;
	 }
}

//-------------------------Players Actions-------------------------------

void TMainForm::ConfigureFoldWithPlayers() {
    HideCardsBtn -> Enabled = true;
	isInGame[currPlayer] = false;
	TurnOffButtons();
	int winner = checkIfWin();
	if (winner != -1)
		ConfigureWinAfterFold(winner);
}

void TMainForm::ConfigureCallWithPlayers() {
	if (playersChips[currPlayer] > bid) {
		playersChips[currPlayer] -= bid;
		bank += bid;
		if (bid == odds)
            bid = savedBid;
	} else {
		bank += playersChips[currPlayer];
		playersChips[currPlayer] = 0;
	}
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
	ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[currPlayer]);
	TurnOffButtons();
	HideCardsBtn -> Enabled = true;
}

void TMainForm::ConfigureRaiseWithPlayers() {
	if (isShown) {
		if (isRaised)
			odds = ChipsTrackBar -> Position - bid;
		bid = ChipsTrackBar -> Position;
		playersChips[currPlayer] -= bid;
		bank += bid;
		ChipsTrackBar -> Visible = false;
		CurrChipsLabel -> Visible = false;
		CurrChipsLabel -> Caption = SELECTED_LABEL + IntToStr(ChipsTrackBar -> Min);
		ChipsTrackBar -> Position = ChipsTrackBar -> Min;
		BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
		ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[currPlayer]);
		RaiseBtn -> Enabled = false;
		HideCardsBtn -> Enabled = true;
		if (isRaised) {
			prevPlayerWhoRaised = playerWhoRaised;
		}
		isRaised = true;
		playerWhoRaised = currPlayer;
		isShown = false;
	} else {
		if (isRaised)
			if (bid == odds)
				ChipsTrackBar -> Min = savedBid + 1;
			else
				ChipsTrackBar -> Min = bid + 1;
		ChipsTrackBar -> Max = playersChips[currPlayer];
		ChipsTrackBar -> Visible = true;
		FoldBtn -> Enabled = false;
		CallBtn -> Enabled = false;
		CurrChipsLabel -> Visible = true;
		isShown = true;
	}
}

//------------------------Players Methods-----------------------------------

void __fastcall TMainForm::PlayWithPeopleBtnClick(TObject *Sender) {
	HideMainMenuButtons();
	WelcomeForm -> ShowModal();
    BackToMenu -> Visible = true;
}

void TMainForm::PrepareGameTable() {
	amountOfPlayers = StrToInt(WelcomeForm -> PlayersSpinEdit -> Text);
    imagesOfPlayersCards = new TImage*[amountOfPlayers * 2];
	lablesOfPlayersNames = new TLabel*[amountOfPlayers];
	for (int i = 0; i < amountOfPlayers * 2; i++) {
		imagesOfPlayersCards[i] = new TImage(MainForm);
		if (i < amountOfPlayers)
			lablesOfPlayersNames[i] = new TLabel(MainForm);
    }
	randomize();
	for (int i = 1; i < amountOfPlayers + 1; i++) {
		GiveCardsToPlayer(i);
	}
	GenerateTableCards();
	Background -> Picture -> LoadFromFile("background_game.png");
	FirstHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][0].value) + "_of_" + playersCards[currPlayer][0].suit + ".png");
	SecondHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][1].value) + "_of_" + playersCards[currPlayer][1].suit + ".png");
	ShowHandCards();
	ShowButtons();
	ShowLabels();
	BotChipsLabel -> Visible = false;
}

void TMainForm::PrepareNewTableWithPlayers() {
	initFlops();
	currPlayer = 0;
	odds = 0;
	isRaised = false;
	isShown = false;
	isOnceRaised = false;
	isFirstGame = false;
	arePlayersCardsShown = true;
	isRoundEnded = false;
	for (int i = 0; i < amountOfPlayers; i++)
        isInGame[i] = true;
	randomize();
	for (int i = 1; i < amountOfPlayers + 1; i++) {
		GiveCardsToPlayer(i);
	}
	GenerateTableCards();
	FirstHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][0].value) + "_of_" + playersCards[currPlayer][0].suit + ".png");
	SecondHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][1].value) + "_of_" + playersCards[currPlayer][1].suit + ".png");
	ShowHandCards();
	ShowButtons();
	ShowLabels();
	HideCardsBtn -> Caption = HIDE_CARDS_STR;
    PlayerNameLabel -> Caption = ACTIVE_LABEL + playersNames[0];
	HideCardsBtn -> Enabled = false;
	BotChipsLabel -> Visible = false;
	NextRoundBtn -> Visible = false;
	ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[0]);
}

void TMainForm::WriteDownPlayers() {
	playersNames[0] = WelcomeForm -> Player1Edit -> Text;
	playersNames[1] = WelcomeForm -> Player2Edit -> Text;
	playersNames[2] = WelcomeForm -> Player3Edit -> Text;
	playersNames[3] = WelcomeForm -> Player4Edit -> Text;
	amountOfChips = WelcomeForm -> ChipsSpinEdit -> Value;
	WelcomeForm -> Close();

	PlayerNameLabel -> Caption = ACTIVE_LABEL + playersNames[0];
	PrepareChips();
}

void TMainForm::ConfigureWinAfterFold(int winner) {
    isRoundEnded = true;
	winnerName = playersNames[winner];
	ConfigureChipsWithPlayers(winner);
	ConfigureGUIForWin(winner);
	PrintWinner();
	HideButtons();
	HideLabels();
	BankLabel -> Visible = true;
	HideCardsBtn -> Visible = false;
	WinnerLabel -> Visible = true;
	NextRoundBtn -> Visible = true;
}

bool allWasShown() {
	if (!isRaised) {
		if (currPlayer == amountOfPlayers - 1)
			return true;
	} else {
		int nextPlayer = (currPlayer + 1) % amountOfPlayers;
		if (nextPlayer == playerWhoRaised)
			return true;
	}

	return false;
}

void TMainForm::InitAllPlayersCardsImages() {
	int j = 0;
	for (int i = 0; i < amountOfPlayers * 2; i++) {
		imagesOfPlayersCards[i] -> Parent = MainForm;
		imagesOfPlayersCards[i] -> Visible = true;
		imagesOfPlayersCards[i] -> Left = FIRST_CARD_LEFT;
		if (i % 2 == 0 && i != 0)
			imagesOfPlayersCards[i] -> Left = imagesOfPlayersCards[i - 1] -> Left + NEW_PAIR_LEFT_ITERATOR;
		else if (i != 0)
			imagesOfPlayersCards[i] -> Left = imagesOfPlayersCards[i - 1] -> Left + SECOND_CARD_LEFT_ITERATOR;

		imagesOfPlayersCards[i] -> Top = CARDS_TOP;
		imagesOfPlayersCards[i] -> AutoSize = true;
		imagesOfPlayersCards[i] -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[j][i % 2].value) + "_of_" + playersCards[j][i % 2].suit + ".png");
		imagesOfPlayersCards[i] -> SendToBack();
		if (i % 2 != 0) {
			imagesOfPlayersCards[i] -> BringToFront();
			j++;
		}
	}
}

void TMainForm::InitAllPlayersNamesLabels() {
	for (int i = 0; i < amountOfPlayers; i++) {
		lablesOfPlayersNames[i] -> Parent = MainForm;
		lablesOfPlayersNames[i] -> Visible = true;
		lablesOfPlayersNames[i] -> AutoSize = true;
		if (isInGame[i])
			lablesOfPlayersNames[i] -> Caption = playersNames[i];
		else
			lablesOfPlayersNames[i] -> Caption = playersNames[i] + FOLDED_CAPTION;
		lablesOfPlayersNames[i] -> Left = FIRST_NAMELABEL_LEFT + (PAIR_OF_CARDS_WIDTH - lablesOfPlayersNames[i] -> Width) / 2 + 392 * i;
		lablesOfPlayersNames[i] -> Top = NAMELABEL_TOP;
		lablesOfPlayersNames[i] -> Font -> Size = FONT_SIZE_FOR_NAMELABEL;
		lablesOfPlayersNames[i] -> Font -> Color = clYellow;
	}
}

void TMainForm::ConfigureGUIForWin(int i) {
    InitAllPlayersCardsImages();
	InitAllPlayersNamesLabels();
	Background -> SendToBack();
	CrownImage -> BringToFront();
	CrownImage -> Visible = true;
	CrownImage -> Picture -> LoadFromFile("crown.png");
	FirstHandCard -> Visible = false;
	SecondHandCard -> Visible = false;
	lablesOfPlayersNames[i] -> Visible = false;
	CrownImage -> Left = FISRT_CROWN_LEFT + NEXT_CROWN_LEFT * i;
	CrownImage -> Top = CROWN_TOP;
}

void TMainForm::СheckGameStage() {
	if (isPreFlop && allWasShown()) {
		isPreFlop = false;
		isFlop = true;
		bid = 0;
		CallBtn -> Caption = CHECK_CAPTION;
	} else if (isFlop && allWasShown()) {
		isFlop = false;
		isTurn = true;
		bid = 0;
		CallBtn -> Caption = CHECK_CAPTION;
	} else if (isTurn && allWasShown()) {
		isTurn = false;
		isRiver = true;
		bid = 0;
		CallBtn -> Caption = CHECK_CAPTION;
	} else if (isRiver && allWasShown()) {
		isRoundEnded = true;
		int i = FindWinnerWithPlayers();
		ConfigureGUIForWin(i);
		PrintWinner();
		PrintCombination();
		for (int j = 0; j < amountOfPlayers; j++) {
			if (playersChips[j] == 0) {
				EndForm -> ShowModal();
                break;
            }
		}
    }
}

int findIndexOfMax() {
	int maxI = 0;
	int maxCombination = playersCombinations[maxI];
	for (int i = 1; i < MAX_AMOUNT_OF_PLAYERS; i++) {
		if (playersCombinations[i] > maxCombination) {
			maxI = i;
			maxCombination = playersCombinations[i];
		} else if (playersCombinations[i] == maxCombination) {
			checkHigher();
		}
	}

	return maxI;
}

int setVicroryWithPlayers(Card** cards) {
	int i = findIndexOfMax();
	winnerName = playersNames[i];
	combinationName = combinations[playersCombinations[i]];
	return i;
}

void TMainForm::ConfigureGUIWhileChanging(const int situation) {
	if (situation == 1) {
        FirstHandCard -> Picture -> LoadFromFile("cards/back_of_card.png");
		SecondHandCard -> Picture -> LoadFromFile("cards/back_of_card.png");
		HideCardsBtn -> Caption = SHOW_CARDS_STR;
		int nextPlayer = (currPlayer + 1) % amountOfPlayers;
		if (isInGame[nextPlayer]) {
			if (isRaised && nextPlayer == playerWhoRaised)
                PlayerNameLabel -> Caption = PREPARING_LABEL + playersNames[0];
			else
				PlayerNameLabel -> Caption = PREPARING_LABEL + playersNames[nextPlayer];
			СheckGameStage();
		} else {
			СheckGameStage();
			currPlayer = (currPlayer + 1) % amountOfPlayers;
			ConfigureGUIWhileChanging(situation);
			return;
		}
		HideButtons();
		if (!isRiver)
			HideLabels();
		BankLabel -> Visible = true;
		PlayerNameLabel -> Visible = true;
		HideCardsBtn -> Visible = true;
		FoldBtn -> Enabled = true;
		if (isRiver && allWasShown() && isRoundEnded) {
            PlayerNameLabel -> Visible = false;
			ChipsLabel -> Visible = false;
            NextRoundBtn -> Visible = true;
        	HideCardsBtn -> Visible = false;
        }
	} else if (situation == 2) {
		FirstHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][0].value) + "_of_" + playersCards[currPlayer][0].suit + ".png");
		SecondHandCard -> Picture -> LoadFromFile("cards/" + IntToStr(playersCards[currPlayer][1].value) + "_of_" + playersCards[currPlayer][1].suit + ".png");
		HideCardsBtn -> Caption = HIDE_CARDS_STR;
		HideCardsBtn -> Enabled = false;
		PlayerNameLabel -> Caption = ACTIVE_LABEL + playersNames[currPlayer];
		ChipsLabel -> Caption = CHIPS_LABEL + IntToStr(playersChips[currPlayer]);
		if (bid >= playersChips[currPlayer] && bid != 0)
			CallBtn -> Caption = ALL_IN_CAPTION;
        ShowButtons();
		EnableButtons();
		ShowLabels();
    }
}

void TMainForm::ConfigureRaisingAndCalling() {
	if (isRaised) {
		if (currPlayer == playerWhoRaised) {
			currPlayer = 0;
			bid = 0;
			isRaised = false;
		} else {
			if (odds != 0) { //если было переповышение
				savedBid = bid;
				if ((prevPlayerWhoRaised + 1) % amountOfPlayers == playerWhoRaised) { //если переповышение было сразу
					if (currPlayer == prevPlayerWhoRaised) {
						bid = odds;
					}
				} else { //не сразу
					if (currPlayer != playerWhoRaised) {
						bid = odds;
					}
                }
			}
			CallBtn -> Caption = CALL_CAPTION + IntToStr(bid) + ")";
		}
	} else {
		if (isPreFlop) {
			if (currPlayer == smallBlind) {
				bid = amountOfChips / DIVIDER_FOR_SMALL_BLIND;
				CallBtn -> Caption = CALL_CAPTION + IntToStr(bid) + ")";
			} else if (currPlayer == bigBlind) {
				bid = 0;
				CallBtn -> Caption = CHECK_CAPTION;
			} else {
                bid = amountOfChips / DIVIDER_FOR_SMALL_BLIND * 2;
				CallBtn -> Caption = CALL_CAPTION + IntToStr(bid) + ")";
            }
		}
	}
}

void TMainForm::ChangePlayers() {
	if (arePlayersCardsShown) {
		ConfigureGUIWhileChanging(1);
		arePlayersCardsShown = false;
	} else {
		currPlayer = (currPlayer + 1) % amountOfPlayers;
		ConfigureRaisingAndCalling();
		ConfigureGUIWhileChanging(2);
        arePlayersCardsShown = true;
	}
}

void TMainForm::ConfigureChipsWithPlayers(int i) {
	playersChips[i] += bank;
	bank = 0;
	BankLabel -> Caption = BANK_LABEL + IntToStr(bank);
}

int TMainForm::FindWinnerWithPlayers() {
	int challengers = 0;
	for (int i = 0; i < amountOfPlayers; i++) {
		if (isInGame[i])
			challengers++;
	}

	Card** challengersCards = new Card*[MAX_AMOUNT_OF_PLAYERS];
	for (int i = 0; i < MAX_AMOUNT_OF_PLAYERS; i++)
		challengersCards[i] = new Card[AMOUNT_OF_CARDS_FOR_COMBINATION];

	for (int i = 0; i < amountOfPlayers; i++)
		if (isInGame[i])
			for (int j = 0; j < AMOUNT_OF_CARDS_FOR_COMBINATION; j++)
				if (j < 2)
					challengersCards[i][j] = playersCards[i][j];
				else
					challengersCards[i][j] = tableCards[j - 2];


	for (int i = 0; i < MAX_AMOUNT_OF_PLAYERS; i++)
		insertionSort(challengersCards[i], AMOUNT_OF_CARDS_FOR_COMBINATION);

	for (int i = 0; i < amountOfPlayers; i++)
		if (isInGame[i])
			findCombinationForPlayer(challengersCards[i], AMOUNT_OF_CARDS_FOR_COMBINATION, i);

	int i = setVicroryWithPlayers(challengersCards);

	ConfigureChipsWithPlayers(i);

	return i;
}