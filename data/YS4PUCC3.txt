#include <fstream>
#include <iostream>
#include <vector>

using namespace std;

using Time = double;

// Number of seconds in one day
const Time DefaultTimeStep{ 24.0 * 60 * 60 }; 
// Gravitational Constant from the Newtons law
const double G{ 6.67e-11 };
// Mass of the Sun
const double SunMass{ 2.0e30 };
// Mass of the Earth
const double EarthMass{ 5.972e24 };
// Distance between Earth and Sun
const double EarthToSunDistance{ 1.5e11 };
// Velocity of Earth
const double EarthVelocity{ 29290 };

struct Position
{
  double x{ 0. };
  double y{ 0. };
};

struct Vector {
  double x{ 0. };
  double y{ 0. };

  double abs() const {
    return std::sqrt(x * x + y * y);
  }
};

// Calculates the difference vector between pair of points in 2D space
Vector calculateDifference(const Position from, const Position to)
{
  Vector difference;
  difference.x = to.x - from.x;
  difference.y = to.y - from.y;

  return difference;
}

// Calculates the distance between pair of points in 2D space
double calculateDistance(const Position from, const Position to)
{
  Vector direction;
  direction.x = to.x - from.x;
  direction.y = to.y - from.y;

  return direction.abs();
}

struct SpaceBody
{
  double mass{ 0. };
  Position position;
  Vector velocity;
  // Stores position of the space object on each iteration 
  vector<Position> pathway;

  void updatePosition(const SpaceBody& other, const Time dt)
  {
    const Vector direction = calculateDifference(position, other.position);
    const double distance = calculateDistance(position, other.position);

    // Fx = G * m * M * x / r^3 , but here we divide on mass as well, because it will go :)
    // Pay attention that this is "x" in numerator and "r^3" in denominator
    // (not r^2 - but r^3 because in the numerator we multiply on "x" to find the direction of force action)
    const double acceleration_x = G * other.mass * direction.x / (distance * distance * distance);
    const double acceleration_y = G * other.mass * direction.y / (distance * distance * distance);

    // dv/dt = a -> dv = a * dt 
    velocity.x += acceleration_x * dt;
    velocity.y += acceleration_y * dt;

    // dx/dt = v -> dx = v * dt 
    position.x += velocity.x * dt;
    position.y += velocity.y * dt;

    pathway.push_back(position);
  }
};

// Set all required physical values for the sun
void initSun(SpaceBody& sun)
{
  sun.mass = SunMass;

  sun.position.x = 0;
  sun.position.y = 0;

  sun.velocity.x = 0;
  sun.velocity.y = 0;
}

// Set all required physical values for the earth
void initEarth(SpaceBody& earth)
{
  earth.mass = SunMass;

  earth.position.x = 0;
  earth.position.y = EarthToSunDistance;

  earth.velocity.x = EarthVelocity;
  earth.velocity.y = 0;
}

// !!! OPTIONAL FUNCTION ONLY FOR VISUALIZATION !!! YOU COULD REMOVE IT WITH THE CORRESPONDING CODE IN main() FUNCTION
void printData(const std::vector<Position>& sun_path, const std::vector<Position>& earth_path)
{
  std::ofstream out("planets_pathway.csv");
  out << "sun_x" << "," << "sun_y" << "," << "earth_x" << "," << "earth_y" << '\n';
  for (int id = 0; id < sun_path.size(); ++id)
    out << sun_path[id].x << "," << sun_path[id].y << "," << earth_path[id].x << "," << earth_path[id].y << '\n';
}

int main()
{
  SpaceBody sun;
  initSun(sun);

  SpaceBody earth;
  initEarth(earth);

  int simulation_days{ 0 };
  std::cout << "Input number of days for the simulation: ";
  std::cin >> simulation_days;

  try
  {
    for (int day = 0; day < simulation_days; ++day)
    {
      earth.updatePosition(sun, DefaultTimeStep);
      sun.updatePosition(earth, DefaultTimeStep);
    }

  }
  catch (const exception& error)
  {
    cout << "Error during simulation: " << error.what() << endl;
  }

  printData(sun.pathway, earth.pathway);

  return 0;
}
