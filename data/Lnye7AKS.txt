#include <iostream>
#include <string>

class node {
public:
	int data;
	node* left;
	node* right;
	node* parent;
	node(int data = 0, node* left = nullptr, node* right = nullptr, node* parent = nullptr) {
		this->data = data;
		this->left = left;
		this->right = right;
		this->parent = parent;
	}
	node(const node* x) {
		this->data = x->data;
		this->left = x->left;
		this->right = x->right;
		this->parent = x->parent;
	}
	~node() {}
};

class bin_tree {
public:
	node* root = new node();
	bin_tree() {
		root->data = INT_MIN;
	}
	void insert(node* x, int data);
	void post_order(node* x);
	bool exists(node* x, int data);
	node* find(node* x, int data);
	node* min(node* x);
	node* max(node* x);
	node* next(node* x);
	node* prev(node* x);
	int find_next(node* x, int data, int delta, int closest);
	int find_prev(node* x, int data, int delta, int closest);
	void del(node* x);
};

int main() {
	std::string s;
	bin_tree tree;
	int n;
	while (std::cin >> s) {
		std::cin >> n;
		if (s[0] == 'i') {
			if (tree.root->data == INT_MIN)
				tree.root->data = n;
			else
				tree.insert(tree.root, n);
		}
		else if (s[0] == 'd') {
			node* temp = tree.find(tree.root, n);
			if (temp != nullptr)
				tree.del(temp);
		}
		else if (s[0] == 'e') {
			if (tree.exists(tree.root, n))
				std::cout << "true";
			else
				std::cout << "false";
		}
		else if (s[0] == 'n') {
			int temp_ = tree.find_next(tree.root, n, INT_MAX, INT_MIN);
			if (temp_ != INT_MIN)
				std::cout << temp_;
			else
				std::cout << "none";
		}
		else if (s[0] == 'p') {
			int temp_ = tree.find_prev(tree.root, n, INT_MAX, INT_MIN);
			if (temp_ != INT_MIN)
				std::cout << temp_;
			else
				std::cout << "none";
		}
		std::cout << "\n";
	}
	return 0;
}

void bin_tree::insert(node* x, int data)
{
	while (x != nullptr) {
		if (data > x->data) {
			if (x->right != nullptr) {
				x = x->right;
			}
			else {
				node* z = new node(data, nullptr, nullptr, x);
				x->right = z;
				break;
			}
		}
		else if (data < x->data) {
			if (x->left != nullptr) {
				x = x->left;
			}
			else {
				node* z = new node(data, nullptr, nullptr, x);
				x->left = z;
				break;
			}
		}
	}


}

void bin_tree::post_order(node* x)
{
	if (x != nullptr) {
		post_order(x->left);
		post_order(x->right);
		std::cout << x->data << " ";
	}
}

bool bin_tree::exists(node* x, int data)
{
	if (x == nullptr)
		return false;
	if (x->data == data)
		return true;
	if (data < x->data)
		exists(x->left, data);
	else
		exists(x->right, data);
}

node* bin_tree::min(node* x)
{
	if (x->left == nullptr)
		return x;
	return min(x->left);
}

node* bin_tree::max(node* x)
{
	if (x->right == nullptr)
		return x;
	return max(x->right);
}

node* bin_tree::next(node* x)
{
	node* y;
	if (x->right != nullptr) {
		node* y = min(x->right);
		return y;
	}
	y = x->parent;
	while (y != nullptr && x == y->right) {
		x = y;
		y = y->parent;
	}
	return y;
}

node* bin_tree::prev(node* x)
{
	node* y;
	if (x->left != nullptr) {
		y = max(x->left);
		return y;
	}
	y = x->parent;
	while (y != nullptr && x == y->left) {
		x = y;
		y = y->parent;
	}
	return y;
}

node* bin_tree::find(node* x, int data)
{
	if (x == nullptr || data == x->data)
		return x;
	if (data < x->data) {
		find(x->left, data);
	}
	else {
		find(x->right, data);
	}
}

void bin_tree::del(node* x)
{
	node* p = x->parent;
	if (x->left == nullptr && x->right == nullptr) {
		if (p->left == x)
			p->left = nullptr;
		else
			p->right = nullptr;
		delete x;
	}
	else if (x->left == nullptr || x->right == nullptr) {
		if (x->left == nullptr) {
			if (p->left == x)
				p->left = x->right;
			else
				p->right = x->right;
			x->right->parent = p;
		}
		else {
			if (p->left == x)
				p->left = x->left;
			else
				p->right = x->left;
			x->left->parent = p;
		}
		delete x;
	}
	else {
		node* mnext = next(x);
		x->data = mnext->data;
		if (mnext->parent->left == mnext) {
			mnext->parent->left = mnext->right;
			if (mnext->right != nullptr)
				mnext->right->parent = mnext->parent;
		}
		else {
			mnext->parent->right = mnext->right;
			if (mnext->right != nullptr)
				mnext->right->parent = mnext->parent;
		}
		delete mnext;
	}
}

int bin_tree::find_next(node* x, int data, int delta, int closest)
{
	if (x == nullptr)
		return closest;
	if (data < x->data) {
		if (x->data - data < delta) {
			delta = x->data - data;
			closest = x->data;
		}
		find_next(x->left, data, delta, closest);
	}
	else {
		find_next(x->right, data, delta, closest);
	}
}

int bin_tree::find_prev(node* x, int data, int delta, int closest)
{
	if (x == nullptr)
		return closest;
	if (data < x->data) {
		find_prev(x->left, data, delta, closest);
	}
	else {
		if (data - x->data < delta) {
			delta = data - x->data;
			closest = x->data;
		}
		find_prev(x->right, data, delta, closest);
	}
}
