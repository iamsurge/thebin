#pragma once
#include <vector>
#include <iostream>
using std::vector, std::cout, std::endl;
namespace mtx {
	class BoolMat {
	public:
		vector<vector<bool>>matrix;
		BoolMat(int r, int c) {
			matrix.resize(r);
			for (int i = 0; i < r; i++)
				for (int j = 0; j < c; j++)
					matrix[i].push_back(false);
		}
		void print() {
			for (int i = 0; i < matrix.size(); i++) {
				for (int j = 0; j < matrix[0].size(); j++)
					cout << matrix[i][j] << " ";
				cout << endl;
			}
		}
		vector<bool>& operator[](int i) {
			return matrix[i];
		}
		BoolMat& operator = (BoolMat m) {
			for (int i = 0; i < matrix.size(); i++)
				for (int j = 0; j < matrix[0].size(); j++)
					matrix[i][j] = m[i][j];
			return *this;
		}
	};
	BoolMat operator * (BoolMat m1, BoolMat m2) {
		if (m1.matrix[0].size() != m2.matrix.size()) {
			cout << "Matrixes are not consistent" << endl;
			return m1;
		}
		BoolMat temp(m1.matrix.size(), m2.matrix[0].size());
		for (int i = 0; i < m1.matrix.size(); i++) {
			for (int j = 0; j < m2.matrix[0].size(); j++) {
				for (int k = 0; k < m2.matrix.size(); k++) {
					temp.matrix[i][j] = temp.matrix[i][j] || (m1.matrix[i][k] && m2.matrix[k][j]);
				}
			}
		}
		return temp;
	}
	BoolMat operator + (BoolMat m1, BoolMat m2) {
		if ((m1.matrix.size() != m2.matrix.size()) && (m1.matrix[0].size() != m2.matrix[0].size())) {
			cout << "Wrong size of matrixes" << endl;
			return m1;
		}
		BoolMat temp(m1.matrix.size(), m1.matrix[0].size());
		for (int i = 0; i < m1.matrix.size(); i++) {
			for (int j = 0; j < m1.matrix[0].size(); j++) {
				temp.matrix[i][j] = m1.matrix[i][j] + m2.matrix[i][j];
			}
		}
		return temp;
	}
	bool operator == (BoolMat m1, BoolMat m2) {
		if (m1.matrix.size() != m2.matrix.size() || m1.matrix[0].size() != m2.matrix[0].size())
			return false;
		for (int i = 0; i < m1.matrix.size(); i++)
			for (int j = 0; j < m1.matrix[0].size(); j++)
				if (m1[i][j] != m2[i][j])
					return false;
		return true;
	}

}