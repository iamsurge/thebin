import numpy as np


BANNER = """
--------------------------------------------
== For matrix shape, the input should be
either the no. of columns/rows because we're
about to work with a square matrix anyway

== For input matrix, the format should be:

"row ; row ; ... ; row"

where elements in each row are separated
by spaces " " and rows are separated by
semicolon " ; ". These elements are the
coefficients in your equation.

* Example (a 3x3 matrix):
1 2 3 ; 4 5 6 ; 7 8 9

== The dimension of the input in Constants
should be S x 1, where S = matrix shape.

* Example (for a 3x3 matrix):
16 ; 26 ; 43
--------------------------------------------
"""


def is_diag_dominant(M: list[list[int]]) -> bool:
    """
    Check if the matrix M is diagonally dominant by checking
    if the |diagonal element| >= sum of absolute value of other elements
    """
    for i in range(len(M)):
        if sum([abs(n) for n in M[i][:i]] + [abs(n) for n in M[i][i+1:]]) >= M[i][i]:
            return False
    return True


def get_matrix(matrix_size: int) -> list[list[int]]:
    while True:
        matrix_input = input("Input matrix: ")
        matrix = np.matrix(matrix_input)
        if matrix.size == matrix_size**2:
            break
    return matrix

def get_constants(matrix_size: int) -> list[list[int]]:
    while True:
        consts = input("Constants: ")
        consts = np.matrix(consts)
        if consts.size == matrix_size:
            break
    return consts


def main() -> None:
    print(BANNER)
    
    matrix_size = int(input("Matrix shape: "))

    A = get_matrix(matrix_size)
    print(f"A = {A}")
    
    b = get_constants(matrix_size)
    print(f"B = {b}")

    D = np.diag(np.diag(A))     # Get diagonal elements of A
    D_inv = np.linalg.inv(D)    # Inverse matrix of D
    
    # Initial values for x
    x = np.matrix([[2] for _ in range(matrix_size)])

    tol = 1e-10   # Tolerance
    e = 1         # Initial error

    while e > tol:
        dx = D_inv * (b - A*x)
        new_x = x + dx

        e = max(map(max, abs(dx/x)))

        x = new_x

    print(x)

if __name__ == "__main__":
    main()