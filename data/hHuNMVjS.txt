#include <iostream>
#include <string>
#include <set>
#include <ctime>

class node {
public:
	int data;
	node* left;
	node* right;
	node* parent;
	node(int data = 0, node* left = nullptr, node* right = nullptr, node* parent = nullptr) {
		this->data = data;
		this->left = left;
		this->right = right;
		this->parent = parent;
	}
	~node() {}
};

class bin_tree {
public:
	node* root;
	bin_tree() {
		root = new node();
	}
	void insert(node* x, int data);
	node* find(node* x, int data);
	node* next(int x);
	node* prev(int x);
	void del(node* x);
	node* min(node* x);
	node* max(node* x);
};

int main() {
	std::string s;
	srand(time(0));
	bin_tree tree;
	int n;
	std::set <int> test_set;
	for(int i = 0; i )
	while (std::cin >> s >> n) {
		if (s[0] == 'i') {
			if (tree.root->left == nullptr)
				tree.root->left = new node(n);
			else
				tree.insert(tree.root->left, n);
		}
		else if (s[0] == 'd') {
			node* temp = tree.find(tree.root->left, n);
			if (temp != nullptr) {
				if (temp == tree.root->left && temp->left == nullptr && temp->right == nullptr) {
					tree.root->left = nullptr;
					continue;
				}
			}
			if (temp != nullptr) {
				tree.del(temp);
			}
		}
		else if (s[0] == 'e') {
			if (tree.find(tree.root->left, n) == nullptr)
				std::cout << "false" << "\n";
			else
				std::cout << "true" << "\n";
		}
		else if (s[0] == 'n') {
			node* temp = tree.next(n);
			if (temp != nullptr)
				std::cout << temp->data << "\n";
			else
				std::cout << "none" << "\n";
		}
		else if (s[0] == 'p') {
			node* temp = tree.prev(n);
			if (temp != nullptr)
				std::cout << temp->data << "\n";
			else
				std::cout << "none" << "\n";
		}
	}
	return 0;
}

void bin_tree::insert(node* x, int data)
{
	while (x != nullptr) {
		if (data > x->data) {
			if (x->right != nullptr) {
				x = x->right;
			}
			else {
				node* z = new node(data, nullptr, nullptr, x);
				x->right = z;
				break;
			}
		}
		else if (data < x->data) {
			if (x->left != nullptr) {
				x = x->left;
			}
			else {
				node* z = new node(data, nullptr, nullptr, x);
				x->left = z;
				break;
			}
		}
	}
}

node* bin_tree::next(int x)
{
	node* cur = this->root->left;
	node* suc = nullptr;
	while (cur != nullptr) {
		if (cur->data > x) {
			suc = cur;
			cur = cur->left;
		}
		else
			cur = cur->right;
	}
	return suc;
}

node* bin_tree::prev(int x)
{
	node* cur = this->root->left;
	node* suc = nullptr;
	while (cur != nullptr) {
		if (cur->data < x) {
			suc = cur;
			cur = cur->right;
		}
		else {
			cur = cur->left;
		}
	}
	return suc;
}

node* bin_tree::find(node* x, int data)
{
	if (x == nullptr || data == x->data)
		return x;
	if (data < x->data)
		find(x->left, data);
	else 
		find(x->right, data);
}

node* bin_tree::min(node* x)
{
	if (x->left == nullptr)
		return x;
	return min(x->left);
}

node* bin_tree::max(node* x)
{
	if (x->right == nullptr)
		return x;
	return max(x->right);
}

void bin_tree::del(node* x)
{
	node* p = x->parent;
	if (x->left == nullptr && x->right == nullptr) {
		if (p->left == x)
			p->left = nullptr;
		else
			p->right = nullptr;
		delete x;
	}
	else if (x->left == nullptr || x->right == nullptr) {
		if (x->left == nullptr) {
			if (p != nullptr && p->left == x) {
				p->left = x->right;
				x->right->parent = p;
			}
			else if (p != nullptr && p->right == x) {
				p->right = x->right;
				x->right->parent = p;
			}
			else if (p == nullptr) {
				this->root->left = x->right;
				x->right->parent = p;
			}
		}
		else if(x->right == nullptr) {
			if (p != nullptr && p->left == x) {
				p->left = x->left;
				x->left->parent = p;
			}
			else if (p != nullptr && p->right == x) {
				p->right = x->left;
				x->left->parent = p;
			}
			else if (p == nullptr) {
				this->root->left = x->left;
				x->left->parent = p;
			}
		}
		delete x;
	}
	else {
		node* mnext = next(x->data);
		x->data = mnext->data;
		if (mnext->parent->left == mnext) {
			mnext->parent->left = mnext->right;
			if (mnext->right != nullptr)
				mnext->right->parent = mnext->parent;
		}
		else {
			mnext->parent->right = mnext->right;
			if (mnext->right != nullptr)
				mnext->right->parent = mnext->parent;
		}
		delete mnext;
	}
}
