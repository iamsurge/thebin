CanvasRenderingContext2D.prototype.frac = function(num, den, x, y) {
	this.lineWidth = 1;
	this.fillStyle = "black";
	if (!num || !(num % den))
		this.fillText((num / den).toString(), x * 10 - 2, y - 13);
	else {
		if (den == 10)
			this.fillText((num / den).toString(), x * 10 - 2, y - 13);
		else {
			let obdel = num.nod(den);
			num /= obdel;
			den /= obdel;
			if (num > 9)
				this.fillText(num.toString(), x * 10 - 2, y - 28);
			else
				this.fillText(num.toString(), x * 10, y - 28);

			if (den > 9)
				this.fillText(den.toString(), x * 10 - 2, y - 14);
			else
				this.fillText(den.toString(), x * 10, y - 14);

			this.drawLine(x * 10 - 2, y - 25, x * 10 + 10, y - 25);
		}
	}
};

(function() {
	retryWhileError(function() { //retryWhileUndefined retryWhileError
		'use strict';
		NAinfo.requireApiVersion(0, 2);

		function getFraction(decimal) {
			for (var denominator = 1;
				(decimal * denominator) % 1 !== 0; denominator++)
				if (denominator > 100000)
					break;
			return [decimal * denominator, denominator];
		}

		let number = sl(3, 10);
		let startPoint = 0;
		let points = [];
		let fracPoints = [];
		let pointsViewFrac = [];
		var randomDeviation, realPoint = [];
		let segment = (43 / number).ceil();
		let step = 1 / number;

		function filter() {

			if (realPoint[realPoint.length - 1] < 0 || realPoint[realPoint.length - 1] > 1)
				return false;
			if (realPoint.length != 1)
				for (let i = 0; i < realPoint.length - 1; i++)
					if ((realPoint[i] - realPoint[realPoint.length - 1]).abs() <= step / 2)
						return false;
			return true;
		};
		for (let i = 0; i < 4; i++) {
			do {
				points[i] = sl(startPoint, startPoint + (number - 1) * step, step);
				randomDeviation = sl(1 / (sl(3, 100)), step.pow(2) * ((sl(3, number.pow(2) - 1))), 1 / (sl(3, 100)));
				realPoint[i] = points[i] + randomDeviation;
				fracPoints.pushIf(realPoint[i], filter());
			} while (fracPoints.length != i + 1);

			pointsViewFrac[i] = [(realPoint[i] + step) * number * segment, 0];
		}

		let letters = [];
		let allAnswers = [];
		do {
			let w = slLetter(letters).toZagl();
			letters.pushIf(w, !letters.includes(w));
		} while (letters.length != 4);
		for (let i = 0; i < 4; i++)
			allAnswers.push('$' + letters[i] + '$');
		let numberOfAnsw = sl(0, 3);
		let answ = allAnswers[numberOfAnsw];
		allAnswers.splice(numberOfAnsw, 1);
		let wrAns = allAnswers;
		let simpleFrac = getFraction(realPoint[numberOfAnsw]);
		genAssert(simpleFrac[0] < 1000, 'слишком кривая дробь');
		genAssert(simpleFrac[0] != simpleFrac[1], 'нельзя спрашивать единицу');
		let frac = (simpleFrac[0]).texfrac(simpleFrac[1]);

		let paint1 = function(ct) {
			//стрелочка
			ct.translate(50, 75);
			ct.drawArrow(-20, 0, 520, 0);
			ct.scale(10, -10);
			ct.lineWidth = 0.1;

			//отрезки
			for (let i = 0; i < segment * (number + 1); i += segment)
				ct.drawLine(i, -1, i, 1);
			ct.translate(-segment, 0);

			//отмеченные точки
			ct.fillStyle = ["6600ff", "#006699", "#009900", "#800000"].iz();
			for (let i = 0; i < 4; i++)
				ct.fillKrug(pointsViewFrac[i][0], pointsViewFrac[i][1], 0.4);
			//буква на искомой точке
			ct.fillStyle = ["6600ff", "#006699", "#009900", "#800000"].iz();
			ct.font = "14px liberation_sans";
			ct.scale(1 / 10, -1 / 10);
			for (let i = 0; i < 4; i++)
				ct.fillText(letters[i], pointsViewFrac[i][0] * 10, 1.7 * 10);
			//цифры отрезках
			let c = 0;
			ct.font = "12px liberation_sans";
			ct.fillStyle = "black";
			for (let i = segment; i <= segment * (number + 1); i += segment) {
				ct.frac(c, number, i, 0);
				c++;
			}

		};
		NAtask.setTask({
			text: 'Какое из чисел отмечено на координатной прямой точкой $' + frac + '$? ' +
				'В ответе укажите номер правильного варианта.',
			answers: answ,
			wrongAnswers: wrAns,
		});

		chas2.task.modifiers.addCanvasIllustration({
			width: 600,
			height: 150,
			paint: paint1,
			belowText: true,
		});
		AtoB(3);
	});
})();
//311380 
//SugarHedgehog
