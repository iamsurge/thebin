// bpmi218-7
// docaraos22_   



.global supersum
supersum:
    push %edx 
    push %eax
    push %ecx
    push %ebx
    push %esi // тут будем хранить размер меньшего числа , изначально размер А
    push %edi // размер В
    cmp $0, %esi
    je check_next
    jne ok_do_it
check_next:
    cmp $0, %edi
    je end_0
ok_do_it:
    movl $0, %edx
    jmp take_min

take_min:
    cmp %esi, %edi // определяем какое из слов короче
    jg A_shorter
    movl %edi, %esi
    movl $0, %edi
    jmp sum_1
A_shorter:
    movl $0, %edi
    jmp sum_1

sum_1:
    movl $0, %edx
    cmp %edi, %esi
    je finish_him
    
next:
    movb %dl, (%ecx, %edi, 1)
    cmp %edi, %esi
    je finish_him // дозаписываем число до конца
    movb $0, (%ecx, %edi, 1)
    addb (%eax, %edi, 1), %dl // положили бит из а
    addl (%ebx, %edi, 1), %edx // положили бит из б
    addb %dl, (%ecx, %edi, 1) // все вместе положили в с
    movb $0, %dl
    incl %edi
    cmpb $0, %dh
    je sum_1

    movl $0, %edx
    movl $1, %edx
    jmp next

finish_him:
    pop %edi
    cmp %edi, %esi
    jne B_bigger
    je A_bigger

B_bigger:
    pop %esi
    push %edi
    push %esi
    cmp %esi, %edi
    jle fin1
    jg write_B
write_B:
    cmp %esi, %edi
    jle fin1
write_B_2:
    cmp %esi, %edi
    jle fin1
    movb $0, (%ecx, %esi, 1)
    addb (%ebx, %esi, 1), %dl
    addb %dl, (%ecx, %esi, 1)
    movb $0, %dl
    incl %esi
    cmp $0, %edx
    jz write_B
    movl $1, %edx
    jmp write_B_2

A_bigger:
    pop %esi
    push %edi
    cmp %edi, %esi
    jle fin2
    jg write_A
write_A:
    cmp %edi, %esi
    jle fin2
write_A_2:
    cmp %edi, %esi
    jle fin2
    movb $0, (%ecx, %edi, 1)
    addb (%eax, %edi, 1), %dl
    addb %dl, (%ecx, %edi, 1)
    movb $0, %dl
    incl %edi

    cmp $0, %edx
    jz write_A
    movl $1, %edx
    jmp write_A_2

fin1:
    movl %esi, %eax
    pop %esi
    cmp $0, %edx 
    jnz add_1
    jz and_then

fin2:
    movl %edi, %eax
    cmp $0, %edx 
    jnz add_1
    jz and_then

add_1:
    incl %eax
    addb $1, (%ecx, %eax, 1)
    jmp and_then
and_then:
    pop %edi
    jmp fin

fin:
    pop %ebx
    pop %ecx
    movl %eax, %edx
    pop %eax
    movl %edx, %eax
    pop %edx
    jmp check_c

check_c:
    cmp $0, %eax
    je end_0
    decl %eax
    cmpb $0, (%ecx, %eax, 1)
    jne end
    je check_c
end:
    incl %eax
    jmp finally
end_0:
    movl $0, %eax
finally:
    ret