// This is a header file built in to GCC that includes everything. Fewer than including stack and iostream.
# include <bits/stdc++.h>
 
/*
 * This is a macro for checking if the given character is one of the delimiters. C minus its own ASCII code = 0.
 * All chars are secretly ints. I'll explain the "a" parameter later. Saves 7 characters.
 * ( = 40, [ = 91, { = 123
 * */
# define  d(a) if (!(a c-40 && a c-91 && c-123))
 
// Macro for a duplicated ternary expression to add "not" to the output if needed. Saves 2 characters.
# define  n    ?"not ":"") <<
 
// I use .size() a lot so I made it a macro. Saves 9 characters.
# define  z    .size()
 
// Function return type changed to int because bools are secretly ints.
int BalancedDelimiters(std::string & s) {
    std::stack<int> q;
    // Initialize x to the size of the string, so we know how much we have left to scan.
    int x = s z;
    // Loop over characters in the string. Except int since chars are secretly ints.
    for (int c : s) {
        // Decrement x
        x--;
        // (from macro) If the delimiter is an open delimiter, push it to the stack.
        // The "a" parameter is blank, so ignore it in the above expression.
        d(  ) q.push(c);
 
        /*
         * However, since "a" is set to -- here, replace a with -- in the expression. The ASCII code for ) is 41, one
         * more than (. So right before checking the subtraction, decrement c so we can reuse the same number for
         * checking the character. But for [ and {, the corresponding close delimiters are two more. So after we check
         * for ), we can just decrement c once again. That's the use of the second "a" in the expression.
         * */
        d(--) {if ((!q z && ++x) || q.top()-c) break; q.pop();}
        /*
         * After that, it's short-circuit time! Short-circuiting is when a language skips evaluating the second part of
         * a boolean expression because it already knows the answer logically. In this case, if you have an OR
         * statement, and the first part is true, then there is no need to check the right side. For AND, it is similar
         * if the first part is false.
         * */
 
        /*
         * (!q z && ++x)
         * This increments x only if (!q z). In other words, if the stack is empty, increment x. Needed for handling
         *      when we haven't finished scanning the string. Over all, the expression says if the stack is NOT empty.
         * If that is true, then it skips the next part after the || because there is no need to check. Then it breaks.
         * If it is false, it goes on to check (q.top()-c). This checks if the top of the stack is NOT the corresponding
         *      delimiter. If it's not, then break.
         * If we haven't broken at this point, it moves on to the next statement in the block, which pops the correct
         *      character from the top of the stack.
         * */
    }
 
    // Print the output with "not". If q.size(), the stack is "not" empty. If x, scanning of string is "not" completed.
    std::cout << "Stack is " << (q z n "empty and the scanning of input string is " << (x n "completed.\n";
 
    // Return the bitwise AND of the negations of the above. True if the stack is empty AND scanning is complete.
    // This is the first time I've used CS241. Also, it's bitwise because it saves a character from &&.
    return !q z & !x;
}