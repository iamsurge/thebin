csrand_init:
; ix = selected byte
; de = current deviation
; hl = starting address
; inputs: a = samples / 4, (A=0 is 256, 256*4 is 1024)
; outputs: hl = address
    ld (_smc_samples), a
    push ix
        ld ix, 0
        ld de, _max_deviation
        ld hl, $D65800
        ld bc,513
.test_range_loop:
        push bc
            call _test_byte
        pop bc
        cpi
        jp pe,.test_range_loop

        lea hl, ix+0
        ld (_sprng_read_addr), hl

        xor a, a
        sbc hl, bc  ; subtract 0 to set the z flag if HL is 0
    pop ix
    ret z
    inc a
    ret

_test_byte:
; inputs: hl = byte
; inputs: de = minimum deviance
; inputs: ix = pointer to the byte with minimum deviance
; outputs: de is the new minimum deviance (if updated)
; outputs: ix updated to hl if this byte contains the bit with lowest deviance
; outputs: b = 0
; outputs: a = 0x86
; destroys: f
; modifies: a, b, de, ix
    ld a,0x46 ; second half of the `bit 0,(hl)` command
.test_byte_bitloop:
    push hl
        push de
            call _test_bit  ; HL = deviance (|desired - actual|)
        pop de

        add a,8       ; never overflows, so resets carry
        sbc hl, de    ; check if HL is smaller than DE

        jq nc, .skip_next_bit          ; HL >= DE
        add hl,de
        ex de,hl
        pop ix
        push ix
.skip_next_bit:
    pop hl
    cp 0x86
    jq nz, .test_byte_bitloop
    ret

_test_bit:
; inputs: a = second byte of CB**
; inputs: hl = byte
; outputs: hl = hit count
; destroys: af, bc, de, hl

_smc_samples:=$+1
    ld b,0
    ld (.smc1),a
    ld (.smc2),a
    ld (.smc3),a
    ld (.smc4),a
    ld de,0
.loop:
    bit 0,(hl)
.smc1:=$-1
    jq z,.next1
    inc de
.next1:
    bit 0,(hl)
.smc2:=$-1
    jq nz,.next2    ; notice the inverted logic !
    dec de          ; and the dec instead of inc !
.next2:
    bit 0,(hl)
.smc3:=$-1
    jq z, .next3
    inc de
.next3:
    bit 0,(hl)
.smc4:=$-1
    jq nz,.next4    ; notice the inverted logic !
    dec de          ; and the dec instead of inc !
.next4:
    djnz .loop

    ; return |DE|
    or a,a
    sbc hl,hl
    sbc hl,de
    ret nc
    ex de,hl
    ret
