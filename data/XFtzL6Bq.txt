#ifndef UNTITLED_HASH_TABLE_H
#define UNTITLED_HASH_TABLE_H

#include <utility>
#include <optional>

template<class TKey, class TValue>
class node {
    enum state {
        uninitialized, filled, removed
    };

private:
    TKey key_;
    TValue value_;
    size_t hash_;
    char state_;

public:
    node()
            : key_(),
              value_(),
              hash_(0),
              state_(uninitialized) {}

    node(const node &other)
            : key_(other.key),
              value_(other.value),
              hash_(other.hash),
              state_(other.state_) {}

    node(node &&other) noexcept
            : key_(std::move(other.key)),
              value_(std::move(other.value)),
              hash_(other.hash),
              state_(other.state_) {}

    ~node() = default;

    node &operator=(const node &other) {
        key_ = other.key_;
        value_ = other.value_;
        hash_ = other.hash_;
        state_ = other.state_;
        return *this;
    }

    node &operator=(node &&other) noexcept {
        key_ = std::move(other.key_);
        value_ = std::move(other.value_);
        hash_ = other.hash_;
        state_ = other.state_;
        return *this;
    }

    char get_state() const {
        return state_;
    }

    const TKey &get_key() const {
        return key_;
    }

    TKey &get_key() {
        return key_;
    }

    const TValue &get_value() const {
        return value_;
    }

    TValue &get_value() {
        return value_;
    }

    size_t get_hash() const {
        return hash_;
    }

    void set_data(const TKey &key, const TValue &value, size_t hash) {
        key_ = key;
        value_ = value;
        hash_ = hash;
        state_ = filled;
    }

    void clear() {
        state_ = removed;
    }
};

template<class TKey,
        class TValue,
        class KeyHash = std::hash<TKey>,
        class KeyEq = std::equal_to<TKey>>
class hash_table {
private:
    enum state {
        uninitialized, filled, removed
    };

    node<TKey, TValue> *nodes_{nullptr};
    size_t capacity_{0};
    size_t size_{0};
    KeyHash hasher_{};
    KeyEq key_equal_{};

private:
    size_t find_index(const TKey &key) const {
        if (nodes_ != nullptr) {
            size_t hash = hasher_(key);
            size_t index = hash % capacity_;
            for (size_t i = index; i < capacity_; ++i) {
                if (nodes_[i].get_state() == uninitialized) {
                    break;
                }
                if (nodes_[i].get_state() == filled
                    && hash == nodes_[i].get_hash()
                    && key_equal_(key, nodes_[i].get_key())) {
                    return i;
                }
            }
        }
        return capacity_;
    }

public:
    hash_table() = default;

    explicit hash_table(size_t capacity)
            : capacity_(capacity) {
        nodes_ = new node<TKey, TValue>[capacity_];
    }

    hash_table(const hash_table &other)
            : capacity_(other.capacity_),
              size_(other.size_),
              hasher_(other.hasher_),
              key_equal_(other.key_equal_) {
        nodes_ = new node<TKey, TValue>[capacity_];
        for (size_t i = 0; i < capacity_; ++i) {
            nodes_[i] = other.nodes_[i];
        }
    }

    hash_table(hash_table &&other) noexcept
            : capacity_(other.capacity_),
              size_(other.size_),
              hasher_(std::move(other.hasher_)),
              key_equal_(std::move(other.key_equal_)) {
        nodes_ = new node<TKey, TValue>[capacity_];
        for (size_t i = 0; i < capacity_; ++i) {
            nodes_[i] = std::move(other.nodes_[i]);
        }
    }

    ~hash_table() {
        delete[] nodes_;
    }

    hash_table &operator=(const hash_table &other) {
        if (this == &other) {
            return *this;
        }
        delete[] nodes_;
        capacity_ = other.capacity_;
        size_ = other.size_;
        hasher_ = other.hasher_;
        key_equal_ = other.key_equal_;
        nodes_ = new node<TKey, TValue>[capacity_];
        for (size_t i = 0; i < capacity_; ++i) {
            nodes_[i] = other.nodes_[i];
        }
        return *this;
    }

    hash_table &operator=(hash_table &&other) noexcept {
        if (this == &other) {
            return *this;
        }
        capacity_ = other.capacity_;
        size_ = other.size_;
        hasher_ = std::move(other.hasher_);
        key_equal_ = std::move(other.key_equal_);
        nodes_ = other.nodes_;
        other.nodes_ = nullptr;
        return *this;
    }

    void rehash(size_t new_capacity) {
        if (new_capacity < capacity_) {
            return;
        }
        hash_table new_table(new_capacity);
        for (size_t i = 0; i < capacity_; ++i) {
            if (nodes_[i].get_state() == filled) {
                new_table.insert(nodes_[i].get_key(), nodes_[i].get_value());
            }
        }
        swap(new_table);
    }

    void insert(const TKey &key, const TValue &value) {
        if (nodes_ == nullptr) {
            rehash(1);
        }
        if (size_ << 1 > capacity_) {
            rehash(capacity_ << 1);
        }
        size_t index = find_index(key);

        if (index == capacity_) {
            size_t hash = hasher_(key);
            index = hash % capacity_;
            for (size_t i = index; i < capacity_; ++i) {
                if (nodes_[i].get_state() == uninitialized
                    || nodes_[i].get_state() == removed) {
                    nodes_[i].set_data(key, value, hash);
                }
            }
        } else {
            nodes_[index].set_data(key, value, nodes_[index].get_hash());
        }
    }

    void erase(const TKey &key) {
        if (nodes_ == nullptr) {
            return;
        }
        size_t index = find_index(key);
        if (index != capacity_) {
            nodes_[index].clear();
            size_--;
        }
    }

    std::optional<std::reference_wrapper<TValue>> find(const TKey &key) const {
        if (nodes_ == nullptr) {
            return std::nullopt;
        }
        size_t index = find_index(key);
        if (index != capacity_) {
            return std::optional<std::reference_wrapper<TValue>>{nodes_[index].get_value()};
        }
        return std::nullopt;
    }

    void swap(hash_table &other) {
        std::swap(nodes_, other.nodes_);
        std::swap(key_equal_, other.key_equal_);
        std::swap(hasher_, other.hasher_);
        std::swap(capacity_, other.capacity_);
        std::swap(size_, other.size_);
    }

    void clear() {
        delete[] nodes_;
        nodes_ = nullptr;
        size_ = 0;
        capacity_ = 0;
    }

    size_t size() const {
        return size_;
    }

    bool empty() const {
        return size_ == 0;
    }
};

#endif //UNTITLED_HASH_TABLE_H
