#include <iostream>
#include <queue>
#include <cstring>
#include <vector>


using namespace std;
struct node{
int idx;
int cost;
int distance;
int ostanata;
node(){

}
node(int idx2, int cost2, int distance2, int ostanato2){
idx=idx2;
cost=cost2;
ostanata=ostanato2;
distance=distance2;
}
bool operator < (const node &tmp)const{
return cost > tmp.cost;
}
};
int main()
{

    int n, m, x, k, l;
    cin>>n>>x>>k>>l>>m;

    vector<pair<int, int>>graph[n+5];



    for(int i=0; i<m; i++){
    int a, b, c;
    cin>>a>>b>>c;
    graph[a].push_back(make_pair(b, c));
        graph[b].push_back(make_pair(a, c));

    }

    int distance[n + 5][k + 5][l + 5];

    for(int i=0; i<=n; i++){
     for(int j=0; j<=k; j++){
        for(int z=0; z<=l; z++){
        distance[i][j][z]=2e9;
      }
     }
    }
    priority_queue<node>p;
    p.push(node(1, 0, l, k));
    while(!p.empty()){
        node c=p.top();
        p.pop();

        int nova_distanca=c.distance;
        if(c.idx<=x and c.distance > 0){
            nova_distanca=0;
        }
        if(nova_distanca>0){
        for(int i=0; i<graph[c.idx].size(); i++){
            int sosed=graph[c.idx][i].first;
                int weight=graph[c.idx][i].second;
                    if(nova_distanca-weight>=0 and c.cost<distance[sosed][c.ostanata][nova_distanca-weight]){
                        distance[sosed][c.ostanata][nova_distanca-weight]=c.cost;
                            p.push(node(sosed, c.cost, nova_distanca-weight, c.ostanata));
                }
            }
            nova_distanca = 0;
        }
        for(int j=0; j<graph[c.idx].size(); j++){
            int sosed_=graph[c.idx][j].first;
                int weight_=graph[c.idx][j].second;
                    if(c.cost+weight_ < distance[sosed_][c.ostanata][nova_distanca]){
                        distance[sosed_][c.ostanata][nova_distanca]=c.cost + weight_;
                            p.push(node(sosed_, c.cost+weight_, nova_distanca, c.ostanata));
                    }
                }
                if(c.ostanata>0){
                    c.ostanata--;
                      nova_distanca=l;
                      for(int i=0; i<graph[c.idx].size(); i++){
                        int _sosed=graph[c.idx][i].first;
                         int _weight=graph[c.idx][i].second;
                          if(nova_distanca-_weight>=0 and c.cost<distance[_sosed][c.ostanata][nova_distanca-_weight]){
                            distance[_sosed][c.ostanata][nova_distanca-_weight]=c.cost;
                             p.push(node(_sosed, c.cost, nova_distanca-_weight, c.ostanata));
                       }
                      }
                     }
                    }
                int resultat=2e9;
                for(int i=0; i<=k; i++){
                    for(int j=0; j<=l; j++){
                        resultat=min(resultat, distance[n][i][j]);
                    }
                   }
                cout<<resultat;
    return 0;
}
