local SHADER_HELPER = [===[
	//
	// mta-helper.fx
	//
	// File version: 0.0.1
	// Date updated: 2011-09-26
	//
	// Big file of doom containg most of the stuff you need to get shaders working with MTA
	//


	//
	// This file has 4 sections:
	//      1. Variables
	//      2. Renders states (parital - includes only those that are used the most)
	//      3. Helper functions
	//      4. Normal generation
	//



	//####################################################################################################################
	//####################################################################################################################
	//
	// Section #1 : Variables
	//
	//####################################################################################################################
	//####################################################################################################################

	//---------------------------------------------------------------------
	// These parameters are set by MTA whenever a shader is drawn
	//---------------------------------------------------------------------

	//
	// Matrices
	//
	float4x4 gWorld : WORLD;
	float4x4 gView : VIEW;
	float4x4 gProjection : PROJECTION;
	float4x4 gWorldView : WORLDVIEW;
	float4x4 gWorldViewProjection : WORLDVIEWPROJECTION;
	float4x4 gViewProjection : VIEWPROJECTION;
	float4x4 gViewInverse : VIEWINVERSE;
	float4x4 gWorldInverseTranspose : WORLDINVERSETRANSPOSE;
	float4x4 gViewInverseTranspose : VIEWINVERSETRANSPOSE;

	//
	// Camera
	//
	float3 gCameraPosition : CAMERAPOSITION;
	float3 gCameraDirection : CAMERADIRECTION;

	//
	// Seconds counter
	//
	float gTime : TIME;

	//
	// Strongest light influence
	//
	float4 gLightAmbient : LIGHTAMBIENT;
	float4 gLightDiffuse : LIGHTDIFFUSE;
	float4 gLightSpecular : LIGHTSPECULAR;
	float3 gLightDirection : LIGHTDIRECTION;



	//####################################################################################################################
	//####################################################################################################################
	//
	// Section #2 : Renders states
	//
	//####################################################################################################################
	//####################################################################################################################

	//---------------------------------------------------------------------
	// The parameters below mirror the contents of the D3D registers.
	// They are only relevant when using engineApplyShaderToWorldTexture.
	//---------------------------------------------------------------------

	//------------------------------------------------------------------------------------------
	// renderState (partial) - String value should be one of D3DRENDERSTATETYPE without the D3DRS_  http://msdn.microsoft.com/en-us/library/bb172599%28v=vs.85%29.aspx
	//------------------------------------------------------------------------------------------

	int gLighting                      < string renderState="LIGHTING"; >;                        //  = 137,

	float4 gGlobalAmbient              < string renderState="AMBIENT"; >;                    //  = 139,

	int gDiffuseMaterialSource         < string renderState="DIFFUSEMATERIALSOURCE"; >;           //  = 145,
	int gSpecularMaterialSource        < string renderState="SPECULARMATERIALSOURCE"; >;          //  = 146,
	int gAmbientMaterialSource         < string renderState="AMBIENTMATERIALSOURCE"; >;           //  = 147,
	int gEmissiveMaterialSource        < string renderState="EMISSIVEMATERIALSOURCE"; >;          //  = 148,


	//------------------------------------------------------------------------------------------
	// materialState - String value should be one of the members from D3DMATERIAL9  http://msdn.microsoft.com/en-us/library/bb172571%28v=VS.85%29.aspx
	//------------------------------------------------------------------------------------------

	float4 gMaterialAmbient     < string materialState="Ambient"; >;
	float4 gMaterialDiffuse     < string materialState="Diffuse"; >;
	float4 gMaterialSpecular    < string materialState="Specular"; >;
	float4 gMaterialEmissive    < string materialState="Emissive"; >;
	float gMaterialSpecPower    < string materialState="Power"; >;


	//------------------------------------------------------------------------------------------
	// textureState (partial) - String value should be a texture number followed by 'Texture'
	//------------------------------------------------------------------------------------------

	texture gTexture0           < string textureState="0,Texture"; >;
	texture gTexture1           < string textureState="1,Texture"; >;
	texture gTexture2           < string textureState="2,Texture"; >;
	texture gTexture3           < string textureState="3,Texture"; >;


	//------------------------------------------------------------------------------------------
	// vertexDeclState  (partial)
	//------------------------------------------------------------------------------------------

	int gDeclNormal             < string vertexDeclState="Normal"; >;       // Set to 1 if vertex stream includes normals



	//####################################################################################################################
	//####################################################################################################################
	//
	// Section #3 : Helper functions
	//
	//####################################################################################################################
	//####################################################################################################################

	//------------------------------------------------------------------------------------------
	// MTAUnlerp
	// - Find a the relative position between 2 values
	//------------------------------------------------------------------------------------------
	float MTAUnlerp( float from, float to, float pos )
	{
		if ( from == to )
			return 1.0;
		else
			return ( pos - from ) / ( to - from );
	}


	//------------------------------------------------------------------------------------------
	// MTACalcScreenPosition
	// - Transform vertex position for the camera
	//------------------------------------------------------------------------------------------
	float4 MTACalcScreenPosition( float3 InPosition )
	{
		float4 posWorld = mul(float4(InPosition,1), gWorld);
		float4 posWorldView = mul(posWorld, gView);
		return mul(posWorldView, gProjection);
	}

	//------------------------------------------------------------------------------------------
	// MTACalcWorldPosition
	// - Transform position by current world matix
	//------------------------------------------------------------------------------------------
	float3 MTACalcWorldPosition( float3 InPosition )
	{
		return mul(float4(InPosition,1), gWorld).xyz;
	}

	//------------------------------------------------------------------------------------------
	// MTACalcWorldNormal
	// - Rotate normal by current world matix
	//------------------------------------------------------------------------------------------
	float3 MTACalcWorldNormal( float3 InNormal )
	{
		return mul(InNormal, (float3x3)gWorld);
	}

	//------------------------------------------------------------------------------------------
	// MTACalcGTABuildingDiffuse
	// - Calculate GTA lighting for buildings
	//------------------------------------------------------------------------------------------
	float4 MTACalcGTABuildingDiffuse( float4 InDiffuse )
	{
		float4 OutDiffuse;

		if ( !gLighting )
		{
			// If lighting render state is off, pass through the vertex color
			OutDiffuse = InDiffuse;
		}
		else
		{
			// If lighting render state is on, calculate diffuse color by doing what D3D usually does
			float4 ambient  = gAmbientMaterialSource  == 0 ? gMaterialAmbient  : InDiffuse;
			float4 diffuse  = gDiffuseMaterialSource  == 0 ? gMaterialDiffuse  : InDiffuse;
			float4 emissive = gEmissiveMaterialSource == 0 ? gMaterialEmissive : InDiffuse;
			OutDiffuse = gGlobalAmbient * saturate( ambient + emissive );
			OutDiffuse.a *= diffuse.a;
		}
		return OutDiffuse;
	}

	//------------------------------------------------------------------------------------------
	// MTACalcGTAVehicleDiffuse
	// - Calculate GTA lighting for vehicles
	//------------------------------------------------------------------------------------------
	float4 MTACalcGTAVehicleDiffuse( float3 WorldNormal, float4 InDiffuse )
	{
		// Calculate diffuse color by doing what D3D usually does
		float4 ambient  = gAmbientMaterialSource  == 0 ? gMaterialAmbient  : InDiffuse;
		float4 diffuse  = gDiffuseMaterialSource  == 0 ? gMaterialDiffuse  : InDiffuse;
		float4 emissive = gEmissiveMaterialSource == 0 ? gMaterialEmissive : InDiffuse;

		float4 TotalAmbient = ambient * ( gGlobalAmbient + gLightAmbient );

		// Add the strongest light
		float DirectionFactor = max(0,dot(WorldNormal, -gLightDirection ));
		float4 TotalDiffuse = ( diffuse * gLightDiffuse * DirectionFactor );

		float4 OutDiffuse = saturate(TotalDiffuse + TotalAmbient + emissive);
		OutDiffuse.a *= diffuse.a;

		return OutDiffuse;
	}

	//------------------------------------------------------------------------------------------
	// MTACalculateCameraDirection
	// - Get camera direction to a world point
	//------------------------------------------------------------------------------------------
	float3 MTACalculateCameraDirection( float3 CamPos, float3 InWorldPos )
	{
		return normalize( InWorldPos - CamPos );
	}

	//------------------------------------------------------------------------------------------
	// CalcCameraDistance
	// - Get camera distance from a world point
	//------------------------------------------------------------------------------------------
	float MTACalcCameraDistance( float3 CamPos, float3 InWorldPos )
	{
		return distance( InWorldPos, CamPos );
	}

	//------------------------------------------------------------------------------------------
	// CalculateSpecular
	// - Get specular intensity
	//------------------------------------------------------------------------------------------
	float MTACalculateSpecular( float3 CamDir, float3 LightDir, float3 SurfNormal, float SpecPower )
	{
		// Using Blinn half angle modification for performance over correctness
		LightDir = normalize(LightDir);
		SurfNormal = normalize(SurfNormal);
		float3 halfAngle = normalize(-CamDir - LightDir);
		float r = dot(halfAngle, SurfNormal);
		return pow(saturate(r), SpecPower);
	}



	//####################################################################################################################
	//####################################################################################################################
	//
	// Section #4 : Normal generation
	//
	//####################################################################################################################
	//####################################################################################################################

	//
	// Declare '#define GENERATE_NORMALS' before this file is included to tell MTA to generate vertex normals if required
	//

	//---------------------------------------------------------------------
	// Flags for MTA to do something about
	//---------------------------------------------------------------------
	int CUSTOMFLAGS
	<
	#ifdef GENERATE_NORMALS
		string createNormals = "yes";           // Some models do not have normals by default. Setting this to 'yes' will add them to the VertexShaderInput as NORMAL0
	#endif
		string skipUnusedParameters = "yes";    // This will make the shader a bit faster
	>;


	//------------------------------------------------------------------------------------------
	// MTAFixUpNormal
	// - Make sure the normal is valid
	//------------------------------------------------------------------------------------------
	void MTAFixUpNormal( in out float3 OutNormal )
	{
		// Incase we have no normal inputted
		if ( OutNormal.x == 0 && OutNormal.y == 0 && OutNormal.z == 0 )
			OutNormal = float3(0,0,1);   // Default to up
	}
	
]===];

local SHADER_CODE = SHADER_HELPER .. [===[
	static float EPSILON = 1e-10;
	
	float3 RGBtoHCV(in float3 RGB)
	{
		float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0/3.0) : float4(RGB.gb, 0.0, -1.0/3.0);
		float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
		float C = Q.x - min(Q.w, Q.y);
		float H = abs((Q.w - Q.y) / (6 * C + EPSILON) + Q.z);
		return float3(H, C, Q.x);
	}

	float3 RGBtoHSV(in float3 RGB)
	{
		float3 HCV = RGBtoHCV(RGB);
		float S = HCV.y / (HCV.z + EPSILON);
		return float3(HCV.x, S, HCV.z);
	}
	
	float3 HUEtoRGB(in float H)
	{
		float R = abs(H * 6 - 3) - 1;
		float G = 2 - abs(H * 6 - 2);
		float B = 2 - abs(H * 6 - 4);
		return saturate(float3(R,G,B));
	}

	float3 HSVtoRGB(in float3 HSV)
	{
		float3 RGB = HUEtoRGB(HSV.x);
		return ((RGB - 1) * HSV.y + 1) * HSV.z;
	}
	
	float rand(float2 n)
	{
		return frac(sin(cos(dot(n, float2(12.9898,12.1414)))) * 83758.5453);
	}

	float noise(float2 n)
	{
		const float2 d = float2(0.0, 1.0);
		float2 b = floor(n), f = smoothstep((float2)(0.0), (float2)(1.0), frac(n));
		return lerp(lerp(rand(b), rand(b + d.yx), f.x), lerp(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
	}
	
	float fbm(float2 n)
	{
		float total = 0.0, amplitude = 1.0;
		for (int i = 0; i <5; i++)
		{
			total += noise(n) * amplitude;
			n += n*1.7;
			amplitude *= 0.47;
		}
		return total;
	}
	
	struct VSInput
	{
		float3 Position : POSITION0;
		float4 Diffuse : COLOR0;
		float2 TexCoord : TEXCOORD0;
	};
	
	struct PSInput
	{
		float4 Position : POSITION0;
		float2 TexCoord : TEXCOORD0;
	};
	
	PSInput VertexShaderFunction(VSInput VS)
	{
		PSInput PS = (PSInput)0;

		// Calculate screen pos of vertex
		PS.Position = MTACalcScreenPosition ( VS.Position );

		// Pass through tex coord
		PS.TexCoord = VS.TexCoord;

		return PS;
	}

	float4 PixelShaderExample( PSInput PS ) : COLOR0
	{
		const float3 c1 = float3(0.5, 0.0, 0.1);
		const float3 c2 = float3(0.9, 0.1, 0.0);
		const float3 c3 = float3(0.2, 0.1, 0.7);
		const float3 c4 = float3(1.0, 0.9, 0.1);
		const float3 c5 = (float3)(0.1);
		const float3 c6 = (float3)(0.9);
		
		float t = gTime;
		
		float2 speed = float2(1.2, 0.1);
		float shift = 1.327+sin(t*2.0)/2.4;
		float alpha = 1.0;
		
		float dist = 3.5-sin(t*0.4)/1.89;
		
		float2 p = PS.TexCoord * dist / 1;
		p.x -= t/1.1;
		
		float q = fbm(p - t * 0.01+1.0*sin(t)/10.0);
		float qb = fbm(p - t * 0.002+0.1*cos(t)/5.0);
		float q2 = fbm(p - t * 0.44 - 5.0*cos(t)/7.0) - 6.0;
		float q3 = fbm(p - t * 0.9 - 10.0*cos(t)/30.0)-4.0;
		float q4 = fbm(p - t * 2.0 - 20.0*sin(t)/20.0)+2.0;
		
		q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;
		float2 r = float2(fbm(p + q /2.0 + t * speed.x - p.x - p.y), fbm(p + q - t * speed.y));
		float3 c = lerp(c1, c2, fbm(p + r)) + lerp(c3, c4, r.x) - lerp(c5, c6, r.y);
		float3 color = (float3)(c * cos(shift * PS.TexCoord.y / 1));
		
		color += .05;
		color.r *= 2.8;
		float3 hsv = HSVtoRGB(color);
		hsv.y *= hsv.z  * 1.1;
		hsv.z *= hsv.y * 1.13;
		hsv.y = (2.2-hsv.z*.9)*1.20;
		color = HSVtoRGB(hsv);
		
		return float4( color, 1 );
	};

	technique
	{
		pass P0
		{
			VertexShader = compile vs_2_0 VertexShaderFunction();
			PixelShader = compile ps_3_0 PixelShaderExample();
		}
	}
]===];

local lShader = dxCreateShader( SHADER_CODE );

addEventHandler( "onClientRender", root, function ( )
	dxDrawImage( 0, 0, 1920, 1080, lShader );
end );