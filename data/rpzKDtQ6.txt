/*Завдання 1.
Визначити клас Вектор На Площині(Vector), що містить координати вектору (х, у).      
Визначити у класі :
	необхідні конструктор(и);
	перевизначити(override) метод ToString();
	властивість обчислення довжини вектору( √(x^2+y^2 ))

Оператори
	+ додавання двох векторів, результатом  є вектор : (x1 + x2, y1 + y2)
	- віднімання двох векторів результатом  є вектор : (x1 - x2, y1 - y2))
	* множення  вектору на скаляр(дробове число), результатом  є вектор : (x1 * num, y1 * num)
	множення  вектору на вектор(результатом  є дробове число x1*y1 + x2 * y2)
	==,  != операції порівняння двох векторів
попередньо перевизначити Equals(), GetHashCode(), використати Equals())
	приведення типів
		явне перетворення до типу double (повертати довжину  вектору)
		неявне перетворення  від типу double до типу Vector (дробове число - х координата, 0 - у координата)
	++, --  збільшувати(зменшувати) обидві координати на 1
	унарний  мінус(змінювати знак обох  координат вектору) 
	оператори true, false ( false - вектор (0;0), true - хоч одна координата не нуль)
	одновимірний індексатор, який за індексом 0 повертає х -координату, за індексом  1 - у координату 	

Перевірити роботу операцій, включно з +=, -=, *=*/



using System;

namespace dz_7
{
    class Program
    {
        static void Main(string[] args)
        {
            Vector vector1 = new Vector(3, 2);
            Vector vector2 = new Vector(4, 1);

            Console.WriteLine($"{vector1} + {vector2} = {vector1 + vector2}\n");

            Console.WriteLine($"{vector1} - {vector2} = {vector1 - vector2}\n");

            Console.WriteLine($"{vector1} * {2} = {vector1 * 2}\n");

            Console.WriteLine($"{vector1} * {vector2} = {vector1 * vector2}\n");

            Console.WriteLine($"{vector1} == {vector2} => {vector1 == vector2}\n");

            Console.WriteLine($"{vector1} == null => {vector1 == null}\n");

            Console.WriteLine($"null == {vector2} => {null == vector2}\n");

            Console.WriteLine($"Vector {vector2} length => {(double)vector2}\n");

            Console.WriteLine($"++{vector2} => {++vector2}\n");

            Console.WriteLine($"--{vector1} => {--vector1}\n");

            Console.WriteLine($"-{vector1} => {-vector1}\n");

            Console.WriteLine($"X => {vector1[0]}\t Y => {vector1[1]}");

            vector1 = (2.5, 4.5).ToTuple<double, double>();

            Console.WriteLine(vector1);

        }
    }
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace dz_7
{
    class Vector
    {
        public double X { get; set; } = 0;
        public double Y { get; set; } = 0;
        
        public Vector (double x, double y)
        {
            X = x;
            Y = y;
        }
        public Vector()
        {
            X = 0;
            Y = 0;
        }

        public static Vector operator +(Vector one, Vector two)
        {
            Vector result = new Vector()
            {
                X = one.X + two.X,
                Y = one.Y + two.Y
            };

            return result;
        }
        public static Vector operator -(Vector one, Vector two)
        {
            Vector result = new Vector()
            {
                X = one.X - two.X,
                Y = one.Y - two.Y
            };

            return result;
        }
        public static Vector operator -(Vector one)
        {
            Vector result = new Vector()
            {
                X = one.X * (-1),
                Y = one.Y * (-1)
            };

            return result;
        }
        public static Vector operator *(Vector one, double num)
        {
            Vector result = new Vector()
            {
                X = one.X * num,
                Y = one.Y * num
            };

            return result;
        }
        public static Vector operator ++(Vector one)
        {
            Vector result = new Vector()
            {
                X = one.X + 1,
                Y = one.Y + 1

            };

            return result;
        }
        public static Vector operator --(Vector one)
        {
            Vector result = new Vector()
            {
                X = one.X - 1,
                Y = one.Y - 1

            };

            return result;
        }
        public static double operator *(Vector one, Vector two)
        {
            double result = (one.X * two.X) + (one.Y * two.Y);

            return result;
        }
        public static bool operator ==(Vector one, Vector two)
        {
            if (ReferenceEquals(one, two))
            { 
                return true; 
            }
            if (one is null)
            {
                return false;
            }

            return one.Equals(two);
        }
        public static bool operator !=(Vector one, Vector two)
        {    
            return !(one == two);
        }

        public static bool operator true(Vector one)
        {
            return one.X != 0 && one.Y != 0;
        }
        public static bool operator false(Vector one)
        {
            return one.X == 0 || one.Y == 0;
        }

        public static explicit operator double(Vector one)
        {
            return (double)Math.Sqrt(Math.Pow(one.X, 2) + Math.Pow(one.Y, 2));
        }

        public static implicit operator Vector(Tuple<double, double> num)
        {
            return new Vector(num.Item1, num.Item2);
        }

        public double this[int idx]
        {
            get
            {
                switch(idx)
                {
                    case 0:
                        return X;
                    case 1:
                        return Y;
                    default:
                        throw new Exception($"Error index in get [] => must be 0 or 1");
                }
            }
        }

        public override bool Equals(object obj)
        {
            if (obj == null)
                return false;

            if (ReferenceEquals(this, obj))
                return true;

            if (obj.GetType() != this.GetType())
                return false;

            Vector other = (Vector)obj;

            return X == other.X && Y == other.Y;
        }
        public override int GetHashCode()
        {
            return HashCode.Combine(this.X, this.Y);
        }
        public override string ToString()
        {
            return $"[{X}, {Y}]";
        }
    }
}