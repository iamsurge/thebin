/// Build a graph then move round the graph.
/// 1) from start to end
/// 2) from end to closest valid start

// ignore_for_file: unused_import

import 'dart:convert';
import 'dart:math';

import 'package:collection/collection.dart';
import 'package:more/more.dart';
//import 'package:collection/collection.dart';

class Node {
  int distance;
  String name;
  int height;
  String? previous;
  Node(this.name, this.height, [this.distance = 9999999999, this.previous]);
}

class Edge {
  String from, to;
  int weight;
  Edge(this.from, this.to, this.weight);
}

typedef NFunc = Iterable<Tuple2<String, int>> Function(String v);

class Graph {
  // Use String keys for nodes and edges to make look-up easier.
  var nodes = <String, Node>{};
  var edges = <String, Edge>{};
  var connected = SetMultimap<String, String>();
  Graph();

  Node ensure(Node n) => nodes.putIfAbsent(n.name, () => n);

  // Building algo means that both directions get created separately.
  addEdge(String from, String to, int weight) {
    edges["$from/$to"] = Edge(from, to, weight);
    connected.add(from, to);
  }

  List<String> neighboursOf(String node) => connected[node].toList();

  Edge? edgeBetween(String node1, String node2) => edges["$node1/$node2"];
}

var cameFrom = <String, String>{};
Map<dynamic, int> dijkstra(Graph graph, start, end) {
  cameFrom = {start: ''};
  var costSoFar = {start: 0};
  var frontier = PriorityQueue<String>(
      (a, b) => (costSoFar[a]!).compareTo((costSoFar[b]!)));
  frontier.add(start);
  while (frontier.isNotEmpty) {
    var current = frontier.removeFirst();
    if (current == end) break;
    // could use this shortcut here if the Part 2 search takes too long
    // if (graph.nodes[current].height = 0) break;
    for (var next in graph.neighboursOf(current)) {
      var newCost =
          costSoFar[current]! + graph.edgeBetween(current, next)!.weight;
      if (!costSoFar.containsKey(next) || newCost < costSoFar[next]!) {
        costSoFar[next] = newCost;
        frontier.add(next);
        cameFrom[next] = current;
      }
    }
  }
  return costSoFar;
}

Graph buildGraph(List<String> lines) {
  var g = Graph();
  //Add the nodes.
  for (var y = 0; y < lines.length; y++) {
    for (var x = 0; x < lines.first.length; x++) {
      var c = lines[y].substring(x, x + 1);
      if (c == 'S') {
        start = '$x/$y';
        c = 'a';
      } else if (c == 'E') {
        end = '$x/$y';
        c = 'z';
      }
      var h = c.codeUnitAt(0) - 'a'.codeUnitAt(0);
      var n = Node('$x/$y', h);
      g.ensure(n);
    }
  }
  return g;
}

var dirs = [Point(0, 1), Point(0, -1), Point(1, 0), Point(-1, 0)];
var start = '', end = '';
part1(List<String> lines) {
  Graph g = buildGraph(lines);
  // Add edges
  for (var y = 0; y < lines.length; y++) {
    for (var x = 0; x < lines.first.length; x++) {
      var h = Point(x, y);
      var hh = g.nodes['${h.x}/${h.y}']!.height;
      for (var d in dirs) {
        var n = h + d;
        if (g.nodes.containsKey('${n.x}/${n.y}')) {
          var nh = g.nodes['${n.x}/${n.y}']!.height;
          if (nh - hh <= 1) {
            g.addEdge('${h.x}/${h.y}', '${n.x}/${n.y}', 1);
          }
        }
      }
    }
  }
  var path = dijkstra(g, start, end);
  return path[end];
}

part2(List<String> lines) {
  Graph g = buildGraph(lines);

  // Add edges
  for (var y = 0; y < lines.length; y++) {
    for (var x = 0; x < lines.first.length; x++) {
      var h = Point(x, y);
      var hh = g.nodes['${h.x}/${h.y}']!.height;
      for (var d in dirs) {
        var n = h + d;
        if (g.nodes.containsKey('${n.x}/${n.y}')) {
          var nh = g.nodes['${n.x}/${n.y}']!.height;
          if (nh - hh <= 1) {
            // building the other way round.
            g.addEdge('${n.x}/${n.y}', '${h.x}/${h.y}', 1);
          }
        }
      }
    }
  }
  var path = dijkstra(g, end, start);
  return path.entries
      .where((e) => g.nodes[e.key]!.height == 0)
      .map((e) => e.value)
      .min;
}
