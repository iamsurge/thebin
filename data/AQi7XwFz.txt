import 'package:dapp_blog/src/features/authentication/domain/auth_model.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:url_launcher/url_launcher_string.dart';
import 'package:walletconnect_dart/walletconnect_dart.dart';

abstract class AuthRepository {
  Future<WalletModel?> connectToWallet();

  Future<void> signOut();
}

class MetamaskAuthRepository extends AuthRepository {
  WalletModel _walletAddress = WalletModel(session: null);
  Stream<bool> authState = Stream.value(false);

  final connector = WalletConnect(
    bridge: 'https://bridge.walletconnect.org',
    clientMeta: const PeerMeta(
      // metadata for the wallet (optional)
      name: 'blogchain',
      description: 'Blog based on web3',
      url: 'https://blogchain.eth',
      icons: [
        'https://files.gitbook.com/v0/b/gitbook-legacy-files/o/spaces%2F-LJJeCjcLrr53DcT1Ml7%2Favatar.png?alt=media'
      ],
    ),
  );

  @override
  Future<WalletModel> connectToWallet() async {
    if (!connector.connected) {
      try {
        var session = await connector.createSession(onDisplayUri: (uri) async {
          await launchUrlString(uri, mode: LaunchMode.platformDefault);
        });
        _walletAddress = WalletModel(session: session);
        authState = Stream.value(true);
      } catch (exp) {
        print(exp);
      }
    }
    return _walletAddress;
  }

  String? get getWalletAddress {
    return _walletAddress.getWalletAddress;
  }

  String getNetworkName(chainId) {
    switch (chainId) {
      case 1:
        return 'Ethereum Mainnet';
      case 3:
        return 'Ropsten Testnet';
      case 4:
        return 'Rinkeby Testnet';
      case 5:
        return 'Goreli Testnet';
      case 42:
        return 'Kovan Testnet';
      case 137:
        return 'Polygon Mainnet';
      case 80001:
        return 'Mumbai Testnet';
      default:
        return 'Unknown Chain';
    }
  }

  @override
  Future<void> signOut() async {
    await connector.killSession();
    authState = Stream.value(false);
  }
}

final metamaskProvider = Provider<MetamaskAuthRepository>((ref) {
  return MetamaskAuthRepository();
});

final authStateChangesProvider = StreamProvider.autoDispose<bool>((ref) {
  final authRepository = ref.watch(metamaskProvider);
  return authRepository.authState;
});
