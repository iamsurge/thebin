#include <iostream>
#include <string>
#include <sstream>
#include <cmath>
#include <memory.h>
#include <algorithm>
#include <stack>
#include <deque>
#include <iomanip>
#include <stdio.h>
#include <queue>
#include <map>
#include <set>
#include <unordered_map>
#include <unordered_set>
#include <random>
#include <ctime>
#include <cstdlib>
#include <cassert>
#include <chrono>
#include <array>
#define int long long
#define pii pair <int, int>
#define pb push_back
#define all(vc) vc.begin(), vc.end()
#define fir first
#define sec second
#define endl "\n"
#define un unsigned
#define INF 1000000009
#define double long double
using namespace std;

const int N = 1005, R = 1 << 20, MOD = 1e9 + 7, ABC = 26, logn = 19;

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

struct Node {
    int x, y, sz, sum;
    Node* left = nullptr;
    Node* right = nullptr;

    Node(int a) :x(a), y(rnd()), sz(1), sum(a) {}
    Node() :x(0), y(rnd()), sz(1), sum(0) {}
};

int get_sum(Node* a) {
    if (a == nullptr)
        return 0;
    return a->sum;
}

int get_sz(Node* a) {
    if (a == nullptr)
        return 0;
    return a->sz;
}

Node* update(Node* a) {
    if (a == nullptr)
        return a;
    a->sz = 1 + get_sz(a->left) + get_sz(a->right);
    a->sum = a->x + get_sum(a->left) + get_sum(a->right);
    return a;
}

Node* merge(Node* a, Node* b) {
    if (a == nullptr)
        return b;
    if (b == nullptr)
        return a;

    if (a->y > b->y) {
        a->right = merge(a->right, b);
        a = update(a);
        return a;
    }
    else
    {
        b->left = merge(a, b->left);
        b = update(b);
        return b;
    }
}

pair<Node*, Node*>split(Node* root, int k) {
    if (root == nullptr)
        return { nullptr, nullptr };
    if (get_sz(root->left) + 1 <= k) {
        auto sp = split(root->right, k - get_sz(root->left) - 1);
        root->right = sp.first;
        root = update(root);
        return { root, sp.sec };
    }
    else {
        auto sp = split(root->left, k);
        root->left = sp.second;
        root = update(root);
        return { sp.fir, root };
    }
}

Node* insert(Node* root, int pos, Node* nn) {
    auto sp = split(root, pos - 1);
    root = merge(sp.first, merge(nn, sp.sec));
    return root;
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    srand(time(0));

    int n, m;
    int number = 1;

    while (cin >> n >> m) {
        if (n == 0 && m == 0)
            break;

        Node* root1 = nullptr;
        Node* root2 = nullptr;
        for (int i = 0; i < n; i++) {
            int a;
            cin >> a;

            Node* q = new Node(a);

            if ((i+1) & 1) {
                root1 = insert(root1, i / 2 + 1, q);
            }
            else
            {
                root2 = insert(root2, i / 2 + 1, q);
            }
        }

        cout << "Swapper " << number << ":" << endl;
        number++;

        while (m--) {
            int type, l, r;
            cin >> type >> l >> r;
            l--;
            r--;

            if (type == 1) {
                if (l & 1 == 0) {
                    auto sp1 = split(root1, ((r - 1) / 2 + 1));
                    auto sp2 = split(sp1.fir, ((l) / 2 + 1) - 1);
                    auto sp3 = split(root2, ((r) / 2 + 1));
                    auto sp4 = split(sp3.fir, ((l + 1) / 2 + 1) - 1);
                    root1 = merge(sp2.first, merge(sp4.sec, sp1.second));
                    root2 = merge(sp4.first, merge(sp2.sec, sp3.sec));
                }
                else {
                    auto sp1 = split(root1, (r / 2 + 1));
                    auto sp2 = split(sp1.fir, ((l + 1) / 2 + 1) - 1);
                    auto sp3 = split(root2, ((r - 1) / 2 + 1));
                    auto sp4 = split(sp3.fir, (l / 2 + 1) - 1);
                    root1 = merge(sp2.first, merge(sp4.sec, sp1.second));
                    root2 = merge(sp4.first, merge(sp2.sec, sp3.sec));
                }
            }
            else {
                l++;
                r++;
                auto sp1 = split(root1, ((r + 1) / 2));
                auto sp2 = split(sp1.fir, (l / 2 ));
                auto sp3 = split(root2, ((r) / 2));
                auto sp4 = split(sp3.fir, (l-1) / 2);
                int ans = get_sum(sp2.sec) + get_sum(sp4.sec);
                cout << ans << endl;
                root1 = merge(merge(sp2.first, sp2.sec), sp1.sec);
                root2 = merge(merge(sp4.first, sp4.sec), sp3.sec);
            }
        }
    }
    return 0;
}
