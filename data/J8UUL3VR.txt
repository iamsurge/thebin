public int dfs(int[][] grid, int i, int j) {
        int curArea;
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }
 
        grid[i][j] = 0;
        curArea = (1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1));
        return curArea;
}

class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        dfs(image, sr, sc, newColor, image[sr][sc]);
        return image;
    }
    
    void dfs(int[][] img, int i, int j, int col, int target) {
        if (i < 0 || i >= img.length || j < 0 || j >= img[0].length || img[i][j] != target || img[i][j] == col) {
            return;
        }
        
        img[i][j] = col;
        dfs(img, i + 1, j, col, target);
        dfs(img, i - 1, j, col, target);
        dfs(img, i, j + 1, col, target);
        dfs(img, i, j - 1, col, target);
    }
}

class Solution {
    List<String> ans = new ArrayList<>();
    
    public List<String> binaryTreePaths(TreeNode root) {
        dfs(root, "");
        return ans;
    }
    
    void dfs(TreeNode root, String path) {
        if (root == null) {
            return;
        }
        
        if (root.left == null && root.right == null) {
            ans.add(path + root.val);
            return;
        }
        
        dfs(root.left, path + root.val + "->");
        dfs(root.right, path + root.val + "->");
    }
}