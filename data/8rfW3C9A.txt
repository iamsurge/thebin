#include <Windows.h>
#include <string>
#include <iostream>
#include <cstdio>
#include <tlhelp32.h>
#include <process.h>
#include <processthreadsapi.h>
#include <cstdio>
using namespace std;

LPDWORD pid ;

struct Enum_windows_data
{
	DWORD process_id;
	const char* window_title;
	HWND hwnd;
};

BOOL CALLBACK enum_windows_proc(HWND hwnd, LPARAM lparam)
{
	auto data = reinterpret_cast<Enum_windows_data*>(lparam);

	DWORD process_id = 0;

	GetWindowThreadProcessId(hwnd, &process_id);

	if (process_id == data->process_id)
	{
		if (!data->window_title)
		{
			data->hwnd = hwnd;

			return FALSE;
		}

		char window_title[64 + 1];

		if (!GetWindowTextA(hwnd, window_title, sizeof(window_title)))
			return TRUE; // No title or error

		if (_stricmp(window_title, data->window_title) == 0)
		{
			data->hwnd = hwnd;

			return FALSE;
		}
	}

	return TRUE;
}

FORCEINLINE DWORD get_thread_id_by_hwnd(HWND hwnd)
{
	return GetWindowThreadProcessId(hwnd, pid);
}



HWND find_window(DWORD pid, const std::string& window_title)
{
	Enum_windows_data data;
	data.process_id = pid;
	data.window_title
		= window_title.empty()
		? nullptr
		: window_title.c_str();
	data.hwnd = nullptr;

	// MSDN: If EnumWindowsProc returns zero, the return value is also zero.
	if (!EnumWindows(enum_windows_proc, reinterpret_cast<LPARAM>(&data)) && !data.hwnd)
	{
		return nullptr;
	}

	if (!data.hwnd)
	{
		return nullptr;
	}
	return data.hwnd;
}


struct GetCurrentProcessWindowParameters
{
	HWND hWnd;
	LPCSTR ClassName;
	LPCSTR Title;
};



HWND FindWindowX(LPCSTR className, LPCSTR title)
{
	GetCurrentProcessWindowParameters parameters;
	parameters.hWnd = nullptr;
	parameters.ClassName = className;
	parameters.Title = title;

	EnumWindows(enum_windows_proc, reinterpret_cast<LPARAM>(&parameters));

	return parameters.hWnd;
}
 

int main(int argc, wchar_t* argv[])
{

 
 
	//Load library in which weâ€™ll be hooking our functions.
	HMODULE dll = LoadLibraryW(L"xinput1_3.dll");
	if (dll == NULL)
	{
		cout << "[ FAILED ] Could not find target window." << endl;
		system("pause");
		return EXIT_FAILURE;
	}

	
	HWND target = FindWindowX("LaunchUnrealUWindowsClient", "Alliance of Valiant Arms");
	if (target == NULL)
	{
		cout << "target = 0." << endl;
		system("pause");
		return EXIT_FAILURE;
	}
	cout << "window Found " << target << std::hex << std::endl;
	DWORD tid = GetWindowThreadProcessId(target,pid);
	if (tid == NULL)
	{
		cout << "tid = 0." << endl;
		system("pause");
		return EXIT_FAILURE;
	}
	cout << "pid = " << pid << endl;
	cout << "tid = " << tid << endl;
  
	//Get the address of the function inside the DLL.	
	HOOKPROC addr = (HOOKPROC)GetProcAddress(dll, "NextHook");
	if (addr == NULL)
	{
		cout << "dll = 0" << endl;
		system("pause");
		return EXIT_FAILURE;
	}

	//Hook the function.
	HHOOK handle = SetWindowsHookEx(WH_GETMESSAGE, addr, dll, tid);
	if (handle == NULL)
	{
		cout << "MDFK Success injected" << endl;
		system("pause");
		return EXIT_FAILURE;
	}
	cout << "injection successfull Handle = " << handle << std::hex << endl;
 
	//	 Unhook the function.	
	system("pause");
	return EXIT_FAILURE;

	UnhookWindowsHookEx(handle);

	return 0;
}