const fs = require('fs')

// const input = fs.readFileSync('test.txt').toString().trim()
const input = fs.readFileSync('input.txt').toString().trim()

const START = -13
const FINISH = -27

const topography = input
  .split('\n')
  .map((line) => line.split('').map((char) => ({
    [START]: 0,
    [FINISH]: 27,
  })[char.charCodeAt(0) - 96] ?? char.charCodeAt(0) - 96))


const coords = topography.reduce((acc, line, x) => ({
  start: line.includes(0) ? [x, line.findIndex((weight) => weight === 0)] : acc.start,
  finish: line.includes(27) ? [x, line.findIndex((weight) => weight === 27)] : acc.finish,
}), { start: '', finish: '' })

/* based on https://betterprogramming.pub/5-ways-to-find-the-shortest-path-in-a-graph-88cfefd0030f*/
const queue = [{ node: coords.start, dist: 0 }]
const visited = []

while (queue.length) {
  const { node, dist } = queue.shift()
  if (node.join(',') === coords.finish.join(',')) {
    console.log(dist)
    break
  }

  if (!visited.includes(node.join(','))) {
    visited.push(node.join(','));
    [
      [node.at(0), node.at(1) + 1],
      [node.at(0) + 1, node.at(1)],
      [node.at(0), node.at(1) - 1],
      [node.at(0) - 1, node.at(1)],
    ].forEach(([newX, newY]) => {
      if (
        newX >= 0 &&
        newX < topography.length &&
        newY >= 0 &&
        newY < topography.at(0).length &&
        topography[newX][newY] <= topography[node.at(0)][node.at(1)] + 1
      ) {
        queue.push({
          node: [newX, newY], dist: dist + 1,
        })
      }
    })
  }
}

/* lazy boring copy paste*/
const visitedTwo = []
const queueTwo = [{ node: coords.finish, dist: 0 }]

while (queue.length) {
  const { node, dist } = queueTwo.shift()

  if (topography[node.at(0)][node.at(1)] === 1) { /* diff here*/
    console.log({ dist })
    return
  }

  if (!visitedTwo.includes(node.join(','))) {
    visitedTwo.push(node.join(','));
    [
      [node.at(0), node.at(1) + 1],
      [node.at(0) + 1, node.at(1)],
      [node.at(0), node.at(1) - 1],
      [node.at(0) - 1, node.at(1)],
    ].forEach(([newX, newY]) => {
      if (
        newX >= 0 &&
        newX < topography.length &&
        newY >= 0 &&
        newY < topography.at(0).length &&
        (topography[newX][newY] - topography[node.at(0)][node.at(1)] >= -1) /*and here*/
      ) {
        queueTwo.push({
          node: [newX, newY], dist: dist + 1,
        })
      }
    })
  }
}
