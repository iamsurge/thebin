/// Compare pairs of lines and sort them
/// 1) pairwise
/// 2) as one big list with interlopers and find the interlopers

import 'dart:math';
import 'package:collection/collection.dart';

import 'package:more/more.dart';
import 'package:petitparser/petitparser.dart';

enum Order { left, right, neither }

class Node implements Comparable {
  int val = 0;
  bool isNumber = false;
  bool isEmpty = false;
  List<Node> children = [];
  Node.empty() : isEmpty = true;
  Node.withAll(List<Node> c) : children = c;
  Node.forNumber(String val)
      : val = int.parse(val),
        isNumber = true;

  static Parser buildParser() {
    var number = digit().plus().trim().flatten().map<Node>(Node.forNumber);

    var numberOrListOrNothing = undefined();
    var listHolder = undefined();

    var listItem = number.or(listHolder);
    var listTerms =
        listItem.separatedBy<Node>(char(','), includeSeparators: false);

    var emptyList = (char('[') & char(']')).map((List l) => Node.empty());
    var lh = (char('[') & numberOrListOrNothing & char(']'))
        .map((List l) => Node.withAll(l[1]));
    listHolder.set(emptyList.or(lh));
    numberOrListOrNothing.set(listTerms.optional());
    var builder = ExpressionBuilder();
    builder.group().primitive(listHolder);
    return builder.build().end();
  }

  static Parser pp = buildParser();

  factory Node.fromString(String listOrNumber) => pp.parse(listOrNumber).value;

  Node get wrapped => isNumber ? pp.parse('[$val]').value : this;
  int get length => children.length;

  Order order(Node other) {
    if (isNumber && other.isNumber) {
      if (val < other.val) return Order.left;
      if (val > other.val) return Order.right;
      return Order.neither;
    }
    var l = wrapped;
    var r = other.wrapped;
    var len = min(l.length, r.length);
    for (var i in 0.to(len)) {
      var b = l.children[i].order(r.children[i]);
      if (b != Order.neither) return b;
    }
    if (l.length < r.length) return Order.left;
    if (l.length > r.length) return Order.right;

    return Order.neither;
  }

  @override
  int compareTo(other) {
    var ord = order(other);
    if (ord == Order.left) return -1;
    if (ord == Order.right) return 1;
    return 0;
  }

  @override
  String toString() {
    if (isNumber) return val.toString();
    var s = children.map((e) => e.toString()).separatedBy(() => ',').join();
    return '[$s]';
  }
}

bool isOrdered(List<String> pair) =>
    Node.fromString(pair.first).order(Node.fromString(pair.last)) == Order.left;

part1(List<String> lines) {
  return lines
      .chunked(3)
      .map((e) => e.take(2))
      .indexed(offset: 1)
      .where((e) => isOrdered(e.value.toList()))
      .map((e) => e.index)
      .sum;
}

part2(List<String> lines) {
  var signals = ['[[2]]', '[[6]]'];
  return (lines..addAll(signals))
      .where((e) => e.isNotEmpty)
      .map((e) => Node.fromString(e))
      .sorted((a, b) => a.compareTo(b))
      .map((e) => e.toString())
      .indexed(offset: 1)
      .where((e) => signals.contains(e.value))
      .map((e) => e.index)
      .reduce((s, t) => s * t);
}
