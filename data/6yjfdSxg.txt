#include <algorithm>
#include <iostream>
#include <cstdio>
#include <vector>

int main1() {
  int n = 34;
  std::cin >> n;
  std::cout << (std::cin.operator bool() ? "Success" : "Fail") << std::endl;
  std::cout << n;
  return 0;
}

int main2() {
  std::vector<int> v;
  int x = 23;
  while (std::cin >> x) v.push_back(x);
  for (int x : v) std::cout << x << " ";
  std::cout << std::endl;
  return 0;
}

int main3() {
  int n = 34, m = 2;
  auto result = scanf("%d %d", &n, &m);
  std::cout << n << " " << m << std::endl;
  std::cout << result << std::endl;
  return 0;
}

int main4() {
  unsigned int a = 0;
  int b = 0;
  std::cin >> a >> b;
  // UNSIGNED!
  auto result = (int)(b - a);
  std::cout << result << std::endl;
  return 0;
}

void BubbleSort(std::vector<int>& v) {
  for (int i = 0; i < v.size(); ++i) {
    bool swapped = false;
    for (int j = 0; j < v.size() - i - 1; ++j) {
      if (v[j + 1] < v[j]) {
        std::swap(v[j], v[j + 1]);
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}

int main5() {
  std::vector<int> v;
  int x = 0;
  while (std::cin >> x) v.push_back(x);
  BubbleSort(v);

  for (int x : v) std::cout << x << " ";
  std::cout << std::endl;
  return 0;
}

typedef long long ll;
typedef void (* TPrintFunction)(int);

//void PrintVector(const std::vector<int>& v, void (* printer_function)(int)) {
void PrintVector(const std::vector<int>& v, TPrintFunction printer_function) {
  for (int x : v) printer_function(x);
  std::cout << std::endl;
}

void SimplePrinter(int x) {
  std::cout << x << " ";
}

void BeautifulPrinter(int x) {
  std::cout << "**" << x << "** ";
}

int main6() {
  std::vector<int> v;
  int x = 0;
  while (std::cin >> x) v.push_back(x);

  PrintVector(v, SimplePrinter);
  PrintVector(v, BeautifulPrinter);
  return 0;
}

struct Point {
  int x = 0;
  int y = 0;
//  Вариант 1.
//  bool operator<(const Point& right) {
//    return x * x + y * y < right.x * right.x + right.y * right.y;
//  }
};

// Вариант 1.
bool operator<(const Point& left, const Point& right) {
  return left.x * left.x + left.y * left.y < right.x * right.x + right.y * right.y;
}

void BubbleSort(std::vector<Point>& v) {
  for (int i = 0; i < v.size(); ++i) {
    bool swapped = false;
    for (int j = 0; j < v.size() - i - 1; ++j) {
      if (v[j + 1] < v[j]) {
        std::swap(v[j], v[j + 1]);
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}

// Вариант 2. Функция сравнения.
bool CompareByModule(const Point& left, const Point& right) {
  return left.x * left.x + left.y * left.y < right.x * right.x + right.y * right.y;
}

void BubbleSort(std::vector<Point>& v, bool (* comp_function)(const Point&, const Point&)) {
  for (int i = 0; i < v.size(); ++i) {
    bool swapped = false;
    for (int j = 0; j < v.size() - i - 1; ++j) {
      if (comp_function(v[j + 1], v[j])) {
        std::swap(v[j], v[j + 1]);
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}

template <typename Compare>
void BubbleSort2(std::vector<Point>& v, Compare c) {
  for (int i = 0; i < v.size(); ++i) {
    bool swapped = false;
    for (int j = 0; j < v.size() - i - 1; ++j) {
      if (c(v[j + 1], v[j])) {
        std::swap(v[j], v[j + 1]);
        swapped = true;
      }
    }
    if (!swapped) break;
  }
}

// Функтор.
class ComparatorByDistance {
 public:
  explicit ComparatorByDistance(const Point& center_) : center(center_) {}
  bool operator()(const Point& left, const Point& right) const {
    return SqrDistToCenter(left) < SqrDistToCenter(right);
  }

 private:
  Point center;

  int SqrDistToCenter(const Point& p) const {
    return (p.x - center.x) * (p.x - center.x) + (p.y - center.y) * (p.y - center.y);
  }
};

int main7() {
  int n = 0;
  std::cin >> n;
  std::vector<Point> v(n);
  for (int i = 0; i < n; ++i) {
    std::cin >> v[i].x >> v[i].y;
  }
  // Вариант 2.
  BubbleSort(v, CompareByModule);
  // Вариант 2. Передаем лямбду.
  BubbleSort(v, [](const Point& left, const Point& right) -> bool {
    return left.x < right.x;
  });
  // Вариант 3. Передаем все, что имеет ()
  BubbleSort2(v, CompareByModule);
  Point center = {4, 5};
  BubbleSort2(v, ComparatorByDistance(center));

  BubbleSort2(v, [&center](const Point& left, const Point& right) -> bool {
    auto dist_left = (left.x - center.x) * (left.x - center.x) + (left.y - center.y) * (left.y - center.y);
    auto dist_right = (right.x - center.x) * (right.x - center.x) + (right.y - center.y) * (right.y - center.y);
    return dist_left < dist_right;
  });
  for (const Point& p : v) {
    std::cout << p.x << " " << p.y << std::endl;
  }
  return 0;
}

int main() {
  int n = 0;
  std::cin >> n;
  std::vector<Point> v(n);
  for (int i = 0; i < n; ++i) {
    std::cin >> v[i].x >> v[i].y;
  }

  std::sort(v.begin(), v.end());
  std::sort(v.begin(), v.end(), ComparatorByDistance({4, 5}));
  // foo
//  std::sort(v.begin(), v.end(), [](Point& left, Point& right) {
//    left.x = 0;
//    right.x = 0;
//    return left.y < right.y;
//  });

  for (const Point& p : v) {
    std::cout << p.x << " " << p.y << std::endl;
  }
  return 0;
}