#ifndef BST_H
#define BST_H

#include <iostream>

using namespace std;

template <class T>
class Nod
{
private:
    Nod<T>* st;
    Nod<T>* dr;
    T data;
public:
    Nod()
    {
        st = nullptr;
        dr = nullptr;
    }

    explicit Nod(T _data)
    {
        data = _data;
        st = nullptr;
        dr = nullptr;
    }

    void inserare(T _data)
    {
        if (data < _data) {
            if (dr == nullptr) {
                dr = new Nod<T> (_data);
            }else{
                dr->inserare(_data);
            }
        }
        if (data > _data) {
            if (st == nullptr) {
                st = new Nod<T> (_data);
            }else{
                st->inserare(_data);
            }
        }
    }

    Nod<T>* cautare(T _data)
    {

    }

    bool stergere(T _data)
    {
        Nod<T> *next;
        if (data == _data) {
            next = st;
            Nod<T> *tmp = next;
            if (st != nullptr) {
                if (next->st == nullptr && next->dr == nullptr) {
                    data = next->data;
                    delete next;
                    st = nullptr;
                }else if (next->dr != nullptr) {
                    while (tmp->dr != nullptr) {
                        tmp = tmp->dr;
                    }
                    data = tmp->data;
                    tmp->dr = nullptr;
                    delete tmp;
                }else {
                    data = st->data;
                    st = next->st;
                    next->st = nullptr;
                    delete next;
                }
                return true;
            }else {
                if (st != nullptr) {
                    if (st->data == _data) {
                        if (st->st == nullptr && st -> dr == nullptr) {
                            delete st;
                            st = nullptr;
                            return false;
                        }
                    }
                }
                if (dr != nullptr) {
                    if (dr->data == _data) {
                        if (dr->st == nullptr && dr -> dr == nullptr) {
                            delete dr;
                            dr = nullptr;
                            return false;
                        }
                    }
                }
                if (_data > data) {
                    if (dr)
                        dr->stergere(_data);
                }else{
                    if (st)
                        st->stergere(_data);
                }
                return false;
            }
        }
    }
    int adancime()
    {

    }

    void afisarePreordine()
    {
        cout << data << " ";
        if (st)
            st->afisarePreordine();
        if (dr)
            dr->afisarePreordine();
    }

    void afisareInordine()
    {
        if (st)
            st->afisareInordine();
        cout << data << " ";
        if (dr)
            dr->afisareInordine();
    }

    void afisarePostordine()
    {
        if (st)
            st->afisarePostordine();
        if (dr)
            dr->afisarePostordine();
        cout << data << " ";
    }

    void prelucrareP2()
    {

    }

    void prelucrareP3()
    {

    }

    ~Nod()
    {

    }

    bool operator<(T _data2)
    {
        return (data < _data2);
    }

    bool  operator==(T _data2)
    {
        return (data ==  _data2);
    }

};


template<class T>
bool conditie(T _data1, T _data2)
{
    // verifica aici conditie si returneaza true/false
}

#endif
