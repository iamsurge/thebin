#include "cuda_runtime.h"
#include "device_launch_parameters.h"

#include <stdio.h>
#include <cmath>
#include <iostream>
#include <omp.h>
#include <chrono>

using namespace std::chrono;

__global__ void saxpy_gpu(int n, float a, float* x, int incx, float* y, int incy)
{
	const int i = blockIdx.x * blockDim.x + threadIdx.x;
	if (i < n)
		y[i * incy] = y[i * incy] + a * x[i * incx];
}

__global__ void daxpy_gpu(int n, double a, double* x, int incx, double* y, int incy)
{
	const int i = blockIdx.x * blockDim.x + threadIdx.x;
	if (i < n)
		y[i * incy] = y[i * incy] + a * x[i * incx];
}

void saxpy(int n, float a, float* x, int incx, float* y, int incy) {
	for (int i = 0; i < n; i++) {
		y[i * incy] = y[i * incy] + a * x[i * incx];
	}
}

void daxpy(int n, double a, double* x, int incx, double* y, int incy) {
	for (int i = 0; i < n; i++) {
		y[i * incy] = y[i * incy] + a * x[i * incx];
	}
}

void saxpy_omp(int n, float a, float* x, int incx, float* y, int incy) {
#pragma omp parallel for num_threads(8)
	for (int i = 0; i < n; i++) {
		y[i * incy] = y[i * incy] + a * x[i * incx];
	}
}

void daxpy_omp(int n, double a, double* x, int incx, double* y, int incy) {
#pragma omp parallel for num_threads(8) 
	for (int i = 0; i < n; i++) {
		y[i * incy] = y[i * incy] + a * x[i * incx];
	}
}

template <typename T>
bool checkResults(T* first, T* second, int n) {
	bool check = true;
	double eps = 5e-3;
	for (int i = 0; i < n; i++) {
		if (fabs(first[i] - second[i]) > eps) {
			check = false;
		}
	}
	return check;
}


int main()
{
	int ARRAY_SIZE = 200000000;
	int n = ARRAY_SIZE;
	int incx = 1;
	int incy = 1;
	float* x_seq = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* y_seq = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* x_omp = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* y_omp = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* x_gpu = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* y_gpu = (float*)malloc(ARRAY_SIZE * sizeof(float));
	float* gpu_res = (float*)malloc(ARRAY_SIZE * sizeof(float));
	for (int i = 0; i < ARRAY_SIZE; i++) {
		float tmp_x = (float)rand() / RAND_MAX;
		x_seq[i] = tmp_x;
		x_omp[i] = tmp_x;
		x_gpu[i] = tmp_x;
		float tmp_y = (float)rand() / RAND_MAX;
		y_seq[i] = tmp_y;
		y_omp[i] = tmp_y;
		y_gpu[i] = tmp_y;
	}

	std::cout << "------------------ SAXPY/CPU ------------------" << std::endl;
	std::cout << "ARRAY SIZE: " << ARRAY_SIZE <<std::endl;

	float a = (float)rand() / RAND_MAX;

	auto start = high_resolution_clock::now();
	saxpy(n, a, x_seq, incx, y_seq, incy);
	auto stop = high_resolution_clock::now();
	std::cout << "SAXPY CPU sequental: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

	double start_fomp = omp_get_wtime();
	saxpy_omp(n, a, x_omp, incx, y_omp, incy);
	double finish_fomp = omp_get_wtime();
	std::cout << "SAXPY OMP: " << (finish_fomp - start_fomp) * (1000) << " ms" << std::endl;

	if (checkResults<float>(y_seq, y_omp, n))
	{
		std::cout << "Results (Sequental & OMP) are equal." << std::endl;
	}

	std::cout << "------------------ SAXPY/GPU ------------------" << std::endl;
	cudaDeviceProp prop;
	cudaGetDeviceProperties(&prop, 0);
	std::cout << prop.name << std::endl << std::endl;
	float* x_gpu_pointer;
	float* y_gpu_pointer;
	for (int j = 3; j < 9; j++) {
		int TPB = pow(2, j);
		int BPG = (ARRAY_SIZE + TPB - 1) / TPB;
		cudaMalloc(&x_gpu_pointer, ARRAY_SIZE * sizeof(float));
		cudaMalloc(&y_gpu_pointer, ARRAY_SIZE * sizeof(float));
		cudaMemcpy(x_gpu_pointer, x_gpu, ARRAY_SIZE * sizeof(float), cudaMemcpyHostToDevice);
		cudaMemcpy(y_gpu_pointer, y_gpu, ARRAY_SIZE * sizeof(float), cudaMemcpyHostToDevice);

		start = high_resolution_clock::now();
		saxpy_gpu<<<BPG, TPB >> > (n, a, x_gpu_pointer, incx, y_gpu_pointer, incy);
		cudaDeviceSynchronize();
		stop = high_resolution_clock::now();
		std::cout << "SAXPY GPU: TPB=" << TPB << "  " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

		cudaMemcpy(gpu_res, y_gpu_pointer, ARRAY_SIZE * sizeof(float), cudaMemcpyDeviceToHost);

		if (checkResults<float>(y_omp, gpu_res, n))
		{
			std::cout << "Results (Sequental & OMP & GPU) are equal." << std::endl << std::endl;
		}
		cudaFree(x_gpu_pointer);
		cudaFree(y_gpu_pointer);
	}

	std::cout << "------------------ DAXPY/CPU ------------------" << std::endl;
	ARRAY_SIZE = 100000000;
	n = ARRAY_SIZE;
	std::cout << "ARRAY SIZE: " << ARRAY_SIZE << std::endl;

	double b = (double)rand() / RAND_MAX;

	double* dx_seq = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dy_seq = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dx_omp = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dy_omp = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dx_gpu = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dy_gpu = (double*)malloc(ARRAY_SIZE * sizeof(double));
	double* dgpu_res = (double*)malloc(ARRAY_SIZE * sizeof(double));
	for (int i = 0; i < ARRAY_SIZE; i++) {
		double tmp_x = (double)rand() / RAND_MAX;
		dx_seq[i] = tmp_x;
		dx_omp[i] = tmp_x;
		dx_gpu[i] = tmp_x;
		double tmp_y = (double)rand() / RAND_MAX;
		dy_seq[i] = tmp_y;
		dy_omp[i] = tmp_y;
		dy_gpu[i] = tmp_y;
	}

	start = high_resolution_clock::now();
	daxpy(n, b, dx_seq, incx, dy_seq, incy);
	stop = high_resolution_clock::now();
	std::cout << "DAXPY CPU sequental: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

	start_fomp = omp_get_wtime();
	daxpy_omp(n, b, dx_omp, incx, dy_omp, incy);
	finish_fomp = omp_get_wtime();
	std::cout << "DAXPY OMP: " << (finish_fomp - start_fomp) * (1000) << " ms" << std::endl;

	if (checkResults<double>(dy_seq, dy_omp, n))
	{
		std::cout << "Results (Sequental & OMP) are equal." << std::endl;
	}

	std::cout << "------------------ DAXPY/GPU ------------------" << std::endl;
	std::cout << prop.name << std::endl << std::endl;
	double* dx_gpu_pointer;
	double* dy_gpu_pointer;
	for (int j = 3; j < 9; j++) {
		int TPB = pow(2, j);
		int BPG = (ARRAY_SIZE + TPB - 1) / TPB;
		cudaMalloc(&dx_gpu_pointer, ARRAY_SIZE * sizeof(double));
		cudaMalloc(&dy_gpu_pointer, ARRAY_SIZE * sizeof(double));
		cudaMemcpy(dx_gpu_pointer, dx_gpu, ARRAY_SIZE * sizeof(double), cudaMemcpyHostToDevice);
		cudaMemcpy(dy_gpu_pointer, dy_gpu, ARRAY_SIZE * sizeof(double), cudaMemcpyHostToDevice);

		start = high_resolution_clock::now();
		daxpy_gpu<<<BPG, TPB >> > (n, b, dx_gpu_pointer, incx, dy_gpu_pointer, incy);
		cudaDeviceSynchronize();
		stop = high_resolution_clock::now();
		std::cout << "DAXPY GPU: TPB=" << TPB << "  " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

		cudaMemcpy(dgpu_res, dy_gpu_pointer, ARRAY_SIZE * sizeof(double), cudaMemcpyDeviceToHost);

		if (checkResults<double>(dy_omp, dgpu_res, n))
		{
			std::cout << "Results (Sequental & OMP & GPU) are equal." << std::endl << std::endl;
		}
		cudaFree(dx_gpu_pointer);
		cudaFree(dy_gpu_pointer);
	}
}
