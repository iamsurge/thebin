/// ## Structs
/// 1. Unit structs, which are field-less, are usefull for generics.
struct Unit;

/// 2. Tuple structs, which are basically, named tuples.
struct Pair(i32, f32);

/// 3. The classic C-structs
#[derive(Debug)]
struct Point { x: f32, y: f32, }

// Cascade Structs
struct Rectangle
{
    top_left: Point,
    bottom_right: Point,
}

/// ## Enums
/// - Use `enum` to create a type which may be one of a few different variants.
/// create an `enum`, note each element is different and independent.
enum VeryVerboseEnumOfThingsToDoWithWebEvent
{
    
    PageLoad,               // An `enum` may either be `unit-like`.
    PageUnload,
    Paste(String),          // `tuple-like` structs,
    Click {x: i64, y: i64}, // `c-like` structs.
}

/// Create a type alias
type WebEvent = VeryVerboseEnumOfThingsToDoWithWebEvent;

/// - `enum` can also be used as C-like enums
enum Number {
    Zero,
    One,
    Two,
}
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

// A function which takes a `WebEvent` enum as an argument
fn inspect(event: WebEvent)
{
    match event
    {
        WebEvent::PageLoad => println!("{}", PAGELOAD),
        WebEvent::PageUnload => println!("page unload"),
        // Destructure `c` from inside the `enum`
        WebEvent::Paste(s) => println!("pasted \"{}\"", s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click {x, y} => {
            println!("clicked at x={x}, y={y}");
        },
    }
}

/// ## Constants
/// > There are 2 types of contants, all requires explicit type annotation.
/// > Can be declared in any scope including global.
/// - `const` An unchangable value (common case)
/// - `static` A possible `mut`able variable with `'static` lifetime.
static PAGELOAD: &str = "page load";
const THRESHOLD: i32 = 16;


fn main()
{
    let _unit = Unit;        // Instantiate a unit struct
    let pair = Pair(1, 0.1); // Instantiate a tuple struct
    // Instantiate a C-like struct
    let point: Point = Point { x: 10.3, y: 0.4 };
    /* /// Create C-like struct with field init shorthand
     * let x = 10.3;
     * let x = 0.4;
     * let point = Point { x, y };
     */

    let Pair(integer, decimal) = pair; // Destructure a tuple struct
    // Access the fields of a tuple struct
    println!("Pair({:?}, {:?}) has {:?}, {:?}", pair.0,pair.1, integer,decimal);


    println!("{:?}", point); // Print debug struct
    println!("point coordinates: ({}, {})", point.x, point.y); // Access fields

    // struct update syntax to copy fields, `bottom_right.y` == `point.y`
    let bottom_right = Point { x: 5.2, ..point };

    // Destructure the point using a `let` binding
    let Point { x: left_edge, y: top_edge } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };
    
    /// Explicity `use` each name so they are available without manual scoping
    use crate::VeryVerboseEnumOfThingsToDoWithWebEvent::{PageLoad, PageUnload};                                 
    // use crate::WebEvent::*; // Automatically `use` each name

    let load   = PageLoad;
    let unload = PageUnload;
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted = WebEvent::Paste("my text".to_owned()); 
    let click  = WebEvent::Click { x: 20, y: 80 };
    
    inspect(load);
    inspect(unload);
    inspect(pasted);
    inspect(click);
    
    // enums can be cast as integer
    println!("One is {}", Number::One as i32);
    println!("Violets are #{:06x}", Color::Blue as i32);
    
    println!("{} is {}", 10, if 10 > THRESHOLD {"bigger"} else {"smaller"});
}