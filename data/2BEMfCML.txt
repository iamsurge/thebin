--By Rufus14
owner = game:GetService("Players").IAmBanFor
character = owner.Character
runservice = game:GetService("RunService")
humanoid = character:findFirstChildOfClass("Humanoid")
local rightleg = Instance.new("Weld", owner.Character.Torso)
rightleg.Part0 = owner.Character.Torso
rightleg.Part1 = owner.Character["Right Leg"]
rightleg.C0 = CFrame.new(0.5,-2,0)
rightleg.Name = "RightLegWeld"
local leftleg = Instance.new("Weld", owner.Character.Torso)
leftleg.Part0 = owner.Character.Torso
leftleg.Part1 = owner.Character["Left Leg"]
leftleg.C0 = CFrame.new(-0.5,-1,0)
leftleg.Name = "LeftLegWeld"
local rightarm = Instance.new("Weld", owner.Character.Torso)
rightarm.Part0 = owner.Character.Torso
rightarm.Part1 = owner.Character["Right Arm"]
rightarm.C0 = CFrame.new(1.5,0,0)
rightarm.Name = "RightArmWeld"
local leftarm = Instance.new("Weld", owner.Character.Torso)
leftarm.Part0 = owner.Character.Torso
leftarm.Part1 = owner.Character["Left Arm"]
leftarm.C0 = CFrame.new(-1.5,0,0)
leftarm.Name = "LeftArmWeld"
local humanoidrootpart = Instance.new("Weld", owner.Character.HumanoidRootPart)
humanoidrootpart.Part0 = owner.Character.HumanoidRootPart
humanoidrootpart.Part1 = owner.Character.Torso
humanoidrootpart.Name = "HumanoidRootPartWeld"
rootpart = character.HumanoidRootPart
while runservice.Stepped:wait() do
	if rootpart.Velocity.x > 1 or rootpart.Velocity.x < -1 or rootpart.Velocity.z > 1 or rootpart.Velocity.z < -1 then
		humanoidrootpart.C0 = humanoidrootpart.C0:lerp(CFrame.new(0,math.sin(tick()*20)/15,0) * CFrame.Angles(0,math.rad(-rootpart.Orientation.y),math.cos(tick()*10)/15) * CFrame.fromEulerAnglesXYZ(humanoid.MoveDirection.z/6,0,-humanoid.MoveDirection.x/6) * CFrame.Angles(0,math.rad(rootpart.Orientation.y),0),0.3)
		leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1.5,0.5,0) * CFrame.Angles(0,math.rad(-rootpart.Orientation.y),0) * CFrame.fromEulerAnglesXYZ(math.sin(tick()*10)*humanoid.MoveDirection.z/1.5,0,math.sin(tick()*10)*-humanoid.MoveDirection.x/1.5) * CFrame.Angles(0,math.rad(rootpart.Orientation.y),0) * CFrame.new(0,-0.5,0),0.3)
		rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5,0.5,0) * CFrame.Angles(0,math.rad(-rootpart.Orientation.y),0) * CFrame.fromEulerAnglesXYZ(-math.sin(tick()*10)*humanoid.MoveDirection.z/1.5,0,-math.sin(tick()*10)*-humanoid.MoveDirection.x/1.5) * CFrame.Angles(0,math.rad(rootpart.Orientation.y),0) * CFrame.new(0,-0.5,0),0.3)
		leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5,-1+math.cos(tick()*10)/4,0) * CFrame.Angles(0,math.rad(-rootpart.Orientation.y),0) * CFrame.fromEulerAnglesXYZ((-math.sin(tick()*10)*humanoid.MoveDirection.z)/1.5,0,(-math.sin(tick()*10)*-humanoid.MoveDirection.x)/1.5) * CFrame.Angles(0,math.rad(rootpart.Orientation.y),0) * CFrame.new(0,-1,0),0.3)
		rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5,-1-math.cos(tick()*10)/4,0) * CFrame.Angles(0,math.rad(-rootpart.Orientation.y),0) * CFrame.fromEulerAnglesXYZ((math.sin(tick()*10)*humanoid.MoveDirection.z)/1.5,0,(math.sin(tick()*10)*-humanoid.MoveDirection.x)/1.5) * CFrame.Angles(0,math.rad(rootpart.Orientation.y),0) * CFrame.new(0,-1,0),0.3)
	else
		humanoidrootpart.C0 = humanoidrootpart.C0:lerp(CFrame.new(0,math.sin(tick())/20,0) * CFrame.Angles(0,math.rad(20),math.sin(tick())/30),0.3)
		leftarm.C0 = leftarm.C0:lerp(CFrame.new(-1.5,0.5,0) * CFrame.Angles(0,0,math.rad(-5)+math.cos(tick())/20) * CFrame.new(0,-0.5,0),0.3)
		rightarm.C0 = rightarm.C0:lerp(CFrame.new(1.5,0.5,0) * CFrame.Angles(0,0,math.rad(5)-math.cos(tick())/20) * CFrame.new(0,-0.5,0),0.3)
		leftleg.C0 = leftleg.C0:lerp(CFrame.new(-0.5,-1-math.sin(tick())/20,0) * CFrame.Angles(0,0,math.rad(-3)-math.sin(tick())/30) * CFrame.new(0,-1,0),0.3)
		rightleg.C0 = rightleg.C0:lerp(CFrame.new(0.5,-1-math.sin(tick())/20,0) * CFrame.Angles(0,0,math.rad(3)-math.sin(tick())/30) * CFrame.new(0,-1,0),0.3)
	end
end