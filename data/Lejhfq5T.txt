SHOW_LINEUP_WILD = true
 
def pbAnim1(viewport)
    # load ball sprite
    ball = Sprite.new(viewport)
    ball.bitmap = pbBitmap("Graphics/Transitions/Common/ball")
    ball.center!(true)
    ball.zoom_x = 0
    ball.zoom_y = 0
    # spin ball into place
    16.times do
      ball.angle += 22.5
      ball.zoom_x += 0.0625
      ball.zoom_y += 0.0625
      pbWait(1)
    end
    # take screenshot
    bmp = Graphics.snap_to_bitmap
    pbWait(8)
    # dispose ball sprite
    ball.dispose
    # black background
    black = Sprite.new(viewport)
    black.bitmap = Bitmap.new(viewport.width,viewport.height)
    black.bitmap.fill_rect(0,0,viewport.width,viewport.height,Color.black)
    # split screenshot into two halves
    field1 = Sprite.new(viewport)
    field1.bitmap = Bitmap.new(viewport.width, viewport.height)
    field1.bitmap.blt(0, 0, bmp, viewport.rect)
    field1.src_rect.height = viewport.height/2
    field2 = Sprite.new(viewport)
    field2.bitmap = field1.bitmap.clone
    field2.y = viewport.height/2
    field2.src_rect.height = viewport.height/2
    field2.src_rect.y = viewport.height/2
    # move halves off screen
    16.times do
      field1.x -= viewport.width/16
      field2.x += viewport.width/16
      pbWait(1)
    end
    viewport.color = Color.new(0,0,0,255)
    # dispose unused sprites
    black.dispose
    field1.dispose
    field2.dispose
  end
  
  
  
    #-----------------------------------------------------------------------------
  # second variant trainer battle animation
  #-----------------------------------------------------------------------------
  def pbAnim2(viewport)
    # take screenshot and draw black background
    bmp = Graphics.snap_to_bitmap
    black = Sprite.new(viewport)
    black.bitmap = Bitmap.new(viewport.width,viewport.height)
    black.bitmap.fill_rect(0,0,viewport.width,viewport.height,Color.black)
    # split screenshot into two halves
    field1 = Sprite.new(viewport)
    field1.bitmap = Bitmap.new(viewport.width, viewport.height)
    field1.bitmap.blt(0, 0, bmp, viewport.rect)
    field1.src_rect.height = viewport.height/2
    field2 = Sprite.new(viewport)
    field2.bitmap = field1.bitmap.clone
    field2.y = viewport.height/2
    field2.src_rect.height = viewport.height/2
    field2.src_rect.y = viewport.height/2
    # draw ballsprites for transition
    ball1 = Sprite.new(viewport)
    ball1.bitmap = pbBitmap("Graphics/Transitions/Common/ball")
    ball1.center!
    ball1.x = viewport.width + ball1.ox
    ball1.y = viewport.height/4
    ball1.zoom_x = 0.5
    ball1.zoom_y = 0.5
    ball2 = Sprite.new(viewport)
    ball2.bitmap = pbBitmap("Graphics/Transitions/Common/ball")
    ball2.center!
    ball2.y = (viewport.height/4)*3
    ball2.x = -ball2.ox
    ball2.zoom_x = 0.5
    ball2.zoom_y = 0.5
    # move ballsprites on screen
    16.times do
      ball1.x -= (viewport.width/8)
      ball2.x += (viewport.width/8)
      pbWait(1)
    end
    # move screenshots
    32.times do
      field1.x -= (viewport.width/16)
      field1.y -= (viewport.height/32)
      field2.x += (viewport.width/16)
      field2.y += (viewport.height/32)
      pbWait(1)
    end
    viewport.color = Color.new(0,0,0,255)
    # dispose unused sprites
    black.dispose
    ball1.dispose
    ball2.dispose
    field1.dispose
    field2.dispose
  end
  #-----------------------------------------------------------------------------
  # third variant trainer battle animation
  #-----------------------------------------------------------------------------
  def pbAnim3(viewport)
    # hash to store all sprites
    balls = {}
    rects = {}
    # creates blank ball bitmap
    ball = Bitmap.new(viewport.height/6,viewport.height/6)
    bmp = pbBitmap("Graphics/Transitions/Common/ball")
    ball.stretch_blt(Rect.new(0,0,ball.width,ball.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
    # creates necessary sprites
    for i in 0...6
      # black rectangles
      rects["#{i}"] = Sprite.new(viewport)
      rects["#{i}"].bitmap = Bitmap.new(2,viewport.height/6)
      rects["#{i}"].bitmap.fill_rect(0,0,2,viewport.height/6,Color.black)
      rects["#{i}"].x = (i%2==0) ? -32 : viewport.width+32
      rects["#{i}"].ox = (i%2==0) ? 0 : 2
      rects["#{i}"].y = (viewport.height/6)*i
      rects["#{i}"].zoom_x = 0
      # ballsprites
      balls["#{i}"] = Sprite.new(viewport)
      balls["#{i}"].bitmap = ball
      balls["#{i}"].center!
      balls["#{i}"].x = rects["#{i}"].x
      balls["#{i}"].y = rects["#{i}"].y + rects["#{i}"].bitmap.height/2
    end
    # moves sprites across screen
    for j in 0...28
      for i in 0...6
        balls["#{i}"].x += (i%2==0) ? 24 : -24
        balls["#{i}"].angle -= (i%2==0) ? 32 : -32
        rects["#{i}"].zoom_x += 12
      end
      pbWait(1)
    end
    viewport.color = Color.new(0,0,0,255)
    # disposes unused sprites
    pbDisposeSpriteHash(balls)
    pbDisposeSpriteHash(rects)
  end
  #-----------------------------------------------------------------------------
  # plays the little rainbow sequence before the animation (can be standalone)
  #-----------------------------------------------------------------------------
  def rainbowIntro(viewport=nil)
    viewport = viewport if !viewport && !viewport.nil?
    @sprites = {} if !@sprites
    # takes screenshot
    bmp = Graphics.snap_to_bitmap
    # creates non-blurred overlay
    @sprites["bg1"] = Sprite.new(viewport)
    @sprites["bg1"].bitmap = Bitmap.new(viewport.width, viewport.height)
    @sprites["bg1"].bitmap.blt(0, 0, bmp, viewport.rect)
    @sprites["bg1"].center!(true)
    # creates blurred overlay
    @sprites["bg2"] = Sprite.new(viewport)
    @sprites["bg2"].bitmap = @sprites["bg1"].bitmap.clone
    @sprites["bg2"].blur_sprite(3)
    @sprites["bg2"].center!(true)
    @sprites["bg2"].opacity = 0
    # creates rainbow rings
    for i in 1..2
      z = [0.35,0.1]
      @sprites["glow#{i}"] = Sprite.new(viewport)
      @sprites["glow#{i}"].bitmap = pbBitmap("Graphics/Transitions/Common/glow")
      @sprites["glow#{i}"].ox = @sprites["glow#{i}"].bitmap.width/2
      @sprites["glow#{i}"].oy = @sprites["glow#{i}"].bitmap.height/2
      @sprites["glow#{i}"].x = viewport.width/2
      @sprites["glow#{i}"].y = viewport.height/2
      @sprites["glow#{i}"].zoom_x = z[i-1]
      @sprites["glow#{i}"].zoom_y = z[i-1]
      @sprites["glow#{i}"].opacity = 0
    end
    # main animation
    for i in 0...32
      # zooms in the two screenshots
      @sprites["bg1"].zoom_x += 0.02
      @sprites["bg1"].zoom_y += 0.02
      @sprites["bg2"].zoom_x += 0.02
      @sprites["bg2"].zoom_y += 0.02
      # fades in the blurry screenshot
      @sprites["bg2"].opacity += 12
      # fades to white
      if i >= 16
        @sprites["bg2"].tone.red += 16
        @sprites["bg2"].tone.green += 16
        @sprites["bg2"].tone.blue += 16
      end
      # zooms in rainbow rings
      if i >= 28
        @sprites["glow1"].opacity += 64
        @sprites["glow1"].zoom_x += 0.02
        @sprites["glow1"].zoom_y += 0.02
      end
      Graphics.update
    end
    viewport.color = Color.new(255,255,255,0)
    # second part of animation
    for i in 0...48
      # zooms in rainbow rings
      @sprites["glow1"].zoom_x += 0.02
      @sprites["glow1"].zoom_y += 0.02
      if i >= 8
        @sprites["glow2"].opacity += 64
        @sprites["glow2"].zoom_x += 0.02
        @sprites["glow2"].zoom_y += 0.02
      end
      # fades viewport to white
      if i >= 32
        viewport.color.alpha += 16
      end
      Graphics.update
    end
    # disposes of the elements
    pbDisposeSpriteHash(@sprites)
    #EliteBattle.set(:colorAlpha,255)
    return true
  end
  #-----------------------------------------------------------------------------
  # displays the animation for the evil team logo (can be standalone)
  #-----------------------------------------------------------------------------
  def evilTeam(viewport = nil, trainerid = -1)
    viewport = viewport if !viewport && !viewport.nil?
    @sprites = {} if !@sprites
    viewport.color = Color.new(0,0,0,0)
    # fades viewport to black
    8.times do
      viewport.color.alpha += 32
      pbWait(1)
    end
    bitmaps = [
      "Graphics/Transitions/EvilTeam/background",
      "Graphics/Transitions/EvilTeam/swirl",
      "Graphics/Transitions/EvilTeam/ray0",
      "Graphics/Transitions/EvilTeam/ray1",
      "Graphics/Transitions/EvilTeam/logo0",
      "Graphics/Transitions/EvilTeam/logo1",
      "Graphics/Transitions/EvilTeam/ring0",
      "Graphics/Transitions/EvilTeam/ring1"
    ]
    # try resolve the bitmaps
    bitmaps = self.resolveBitmaps(bitmaps, trainerid) if trainerid >= 0
    # creates background graphic
    @sprites["bg"] = Sprite.new(viewport)
    @sprites["bg"].bitmap = pbBitmap(bitmaps[0])
    @sprites["bg"].color = Color.black
    # creates background swirl
    @sprites["bg2"] = Sprite.new(viewport)
    @sprites["bg2"].bitmap = pbBitmap(bitmaps[1])
    @sprites["bg2"].ox = @sprites["bg2"].bitmap.width/2
    @sprites["bg2"].oy = @sprites["bg2"].bitmap.height/2
    @sprites["bg2"].x = viewport.width/2
    @sprites["bg2"].y = viewport.height/2
    @sprites["bg2"].visible = false
    # sets up all particles
    speed = []
    for j in 0...16
      @sprites["e1_#{j}"] = Sprite.new(viewport)
      bmp = pbBitmap(bitmaps[2])
      @sprites["e1_#{j}"].bitmap = Bitmap.new(bmp.width,bmp.height)
      w = bmp.width/(1 + rand(3))
      @sprites["e1_#{j}"].bitmap.stretch_blt(Rect.new(0,0,w,bmp.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
      @sprites["e1_#{j}"].oy = @sprites["e1_#{j}"].bitmap.height/2
      @sprites["e1_#{j}"].angle = rand(360)
      @sprites["e1_#{j}"].opacity = 0
      @sprites["e1_#{j}"].x = viewport.width/2
      @sprites["e1_#{j}"].y = viewport.height/2
      speed.push(4 + rand(5))
    end
    # creates logo
    @sprites["logo"] = Sprite.new(viewport)
    @sprites["logo"].bitmap = pbBitmap(bitmaps[4])
    @sprites["logo"].ox = @sprites["logo"].bitmap.width/2
    @sprites["logo"].oy = @sprites["logo"].bitmap.height/2
    @sprites["logo"].x = viewport.width/2
    @sprites["logo"].y = viewport.height/2
    @sprites["logo"].memorize_bitmap
    @sprites["logo"].bitmap = pbBitmap(bitmaps[5])
    @sprites["logo"].zoom_x = 2
    @sprites["logo"].zoom_y = 2
    @sprites["logo"].z = 50
    # creates flash ring graphic
    @sprites["ring"] = Sprite.new(viewport)
    @sprites["ring"].bitmap = pbBitmap(bitmaps[6])
    @sprites["ring"].ox = @sprites["ring"].bitmap.width/2
    @sprites["ring"].oy = @sprites["ring"].bitmap.height/2
    @sprites["ring"].x = viewport.width/2
    @sprites["ring"].y = viewport.height/2
    @sprites["ring"].zoom_x = 0
    @sprites["ring"].zoom_y = 0
    @sprites["ring"].z = 100
    # creates secondary particles
    for j in 0...32
      @sprites["e2_#{j}"] = Sprite.new(viewport)
      bmp = pbBitmap(bitmaps[3])
      @sprites["e2_#{j}"].bitmap = bmp
      @sprites["e2_#{j}"].oy = @sprites["e2_#{j}"].bitmap.height/2
      @sprites["e2_#{j}"].angle = rand(360)
      @sprites["e2_#{j}"].opacity = 0
      @sprites["e2_#{j}"].x = viewport.width/2
      @sprites["e2_#{j}"].y = viewport.height/2
      @sprites["e2_#{j}"].z = 100
    end
    # creates secondary flash ring
    @sprites["ring2"] = Sprite.new(viewport)
    @sprites["ring2"].bitmap = pbBitmap(bitmaps[7])
    @sprites["ring2"].ox = @sprites["ring2"].bitmap.width/2
    @sprites["ring2"].oy = @sprites["ring2"].bitmap.height/2
    @sprites["ring2"].x = viewport.width/2
    @sprites["ring2"].y = viewport.height/2
    @sprites["ring2"].visible = false
    @sprites["ring2"].zoom_x = 0
    @sprites["ring2"].zoom_y = 0
    @sprites["ring2"].z = 100
    # first phase of animation
    for i in 0...32
      viewport.color.alpha -= 8 if viewport.color.alpha > 0
      @sprites["logo"].zoom_x -= 1/32.0
      @sprites["logo"].zoom_y -= 1/32.0
      for j in 0...16
        next if j > i/4
        if @sprites["e1_#{j}"].ox < -(viewport.width/2)
          speed[j] = 4 + rand(5)
          @sprites["e1_#{j}"].opacity = 0
          @sprites["e1_#{j}"].ox = 0
          @sprites["e1_#{j}"].angle = rand(360)
          bmp = pbBitmap(bitmaps[3])
          @sprites["e1_#{j}"].bitmap.clear
          w = bmp.width/(1 + rand(3))
          @sprites["e1_#{j}"].bitmap.stretch_blt(Rect.new(0,0,w,bmp.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
        end
        @sprites["e1_#{j}"].opacity += speed[j]
        @sprites["e1_#{j}"].ox -=  speed[j]
      end
      pbWait(1)
    end
    # configures logo graphic
    @sprites["logo"].color = Color.white
    @sprites["logo"].restore_bitmap
    @sprites["ring2"].visible = true
    @sprites["bg2"].visible = true
    viewport.color = Color.white
    # final animation of background and particles
    for i in 0...144
      if i >= 128
        viewport.color.alpha += 16
      else
        viewport.color.alpha -= 16 if viewport.color.alpha > 0
      end
      @sprites["logo"].color.alpha -= 16 if @sprites["logo"].color.alpha > 0
      @sprites["bg"].color.alpha -= 8 if @sprites["bg"].color.alpha > 0
      for j in 0...16
        if @sprites["e1_#{j}"].ox < -(viewport.width/2)
          speed[j] = 4 + rand(5)
          @sprites["e1_#{j}"].opacity = 0
          @sprites["e1_#{j}"].ox = 0
          @sprites["e1_#{j}"].angle = rand(360)
          bmp = pbBitmap(bitmaps[2])
          @sprites["e1_#{j}"].bitmap.clear
          w = bmp.width/(1 + rand(3))
          @sprites["e1_#{j}"].bitmap.stretch_blt(Rect.new(0,0,w,bmp.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
        end
        @sprites["e1_#{j}"].opacity += speed[j]
        @sprites["e1_#{j}"].ox -=  speed[j]
      end
      for j in 0...32
        next if j > i*2
        @sprites["e2_#{j}"].ox -= 16
        @sprites["e2_#{j}"].opacity += 16
      end
      @sprites["ring"].zoom_x += 0.1
      @sprites["ring"].zoom_y += 0.1
      @sprites["ring"].opacity -= 8
      @sprites["ring2"].zoom_x += 0.2 if @sprites["ring2"].zoom_x < 3
      @sprites["ring2"].zoom_y += 0.2 if @sprites["ring2"].zoom_y < 3
      @sprites["ring2"].opacity -= 16
      @sprites["bg2"].angle += 2 if $PokemonSystem.screensize < 2
      pbWait(1)
    end
    # disposes all sprites
    pbDisposeSpriteHash(@sprites)
    # fades viewport
    8.times do
      viewport.color.red -= 255/8.0
      viewport.color.green -= 255/8.0
      viewport.color.blue -= 255/8.0
      pbWait(1)
    end
    #EliteBattle.set(:colorAlpha,0)
    return true
  end
  #-----------------------------------------------------------------------------
  # plays Team Skull styled intro animation
  #-----------------------------------------------------------------------------
  def teamSkull(viewport = nil, trainerid = -1)
    viewport = viewport if !viewport && !viewport.nil?
    # set up initial variables
    @sprites = {} if !@sprites
    @fpIndex = 0
    @spIndex = 0
    pbWait(4)
    # get list of required graphics
    bitmaps = [
      "Graphics/Transitions/Skull/background",
      "Graphics/Transitions/Skull/smoke",
      "Graphics/Transitions/Skull/logo",
      "Graphics/Transitions/Skull/shine",
      "Graphics/Transitions/Skull/rainbow",
      "Graphics/Transitions/Skull/glow",
      "Graphics/Transitions/Skull/burst",
      "Graphics/Transitions/Skull/ray",
      "Graphics/Transitions/Skull/particle",
      "Graphics/Transitions/Skull/paint0",
      "Graphics/Transitions/Skull/splat0",
      "Graphics/Transitions/Skull/splat1",
      "Graphics/Transitions/Skull/splat2"
    ]
    # try resolve the bitmaps
    bitmaps = self.resolveBitmaps(bitmaps, trainerid) if trainerid >= 0
    # set up background
    @sprites["bg"] = Sprite.new(viewport)
    @sprites["bg"].bitmap = pbBitmap(bitmaps[0])
    @sprites["bg"].color = Color.new(0,0,0,92)
    # set up smoke particles
    for j in 0...20
      @sprites["s#{j}"] = Sprite.new(viewport)
      @sprites["s#{j}"].bitmap = pbBitmap(bitmaps[1])
      @sprites["s#{j}"].center!(true)
      @sprites["s#{j}"].opacity = 0
    end
    # set up ray particles
    for i in 0...16
      @sprites["r#{i}"] = Sprite.new(viewport)
      @sprites["r#{i}"].opacity = 0
    end
    # set up logo
    @sprites["logo"] = Sprite.new(viewport)
    @sprites["logo"].bitmap = pbBitmap(bitmaps[2])
    @sprites["logo"].center!(true)
    @sprites["logo"].z = 9999
    @sprites["logo"].zoom_x = 2
    @sprites["logo"].zoom_y = 2
    @sprites["logo"].color = Color.black
    # set up logo shine
    @sprites["shine"] = Sprite.new(viewport)
    @sprites["shine"].bitmap = pbBitmap(bitmaps[3])
    @sprites["shine"].center!(true)
    @sprites["shine"].x -= 72
    @sprites["shine"].y -= 64
    @sprites["shine"].z = 99999
    @sprites["shine"].opacity = 0
    @sprites["shine"].zoom_x = 0.6
    @sprites["shine"].zoom_y = 0.4
    @sprites["shine"].angle = 30
    # set up rainbow particle
    @sprites["rainbow"] = Sprite.new(viewport)
    @sprites["rainbow"].bitmap = pbBitmap(bitmaps[4])
    @sprites["rainbow"].center!(true)
    @sprites["rainbow"].z = 99999
    @sprites["rainbow"].opacity = 0
    # set up logo glow
    @sprites["glow"] = Sprite.new(viewport)
    @sprites["glow"].bitmap = pbBitmap(bitmaps[5])
    @sprites["glow"].center!(true)
    @sprites["glow"].opacity = 0
    @sprites["glow"].z = 9
    @sprites["glow"].zoom_x = 0.6
    @sprites["glow"].zoom_y = 0.6
    # set up burst sprite
    @sprites["burst"] = Sprite.new(viewport)
    @sprites["burst"].bitmap = pbBitmap(bitmaps[6])
    @sprites["burst"].center!(true)
    @sprites["burst"].zoom_x = 0
    @sprites["burst"].zoom_y = 0
    @sprites["burst"].opacity = 0
    @sprites["burst"].z = 999
    @sprites["burst"].color = Color.new(255,255,255,0)
    # set up particles
    for j in 0...24
      @sprites["p#{j}"] = Sprite.new(viewport)
      @sprites["p#{j}"].bitmap = pbBitmap(bitmaps[8])
      @sprites["p#{j}"].center!(true)
      @sprites["p#{j}"].center!
      z = 1 - rand(81)/100.0
      @sprites["p#{j}"].zoom_x = z
      @sprites["p#{j}"].zoom_y = z
      @sprites["p#{j}"].param = 1 + rand(8)
      r = 256 + rand(65)
      cx, cy = randCircleCord(r)
      @sprites["p#{j}"].ex = @sprites["p#{j}"].x - r + cx
      @sprites["p#{j}"].ey = @sprites["p#{j}"].y - r + cy
      r = rand(33)/100.0
      @sprites["p#{j}"].x = viewport.width/2 - (@sprites["p#{j}"].ex - viewport.width/2)*r
      @sprites["p#{j}"].y = viewport.height/2 - (viewport.height/2 - @sprites["p#{j}"].ey)*r
      @sprites["p#{j}"].visible = false
    end
    # set up paint strokes
    x = [viewport.width/3,viewport.width+32,16,-32,2*viewport.width/3,viewport.width+32,0,viewport.width+64]
    y = [viewport.height+32,viewport.height+32,-32,viewport.height/2,viewport.height+64,viewport.height/2,viewport.height-64,viewport.height/2+32]
    a = [50,135,-70,10,105,165,-30,190]
    for j in 0...8
      @sprites["sl#{j}"] = Sprite.new(viewport)
      @sprites["sl#{j}"].bitmap = pbBitmap(bitmaps[9])
      @sprites["sl#{j}"].oy = @sprites["sl#{j}"].bitmap.height/2
      @sprites["sl#{j}"].z = j < 2 ? 999 : 99999
      @sprites["sl#{j}"].ox = -@sprites["sl#{j}"].bitmap.width
      @sprites["sl#{j}"].x = x[j]
      @sprites["sl#{j}"].y = y[j]
      @sprites["sl#{j}"].angle = a[j]
      @sprites["sl#{j}"].param = (@sprites["sl#{j}"].bitmap.width/8)
    end
    # set up paint splats
    for j in 0...12
      @sprites["sp#{j}"] = Sprite.new(viewport)
      @sprites["sp#{j}"].bitmap = pbBitmap(bitmaps[10 + rand(3)])
      @sprites["sp#{j}"].center!
      @sprites["sp#{j}"].x = rand(viewport.width)
      @sprites["sp#{j}"].y = rand(viewport.height)
      @sprites["sp#{j}"].visible = false
      z = 1 + rand(40)/100.0
      @sprites["sp#{j}"].zoom_x = z
      @sprites["sp#{j}"].zoom_y = z
      @sprites["sp#{j}"].z = 99999
    end
    # begin animation
    for i in 0...32
      viewport.color.alpha -= 16
      @sprites["logo"].zoom_x -= 1/32.0
      @sprites["logo"].zoom_y -= 1/32.0
      @sprites["logo"].color.alpha -= 8
      for j in 0...16
        next if j > @fpIndex/2
        if @sprites["r#{j}"].opacity <= 0
          bmp = pbBitmap(bitmaps[7])
          w = rand(65) + 16
          @sprites["r#{j}"].bitmap = Bitmap.new(w,bmp.height)
          @sprites["r#{j}"].bitmap.stretch_blt(@sprites["r#{j}"].bitmap.rect,bmp,bmp.rect)
          @sprites["r#{j}"].center!(true)
          @sprites["r#{j}"].ox = -(64 + rand(17))
          @sprites["r#{j}"].zoom_x = 1
          @sprites["r#{j}"].zoom_y = 1
          @sprites["r#{j}"].angle = rand(360)
          @sprites["r#{j}"].param = 2 + rand(5)
        end
        @sprites["r#{j}"].ox -= @sprites["r#{j}"].param
        @sprites["r#{j}"].zoom_x += 0.001*@sprites["r#{j}"].param
        @sprites["r#{j}"].zoom_y -= 0.001*@sprites["r#{j}"].param
        if @sprites["r#{j}"].ox > -128
          @sprites["r#{j}"].opacity += 8
        else
          @sprites["r#{j}"].opacity -= 2*@sprites["r#{j}"].param
        end
      end
      if i >= 24
        @sprites["shine"].opacity += 48
        @sprites["shine"].zoom_x += 0.02
        @sprites["shine"].zoom_y += 0.02
      end
      @fpIndex += 1
      Graphics.update
    end
    viewport.color = Color.new(0,0,0,0)
    for i in 0...128
      @sprites["shine"].opacity -= 16
      @sprites["shine"].zoom_x += 0.02
      @sprites["shine"].zoom_y += 0.02
      if i < 8
        z = (i < 4) ? 0.02 : -0.02
        @sprites["logo"].zoom_x -= z
        @sprites["logo"].zoom_y -= z
      end
      for j in 0...16
        if @sprites["r#{j}"].opacity <= 0
          bmp = pbBitmap(bitmaps[7])
          w = rand(65) + 16
          @sprites["r#{j}"].bitmap = Bitmap.new(w,bmp.height)
          @sprites["r#{j}"].bitmap.stretch_blt(@sprites["r#{j}"].bitmap.rect,bmp,bmp.rect)
          @sprites["r#{j}"].center!(true)
          @sprites["r#{j}"].ox = -(64 + rand(17))
          @sprites["r#{j}"].zoom_x = 1
          @sprites["r#{j}"].zoom_y = 1
          @sprites["r#{j}"].angle = rand(360)
          @sprites["r#{j}"].param = 2 + rand(5)
        end
        @sprites["r#{j}"].ox -= @sprites["r#{j}"].param
        @sprites["r#{j}"].zoom_x += 0.001*@sprites["r#{j}"].param
        @sprites["r#{j}"].zoom_y -= 0.001*@sprites["r#{j}"].param
        if @sprites["r#{j}"].ox > -128
          @sprites["r#{j}"].opacity += 8
        else
          @sprites["r#{j}"].opacity -= 2*@sprites["r#{j}"].param
        end
      end
      for j in 0...24
        @sprites["p#{j}"].visible = true
        next if @sprites["p#{j}"].opacity <= 0
        x = (@sprites["p#{j}"].ex - viewport.width/2)/(4.0*@sprites["p#{j}"].param)
        y = (viewport.height/2 - @sprites["p#{j}"].ey)/(4.0*@sprites["p#{j}"].param)
        @sprites["p#{j}"].x -= x
        @sprites["p#{j}"].y -= y
        @sprites["p#{j}"].opacity -= @sprites["p#{j}"].param
      end
      for j in 0...20
        if @sprites["s#{j}"].opacity <= 0
          @sprites["s#{j}"].opacity = 255
          r = 160 + rand(33)
          cx, cy = randCircleCord(r)
          @sprites["s#{j}"].center!(true)
          @sprites["s#{j}"].ex = @sprites["s#{j}"].x - r + cx
          @sprites["s#{j}"].ey = @sprites["s#{j}"].y - r + cy
          @sprites["s#{j}"].toggle = rand(2)==0 ? 2 : -2
          @sprites["s#{j}"].param = 2 + rand(4)
          z = 1 - rand(41)/100.0
          @sprites["s#{j}"].zoom_x = z
          @sprites["s#{j}"].zoom_y = z
        end
        @sprites["s#{j}"].x -= (@sprites["s#{j}"].x - @sprites["s#{j}"].ex)*0.02
        @sprites["s#{j}"].y -= (@sprites["s#{j}"].y - @sprites["s#{j}"].ey)*0.02
        @sprites["s#{j}"].opacity -= @sprites["s#{j}"].param*1.5
        @sprites["s#{j}"].angle += @sprites["s#{j}"].toggle if $PokemonSystem.screensize < 2
        @sprites["s#{j}"].zoom_x -= 0.002
        @sprites["s#{j}"].zoom_y -= 0.002
      end
      # phase 2
      @sprites["bg"].color.alpha -= 2
      @sprites["glow"].opacity += (i < 6) ? 48 : -24
      @sprites["glow"].zoom_x += 0.05
      @sprites["glow"].zoom_y += 0.05
      @sprites["rainbow"].zoom_x += 0.01
      @sprites["rainbow"].zoom_y += 0.01
      @sprites["rainbow"].opacity += (i < 16) ? 32 : -16
      @sprites["burst"].zoom_x += 0.2
      @sprites["burst"].zoom_y += 0.2
      @sprites["burst"].color.alpha += 20
      @sprites["burst"].opacity += 16
      if i >= 72
        for j in 0...8
          next if j > @spIndex/6
          @sprites["sl#{j}"].ox += @sprites["sl#{j}"].param if @sprites["sl#{j}"].ox < 0
        end
        for j in 0...12
          next if @spIndex < 4
          next if j > (@spIndex-4)/4
          @sprites["sp#{j}"].visible = true
        end
        @spIndex += 1
      end
      viewport.color.alpha += 16 if i >= 112
      Graphics.update
    end
    # dispose all sprites
    pbDisposeSpriteHash(@sprites)
    #EliteBattle.set(:colorAlpha, 0)
    return true
  end
 
  
  
    #-----------------------------------------------------------------------------
  #  special animation for Regis
  #-----------------------------------------------------------------------------
  def animRegi(viewport)
    fp = {}
    # gets main index
    #index = self.regiIndex?
    index = 2
    # gets viewport size
    width = viewport.width
    height = viewport.height
    # sets viewport to black, transparent
    viewport.color = Color.new(0,0,0,0)
    # defines necessary sprites
    fp["back"] = Sprite.new(viewport)
    fp["back"].snap_screen
    fp["back"].blur_sprite
    c = index < 3 ? 0 : 255
    fp["back"].color = Color.new(c,c,c,128*(index < 3 ? 1 : 2))
    fp["back"].z = 99999
    fp["back"].opacity = 0
    # positioning matrix for all the Regi dots
    x = [
      [width*0.5,width*0.25,width*0.75,width*0.25,width*0.75,width*0.25,width*0.75],
      [width*0.5,width*0.3,width*0.7,width*0.15,width*0.85,width*0.3,width*0.7],
      [width*0.5,width*0.325,width*0.675,width*0.5,width*0.5,width*0.15,width*0.85],
      [width*0.5,width*0.5,width*0.5,width*0.5,width*0.35,width*0.65,width*0.5]
    ]
    y = [
      [height*0.5,height*0.5,height*0.5,height*0.25,height*0.75,height*0.75,height*0.25],
      [height*0.5,height*0.25,height*0.75,height*0.5,height*0.5,height*0.75,height*0.25],
      [height*0.5,height*0.5,height*0.5,height*0.25,height*0.75,height*0.5,height*0.5],
      [height*0.9,height*0.74,height*0.58,height*0.4,height*0.25,height*0.25,height*0.1]
    ]
    # draws necessary dots
    for j in 0...14
      fp[j] = Sprite.new(viewport)
      fp[j].bitmap = pbBitmap("Graphics/Transitions/Species/regi")
      fp[j].src_rect.set(96*(j/7),100*index,96,100)
      fp[j].ox = fp[j].src_rect.width/2
      fp[j].oy = fp[j].src_rect.height/2
      fp[j].x = x[index][j%7]
      fp[j].y = y[index][j%7]
      fp[j].opacity = 0
      fp[j].z = 99999
    end
    # fades to black
    8.times do
      fp["back"].opacity += 32
      pbWait(1)
    end
    k = -2
    # fades in regi dots
    for i in 0...72
      if index < 3
        k += 2 if i%8 == 0
      else
        k += (k==3 ? 2 : 1) if i%4 == 0
      end
      k = 6 if k > 6
      for j in 0..k
        fp[j].opacity += 32
        fp[j+7].opacity += 26 if fp[j].opacity >= 255
        fp[j].visible = fp[j+7].opacity < 255
      end
      fp["back"].color.alpha += 2 if fp["back"].color.alpha < 255
      pbWait(1)
    end
    # fades viewport to black
    8.times do
      viewport.color.alpha += 32
      pbWait(1)
    end
    # disposes unused sprites
    pbDisposeSpriteHash(fp)
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for outdoor battles
  #-----------------------------------------------------------------------------
  def pbOutdoor(viewport,variant = false)
    # gets screen size
    hz = 8
    vz = 6
    width = viewport.width/hz
    height = viewport.height/vz
    bmp = Graphics.snap_to_bitmap
    # generates all sprite particles
    sps = {}
    if variant
      sps["black"] = Sprite.new(viewport)
      sps["black"].create_rect(viewport.width,viewport.height,Color.black)
    end
    for j in 0...(hz*vz)
      # renders rectangle
      sps[j] = Sprite.new(viewport)
      sps[j].ox = width/2
      # decides which snaking pattern to take
      pat = j < (hz*vz)/2 ? (j/hz)%2 == 0 : (j/hz)%2 == 1
      # determines positioning
      x = pat ? (width/2 + width*(j%hz)) : (viewport.width - width/2 - width*(j%hz))
      y = height * (j/hz)
      sps[j].x = x
      sps[j].y = y
      if variant
        sps[j].bitmap = Bitmap.new(width,height)
        sps[j].bitmap.blt(0,0,bmp,Rect.new(x-width/2,y,width,height))
      else
        sps[j].create_rect(width,height,Color.black)
      end
      sps[j].zoom_x = variant ? 1 : 0
    end
    # animates pattern
    for i in 0...40
      for j in 0...(hz*vz)
        k = j < (hz*vz)/2 ? j : (hz*vz) - j
        next if k > i*0.75
        if variant
          sps[j].zoom_x -= 0.15 if sps[j].zoom_x > 0
        else
          sps[j].zoom_x += 0.15 if sps[j].zoom_x < 1
        end
      end
      pbWait(1)
    end
    # ensures viewport is set to black
    viewport.color = Color.new(0,0,0,255)
    # disposes unused sprites
    pbDisposeSpriteHash(sps)
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for indoor battles
  #-----------------------------------------------------------------------------
  def pbIndoor(viewport)
    # draws blank bitmap upon which to draw snaking pattern
    screen = Sprite.new(viewport)
    screen.bitmap = Bitmap.new(viewport.width,viewport.height)
    black = Color.black
    # gets screen size
    width = viewport.width
    height = viewport.height/16
    # animates pattern draw
    for i in 1..16
      for j in 0...16
        x = (j%2 == 0) ? 0 : viewport.width - i*(width/16)
        screen.bitmap.fill_rect(x,j*height,i*(width/16),height,black)
      end
      pbWait(1)
    end
    # ensures viewport is black
    viewport.color = Color.new(0,0,0,255)
    pbWait(10)
    # disposes unused sprite
    screen.dispose
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for cave battles
  #-----------------------------------------------------------------------------
  def pbCave(viewport)
    # draws blank bitmap upon which to draw snaking pattern
    screen = Sprite.new(viewport)
    screen.bitmap = Bitmap.new(viewport.width,viewport.height)
    black = Color.black
    # gets screen size
    width = viewport.width/4
    height = viewport.height/4
    # draws all sprite elements
    sprites = {}
    for i in 0...16
      sprites[i] = Sprite.new(viewport)
      sprites[i].bitmap = Bitmap.new(width,height)
      sprites[i].bitmap.fill_rect(0,0,width,height,black)
      sprites[i].ox = width/2
      sprites[i].oy = height/2
      sprites[i].x = width/2 + width*(i%4)
      sprites[i].y = viewport.height - height/2 - height*(i/4)
      sprites[i].zoom_x = 0
      sprites[i].zoom_y = 0
    end
    # pattern sequence definition
    seq = [[0],[4,1],[8,5,2],[12,9,6,3],[13,10,7],[14,11],[15]]
    # animate sequence
    for i in 0...seq.length
      5.times do
        for j in 0...seq[i].length
          n = seq[i][j]
          sprites[n].zoom_x += 0.2
          sprites[n].zoom_y += 0.2
        end
        pbWait(1)
      end
    end
    # ensures viewport is black
    viewport.color=Color.new(0,0,0,255)
    pbWait(1)
    # disposes unused sprites
    pbDisposeSpriteHash(sprites)
    screen.dispose
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for water encounters
  #-----------------------------------------------------------------------------
  def pbWater(viewport)
    # gets snapshot of screen
    bmp = Graphics.snap_to_bitmap
    split = 12
    n = viewport.height/split
    sprites = {}
    # creates black bg
    black = Sprite.new(viewport)
    black.bitmap = Bitmap.new(viewport.width,viewport.height)
    black.bitmap.fill_rect(0,0,black.bitmap.width,black.bitmap.height,Color.black)
    # splits the screen into proper segments
    for i in 0...n
      sprites[i] = Sprite.new(viewport)
      sprites[i].bitmap = Bitmap.new(viewport.width, viewport.height)
      sprites[i].bitmap.blt(0, 0, bmp, viewport.rect)
      sprites[i].ox = sprites[i].bitmap.width/2
      sprites[i].x = viewport.width/2
      sprites[i].y = i*split
      sprites[i].src_rect.set(0, i*split, sprites[i].bitmap.width, split)
      sprites[i].color = Color.new(0, 0, 0, 0)
    end
    # animates wave motion
    for f in 0...64
      for i in 0...n
        o = Math.sin(f - i*0.5)
        sprites[i].x = viewport.width/2 + 16*o if f >= i
        sprites[i].color.alpha += 25.5 if sprites[i].color.alpha < 255 && f >= (64 - (48-i))
      end
      pbWait(1)
    end
    # ensures viewport is black
    viewport.color = Color.new(0,0,0,255)
    # disposes unused sprites
    pbDisposeSpriteHash(sprites)
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for minor legendaries
  #-----------------------------------------------------------------------------
  def minorLegendary(viewport,special = false)
    # initial metrics
    bmp = Graphics.snap_to_bitmap
    max = 50
    amax = 4
    frames = {}
    zoom = 1
    # sets viewport color
    viewport.color = special ? Color.new(64,64,64,0) : Color.new(255,255,155,0)
    # animates initial viewport color
    20.times do
      viewport.color.alpha+=2
      pbWait(1)
    end
    # animates screen blur pattern
    for i in 0...(max + 20)
      if !(i%2 == 0)
        zoom += (i > max*0.75) ? 0.3 : -0.01
        angle = 0 if angle.nil?
        angle = (i%3 == 0) ? rand(amax*2) - amax : angle
        # creates necessary sprites
        frames[i] = Sprite.new(viewport)
        frames[i].bitmap = Bitmap.new(viewport.width, viewport.height)
        frames[i].bitmap.blt(0, 0, bmp, viewport.rect)
        frames[i].center!(true)
        frames[i].angle = angle
        frames[i].zoom = zoom
        frames[i].tone = Tone.new(i/4,i/4,i/4)
        frames[i].opacity = 30
      end
      # colors viewport
      if i >= max
        viewport.color.alpha += 12
        if special
          viewport.color.red -= 64/20.0
          viewport.color.green -= 64/20.0
          viewport.color.blue -= 64/20.0
        else
          viewport.color.blue += 5
        end
      end
      pbWait(1)
    end
    # ensures viewport goes to black
    frames[(max+19)].tone = Tone.new(255,255,255)
    pbWait(10)
    10.times do
      next if special
      viewport.color.red-=25.5
      viewport.color.green-=25.5
      viewport.color.blue-=25.5
      pbWait(1)
    end
    # disposes unused sprites
    pbDisposeSpriteHash(frames)
    return true
  end
  #-----------------------------------------------------------------------------
  #  animation for B/W legendaries
  #-----------------------------------------------------------------------------
  def bwLegendary(viewport,special = false)
    bmp = pbBitmap("Graphics/Transitions/Common/zoomStreak")
    n = 10
    sprites = {}
    # generate black backdrop
    sprites["bg"] = Sprite.new(viewport)
    sprites["bg"].full_rect(Color.new(0, 0, 0, 128))
    sprites["bg"].opacity = 0
    # generate zoom sphere
    sprites["sp"] = Sprite.new(viewport)
    sprites["sp"].bitmap = pbBitmap("Graphics/Transitions/Common/zoomSphere")
    sprites["sp"].center!(true)
    sprites["sp"].zoom_x = 0
    sprites["sp"].zoom_y = 0
    sprites["sp"].opacity = 0
    # generate all the sprites
    for i in 0...n
      sprites["s#{i}"] = Sprite.new(viewport)
      sprites["s#{i}"].bitmap = bmp
      sprites["s#{i}"].oy = 48
      sprites["s#{i}"].ox = sprites["s#{i}"].bitmap.width + viewport.width/2
      sprites["s#{i}"].x = viewport.width/2
      sprites["s#{i}"].y = viewport.height/2
      sprites["s#{i}"].angle = i * (360/n)
    end
    # animate in
    for j in 0...48
      for i in 0...n
        if j < 8
          sprites["s#{i}"].ox -= (viewport.width/16)
        elsif j < 16
          sprites["s#{i}"].src_rect.width -= sprites["s#{i}"].bitmap.width/8
          sprites["s#{i}"].src_rect.x += sprites["s#{i}"].bitmap.width/8
          sprites["s#{i}"].ox -= sprites["s#{i}"].bitmap.width/8
          sprites["s#{i}"].zoom_y -= 0.125
          sprites["s#{i}"].tone.all += 32
        end
        sprites["s#{i}"].angle -= 4 if j < 16
      end
      # animate viewport tone
      if j >= 8
        viewport.tone.all += (j < 32) ? 4 : -32
      end
      # animate sphere
      if j >= 16 && j < 32
        sprites["sp"].zoom_x += 0.2
        sprites["sp"].zoom_y += 0.2
        sprites["sp"].opacity += 32
      end
      sprites["bg"].opacity += 16
      pbWait(1)
    end
    # dispose
    pbDisposeSpriteHash(sprites)
    return true
  end
  #-----------------------------------------------------------------------------
  #  animation for B/W legendaries
  #-----------------------------------------------------------------------------
  def bwLegendary2(viewport)
    sprites = {}
    # generate black backdrop
    sprites["bg"] = Sprite.new(viewport)
    sprites["bg"].full_rect(Color.new(0, 0, 0, 128))
    sprites["bg"].opacity = 0
    # generate bar sprite
    sprites["bar"] = Sprite.new(viewport)
    sprites["bar"].bitmap = pbBitmap("Graphics/Transitions/Common/hStreak")
    sprites["bar"].oy = sprites["bar"].bitmap.height/2
    sprites["bar"].y = viewport.height/2
    sprites["bar"].x = -viewport.width
    # generate shine sprite
    sprites["s1"] = Sprite.new(viewport)
    sprites["s1"].bitmap = pbBitmap("Graphics/Transitions/Common/shine2")
    sprites["s1"].center!(true)
    sprites["s1"].zoom = 0
    # generate shine fill sprite
    sprites["s2"] = Sprite.new(viewport)
    sprites["s2"].bitmap = pbBitmap("Graphics/Transitions/Common/shine")
    sprites["s2"].center!(true)
    sprites["s2"].zoom = 0
    sprites["s2"].opacity = 0
    # begin animation part 1
    4.times do
      sprites["bg"].opacity += 64
      sprites["bar"].x += viewport.width/4
      pbWait(1)
    end
    # animate bar out
    8.times do
      sprites["bar"].zoom_y -= 0.125
      sprites["bar"].opacity -= 8
      pbWait(1)
    end
    # animate spark
    for i in 0...8
      sprites["s1"].zoom += i < 4 ? 0.25 : -0.25
      sprites["s1"].angle += 8
      pbWait(1)
    end
    # animate full shine
    viewport.color = Color.new(255, 255, 255, 0)
    for i in 0...16
      sprites["s2"].zoom += 0.25
      sprites["s2"].opacity += 32
      viewport.color.alpha += 32 if i >= 8
      Graphics.update
    end
    viewport.color = Color.white
    16.times { Graphics.update }
    # dispose
    pbDisposeSpriteHash(sprites)
    # fade to black
    16.times do
      viewport.color.red -= 8
      viewport.color.green -= 8
      viewport.color.blue -= 8
      Graphics.update
    end
    viewport.color = Color.black
    2.times { Graphics.update   }
    return true
  end
  #-----------------------------------------------------------------------------
  #  wild animation for Pokemon that are higher level than your party leader
  #-----------------------------------------------------------------------------
  def pbOverlevel(viewport)
    # gets screen size
    height = viewport.height/4
    width = viewport.width/10
    # creates a sprite of screen
    backdrop = Sprite.new(viewport)
    backdrop.snap_screen
    # creates blank sprite
    sprite = Sprite.new(viewport)
    sprite.bitmap = Bitmap.new(viewport.width, viewport.height)
    # animates gradient pattern
    for j in 0...4
      y = [0,2,1,3]
      for i in 1..10
        sprite.bitmap.fill_rect(0,height*y[j],width*i,height,Color.white)
        backdrop.tone.red += 3
        backdrop.tone.green += 3
        backdrop.tone.blue += 3
        pbWait(1)
      end
    end
    # ensures viewport is black
    viewport.color = Color.new(0,0,0,0)
    10.times do
      viewport.color.alpha += 25.5
      pbWait(1)
    end
    # disposes unused sprites
    backdrop.dispose
    sprite.dispose
    return true
  end
  
  
#===============================================================================
#  The main class responsible for loading up the S/M styled Pokemon transitions
#  Only for single Pokemon battles
#===============================================================================
class SunMoonSpeciesTransitions
  attr_accessor :speed
  attr_reader :started
  #-----------------------------------------------------------------------------
  #  creates the transition handler
  #-----------------------------------------------------------------------------
  def initialize(*args)
    return if args.length < 3
    @started = false
    # sets up main viewports
    @viewport = args[0]
    @viewport.color = Color.new(255, 255, 255, 0)#EliteBattle.get(:colorAlpha))
    #EliteBattle.set(:colorAlpha, 0)
    # sets up variables
    @disposed = false
    @sentout = false
    @scene = args[1]
    # sets up Pokemon parameters
    @poke = args[2]
    @species = @poke.species
    @form = @poke.form
    @speed = 1
    @sprites = {}
    # retreives additional parameters
    self.getParameters(@species)
    # initializes the backdrop
    args = "@viewport,@species"
    var = @variant == "trainer" ? "default" : @variant
    # check if can continue
    unless var.is_a?(String) && !var.empty?
    #  EliteBattle.log.error("Cannot get VS sequence variant for Sun/Moon battle transition for species: #{@species}!")
      var = "default"
    end
    # loag background effect
    @sprites["background"] = eval("SunMoon#{var.capitalize}Background.new(#{args})")
    @sprites["background"].speed = 24
    # graphics for bars covering the viewport
    @sprites["bar1"] = Sprite.new(@viewport)
    @sprites["bar1"].create_rect(@viewport.width,@viewport.height/2,Color.black)
    @sprites["bar1"].z = 999
    @sprites["bar2"] = Sprite.new(@viewport)
    @sprites["bar2"].create_rect(@viewport.width,@viewport.height/2 + 2,Color.black)
    @sprites["bar2"].oy = @sprites["bar2"].bitmap.height
    @sprites["bar2"].y = @viewport.height + 2
    @sprites["bar2"].z = 999
    # "electricity" effect that scrolls horizontally behind the Pokemon
    @sprites["streak"] = ScrollingSprite.new(@viewport)
    @sprites["streak"].setBitmap("Graphics/Transitions/Species/light")
    @sprites["streak"].x = @viewport.width
    @sprites["streak"].y = @viewport.height/2
    @sprites["streak"].z = 400
    @sprites["streak"].speed = 64
    @sprites["streak"].oy = @sprites["streak"].bitmap.height/2
    # initializes particles
    for j in 0...24
      n = ["A","B"][rand(2)]
      @sprites["p#{j}"] = Sprite.new(@viewport)
      str = "Graphics/Transitions/Species/particle#{n}#{@species}"
      str = "Graphics/Transitions/Species/particle#{n}" if !pbResolveBitmap(str)
      @sprites["p#{j}"].bitmap = pbBitmap(str)
      @sprites["p#{j}"].ox = @sprites["p#{j}"].bitmap.width/2
      @sprites["p#{j}"].oy = @sprites["p#{j}"].bitmap.height/2
      @sprites["p#{j}"].x = @viewport.width + 48
      y = @viewport.height*0.5*0.72 + rand(0.28*@viewport.height)
      @sprites["p#{j}"].y = y
      @sprites["p#{j}"].speed = rand(4) + 1
      @sprites["p#{j}"].z = 450
      @sprites["p#{j}"].z += 1 if rand(2) == 0
    end
    # determines the extension for the Pokemon bitmap
    str = pbCheckPokemonBitmapFiles([@species,false,@poke.isFemale?,@poke.isShiny?,(@poke.form rescue 0),(@poke.isShadow? rescue false)]).split("/")
    str = str[str.length - 1]
    str = "#{@species}" if !pbResolveBitmap("Graphics/Transitions/species#{str}") # fallback
    # initializes the necessary Pokemon graphic
    @sprites["poke1"] = Sprite.new(@viewport)
    @sprites["poke1"].bitmap = pbBitmap("Graphics/Transitions/species#{str}")
    @sprites["poke1"].ox = @sprites["poke1"].bitmap.width/2
    @sprites["poke1"].oy = @sprites["poke1"].bitmap.height*0.35
    @sprites["poke1"].x = @viewport.width/2
    @sprites["poke1"].y = @viewport.height/2
    @sprites["poke1"].glow(Color.new(101,136,194),35,false)
    @sprites["poke1"].src_rect.height = 0
    @sprites["poke1"].toggle = -1
    @sprites["poke1"].z = 350
    @sprites["poke1"].visible = false
    @sprites["poke2"] = Sprite.new(@viewport)
    @sprites["poke2"].bitmap = pbBitmap("Graphics/Transitions/species#{str}")
    @sprites["poke2"].ox = @sprites["poke2"].bitmap.width/2
    @sprites["poke2"].oy = @sprites["poke2"].bitmap.height*0.35
    @sprites["poke2"].x = @viewport.width
    @sprites["poke2"].y = @viewport.height/2
    @sprites["poke2"].opacity = 0
    @sprites["poke2"].z = 350
  end
  #-----------------------------------------------------------------------------
  #  starts the animation
  #-----------------------------------------------------------------------------
  def start
    @started = true
    return if self.disposed?
    for i in 0...64
      @sprites["background"].reduceAlpha(16) if i < 16
      @sprites["streak"].x -= 64 if @sprites["streak"].x > 0
      @sprites["streak"].update if @sprites["streak"].x <= 0
      @sprites["streak"].opacity -= 16 if i >= 48
      @sprites["bar1"].zoom_y -= 0.02 if @sprites["bar1"].zoom_y > 0.72
      @sprites["bar2"].zoom_y -= 0.02 if @sprites["bar2"].zoom_y > 0.72
      @sprites["poke2"].opacity += 16
      @sprites["poke2"].x -= (@sprites["poke2"].x - @viewport.width/2)*0.1
      for j in 0...24
        next if j > i/2
        @sprites["p#{j}"].x -= 32*@sprites["p#{j}"].speed
      end
      @sprites["background"].update
      Graphics.update
    end
    @sprites["background"].speed = 4
    # changes focus to Pokemon graphic
    for i in 0...8
      @sprites["bar1"].zoom_y -= 0.72/8
      @sprites["bar2"].zoom_y -= 0.72/8
      @sprites["poke1"].y -= 4
      @sprites["poke2"].y -= 4
      if i >= 4
        @viewport.color.alpha += 64
      end
      self.update
      Graphics.update
    end
    # flash and impact of screen
    @sprites["poke1"].oy = @sprites["poke1"].bitmap.height/2
    @sprites["poke1"].y = @viewport.height/2
    @sprites["poke1"].visible = true
    @sprites["poke2"].oy = @sprites["poke2"].bitmap.height/2
    @sprites["poke2"].y = @viewport.height/2
    @sprites["impact"] = Sprite.new(@viewport)
    @sprites["impact"].bitmap = pbBitmap("Graphics/Pictures/impact")
    @sprites["impact"].ox = @sprites["impact"].bitmap.width/2
    @sprites["impact"].oy = @sprites["impact"].bitmap.height/2
    @sprites["impact"].x = @viewport.width/2
    @sprites["impact"].y = @viewport.height/2
    @sprites["impact"].z = 999
    @sprites["impact"].opacity = 0
    pbSEPlay(GameData::Species.cry_filename(@species, @form))
    #@scene.pbShowPartyLineup(0) if SHOW_LINEUP_WILD
    @sprites["background"].show
    k = -1
    # fades flash
    for i in 0...32
      @viewport.color.alpha -= 16 if @viewport.color.alpha > 0
      @sprites["poke2"].y += k*6 if i < 16
      k *= -1 if i%2 == 0
      @sprites["impact"].opacity += (i < 24) ? 64 : -32
      @sprites["impact"].angle += 180 if i%4 == 0
      @sprites["impact"].mirror = !@sprites["impact"].mirror if i%4 == 2
      self.update
      Graphics.update
    end
  end
  #-----------------------------------------------------------------------------
  #  main update call
  #-----------------------------------------------------------------------------
  def update
    return if self.disposed?
    @sprites["poke1"].src_rect.height += 40 if @sprites["poke1"].src_rect.height < 640
    @sprites["poke1"].opacity -= 2*@sprites["poke1"].toggle
    @sprites["poke1"].toggle *= -1 if @sprites["poke1"].opacity <= 0 || @sprites["poke1"].opacity >= 255
    @sprites["background"].update
  end
  #-----------------------------------------------------------------------------
  #  called before Trainer sends out their Pokemon
  #-----------------------------------------------------------------------------
  def finish
    return if self.disposed?
    @scene.clearMessageWindow(true)
    @sprites["ov1"] = Sprite.new(@viewport)
    @sprites["ov1"].snap_screen
    @sprites["ov1"].center!(true)
    @sprites["ov1"].z = 99999
    @sprites["ov2"] = Sprite.new(@viewport)
    @sprites["ov2"].bitmap = @sprites["ov1"].bitmap.clone
    @sprites["ov2"].blur_sprite(3)
    @sprites["ov2"].center!(true)
    @sprites["ov2"].z = 99999
    @sprites["ov2"].opacity = 0
    # final zooming transition
    for i in 0...32
      @sprites["ov1"].zoom_x += 0.02
      @sprites["ov1"].zoom_y += 0.02
      @sprites["ov2"].zoom_x += 0.02
      @sprites["ov2"].zoom_y += 0.02
      @sprites["ov2"].opacity += 12
      if i >= 16
        @sprites["ov2"].tone.all += 16
      end
      Graphics.update
    end
    @viewport.color = Color.white
    self.dispose
    8.times { Graphics.update }
    EliteBattle.set(:smAnim, false)
    # fades out viewport and shows battlebox
    @scene.sprites["dataBox_1"].appear
    @scene.sprites["dataBox_1"].position
    # apply for Player follower
    #if !EliteBattle.follower(@scene.battle).nil?
    #  @scene.sprites["dataBox_#{EliteBattle.follower(@scene.battle)}"].appear
    #  @scene.sprites["dataBox_#{EliteBattle.follower(@scene.battle)}"].position
    #end
    for i in 0...16
      @viewport.color.alpha -= 16
      @scene.wait
    end
  end
  #-----------------------------------------------------------------------------
  #  disposes all sprites
  #-----------------------------------------------------------------------------
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  #-----------------------------------------------------------------------------
  #  checks if disposed
  #-----------------------------------------------------------------------------
  def disposed?; return @disposed; end
  #-----------------------------------------------------------------------------
  #  compatibility for pbFadeOutAndHide
  #-----------------------------------------------------------------------------
  def color; end
  def color=(val); end
  #-----------------------------------------------------------------------------
  #  fetches secondary parameters for the animations
  #-----------------------------------------------------------------------------
  def getParameters(trainerid)
    # method used to check if battling against a registered evil team member
    #@evilteam = EliteBattle.canTransition?("evilTeam", trainerid, @form)
    # methods used to determine special variants
    @variant = "trainer"
    #for ext in EliteBattle.smTransitions?
    #  @variant = ext if EliteBattle.canTransition?("#{ext}SM", trainerid, @form)
    #end
  end
  #-----------------------------------------------------------------------------
end
 
 
 
#===============================================================================
#  Tech here- made this class to make it easier to make trainer intros
#===============================================================================
class SunMoonTrainerTransitions
  attr_accessor :speed
  attr_reader :started
  #-----------------------------------------------------------------------------
  #  creates the transition handler
  #-----------------------------------------------------------------------------
  def initialize(*args)
    return if args.length < 3
    @started = false
    # sets up main viewports
    @viewport = args[0]
    @viewport.color = Color.new(255, 255, 255, 0)#EliteBattle.get(:colorAlpha))
    #EliteBattle.set(:colorAlpha, 0)
    # sets up variables
    @disposed = false
    @sentout = false
    @scene = args[1]
    # sets up Pokemon parameters
    @trainer = args[2]
    @fullname = args[3]
    @speed = 1
    @variant = args[4]
    @sprites = {}
    # retreives additional parameters
    #self.getParameters(@trainer)
    # initializes the backdrop
    args = "@viewport,@trainer"
    var = @variant
    # check if can continue
    unless var.is_a?(String) && !var.empty?
      var = "default"
    end
    # loag background effect
    @sprites["background"] = eval("SunMoon#{var.capitalize}Background.new(#{args})")
    @sprites["background"].speed = 24
    # graphics for bars covering the viewport
    @sprites["bar1"] = Sprite.new(@viewport)
    @sprites["bar1"].create_rect(@viewport.width,@viewport.height/2,Color.black)
    @sprites["bar1"].z = 999
    @sprites["bar2"] = Sprite.new(@viewport)
    @sprites["bar2"].create_rect(@viewport.width,@viewport.height/2 + 2,Color.black)
    @sprites["bar2"].oy = @sprites["bar2"].bitmap.height
    @sprites["bar2"].y = @viewport.height + 2
    @sprites["bar2"].z = 999
    # "electricity" effect that scrolls horizontally behind the Trainer
    @sprites["streak"] = ScrollingSprite.new(@viewport)
    @sprites["streak"].setBitmap("Graphics/Transitions/Species/light")
    @sprites["streak"].x = @viewport.width
    @sprites["streak"].y = @viewport.height/2
    @sprites["streak"].z = 400
    @sprites["streak"].speed = 64
    @sprites["streak"].oy = @sprites["streak"].bitmap.height/2
    # initializes particles
    for j in 0...24
      n = ["A","B"][rand(2)]
      @sprites["p#{j}"] = Sprite.new(@viewport)
      str = "Graphics/Transitions/Species/particle#{n}#{@species}"
      str = "Graphics/Transitions/Species/particle#{n}" if !pbResolveBitmap(str)
      @sprites["p#{j}"].bitmap = pbBitmap(str)
      @sprites["p#{j}"].ox = @sprites["p#{j}"].bitmap.width/2
      @sprites["p#{j}"].oy = @sprites["p#{j}"].bitmap.height/2
      @sprites["p#{j}"].x = @viewport.width + 48
      y = @viewport.height*0.5*0.72 + rand(0.28*@viewport.height)
      @sprites["p#{j}"].y = y
      @sprites["p#{j}"].speed = rand(4) + 1
      @sprites["p#{j}"].z = 450
      @sprites["p#{j}"].z += 1 if rand(2) == 0
    end
    @trainer = @trainer.to_s.rjust(3,"0")
    str = "#{@trainer}"
    # initializes the necessary trainer graphic
    @sprites["trainer1"] = Sprite.new(@viewport)
    @sprites["trainer1"].bitmap = pbBitmap("Graphics/Trainers/#{str}")
    @sprites["trainer1"].ox = @sprites["trainer1"].bitmap.width/2
    @sprites["trainer1"].oy = @sprites["trainer1"].bitmap.height*0.35
    @sprites["trainer1"].x = @viewport.width/2
    @sprites["trainer1"].y = @viewport.height/2
    @sprites["trainer1"].zoom_x = 2
    @sprites["trainer1"].zoom_y = 2
    @sprites["trainer1"].glow(Color.new(101,136,194),35,false)
    @sprites["trainer1"].src_rect.height = 0
    @sprites["trainer1"].toggle = -1
    @sprites["trainer1"].z = 350
    @sprites["trainer1"].visible = false
    @sprites["trainer2"] = Sprite.new(@viewport)
    @sprites["trainer2"].bitmap = pbBitmap("Graphics/Trainers/#{str}")
    @sprites["trainer2"].ox = @sprites["trainer2"].bitmap.width/2
    @sprites["trainer2"].oy = @sprites["trainer2"].bitmap.height*0.35
    @sprites["trainer2"].x = @viewport.width
    @sprites["trainer2"].y = @viewport.height/2
    @sprites["trainer2"].opacity = 0
    @sprites["trainer2"].z = 350
    @sprites["trainer2"].zoom_x = 2
    @sprites["trainer2"].zoom_y = 2
  end
  #-----------------------------------------------------------------------------
  #  starts the animation
  #-----------------------------------------------------------------------------
  def start
    @started = true
    return if self.disposed?
    for i in 0...64
      @sprites["background"].reduceAlpha(16) if i < 16
      @sprites["streak"].x -= 64 if @sprites["streak"].x > 0
      @sprites["streak"].update if @sprites["streak"].x <= 0
      @sprites["streak"].opacity -= 16 if i >= 48
      @sprites["bar1"].zoom_y -= 0.02 if @sprites["bar1"].zoom_y > 0.72
      @sprites["bar2"].zoom_y -= 0.02 if @sprites["bar2"].zoom_y > 0.72
      @sprites["trainer2"].opacity += 16
      @sprites["trainer2"].x -= (@sprites["trainer2"].x - @viewport.width/2)*0.1
      for j in 0...24
        next if j > i/2
        @sprites["p#{j}"].x -= 32*@sprites["p#{j}"].speed
      end
      @sprites["background"].update
      Graphics.update
    end
    @sprites["background"].speed = 4
    # changes focus to Trainer graphic
    for i in 0...8
      @sprites["bar1"].zoom_y -= 0.72/8
      @sprites["bar2"].zoom_y -= 0.72/8
      @sprites["trainer1"].y -= 4
      @sprites["trainer2"].y -= 4
      if i >= 4
        @viewport.color.alpha += 64
      end
      self.update
      Graphics.update
    end
    # flash and impact of screen
    @sprites["trainer1"].oy = @sprites["trainer1"].bitmap.height/2
    @sprites["trainer1"].y = @viewport.height/2
    @sprites["trainer1"].visible = true
    @sprites["trainer2"].oy = @sprites["trainer2"].bitmap.height/2
    @sprites["trainer2"].y = @viewport.height/2
    @sprites["impact"] = Sprite.new(@viewport)
    @sprites["impact"].bitmap = pbBitmap("Graphics/Transitions/impact")
    @sprites["impact"].ox = @sprites["impact"].bitmap.width/2
    @sprites["impact"].oy = @sprites["impact"].bitmap.height/2
    @sprites["impact"].x = @viewport.width/2
    @sprites["impact"].y = @viewport.height/2
    @sprites["impact"].z = 999
    @sprites["impact"].opacity = 0
    pbSEPlay(GameData::Species.cry_filename(@species, @form))
    #@scene.pbShowPartyLineup(0) if SHOW_LINEUP_WILD
    @sprites["background"].show
    k = -1
    # fades flash
    for i in 0...32
      @viewport.color.alpha -= 16 if @viewport.color.alpha > 0
      @sprites["trainer2"].y += k*6 if i < 16
      k *= -1 if i%2 == 0
      @sprites["impact"].opacity += (i < 24) ? 64 : -32
      @sprites["impact"].angle += 180 if i%4 == 0
      @sprites["impact"].mirror = !@sprites["impact"].mirror if i%4 == 2
      self.update
      Graphics.update
    end
  end
  #-----------------------------------------------------------------------------
  #  main update call
  #-----------------------------------------------------------------------------
  def update
    return if self.disposed?
    @sprites["trainer1"].src_rect.height += 40 if @sprites["trainer1"].src_rect.height < 640
    @sprites["trainer1"].opacity -= 2*@sprites["trainer1"].toggle
    @sprites["trainer1"].toggle *= -1 if @sprites["trainer1"].opacity <= 0 || @sprites["trainer1"].opacity >= 255
    @sprites["background"].update
  end
  #-----------------------------------------------------------------------------
  #  called before Trainer sends out their Pokemon
  #-----------------------------------------------------------------------------
  def finish
    return if self.disposed?
    pbMessage(_INTL("You are challenged by {1}!",@fullname))
    #@scene.clearMessageWindow(true)
    @sprites["ov1"] = Sprite.new(@viewport)
    @sprites["ov1"].snap_screen
    @sprites["ov1"].center!(true)
    @sprites["ov1"].z = 99999
    @sprites["ov2"] = Sprite.new(@viewport)
    @sprites["ov2"].bitmap = @sprites["ov1"].bitmap.clone
    @sprites["ov2"].blur_sprite(3)
    @sprites["ov2"].center!(true)
    @sprites["ov2"].z = 99999
    @sprites["ov2"].opacity = 0
    # final zooming transition
    for i in 0...32
      @sprites["ov1"].zoom_x += 0.02
      @sprites["ov1"].zoom_y += 0.02
      @sprites["ov2"].zoom_x += 0.02
      @sprites["ov2"].zoom_y += 0.02
      @sprites["ov2"].opacity += 12
      if i >= 16
        @sprites["ov2"].tone.all += 16
      end
      Graphics.update
    end
    @viewport.color = Color.white
    self.dispose
    8.times { Graphics.update }
    #EliteBattle.set(:smAnim, false)
    # fades out viewport and shows battlebox
    #@scene.sprites["dataBox_1"].appear
    #@scene.sprites["dataBox_1"].position
    # apply for Player follower
    #if !EliteBattle.follower(@scene.battle).nil?
    #  @scene.sprites["dataBox_#{EliteBattle.follower(@scene.battle)}"].appear
    #  @scene.sprites["dataBox_#{EliteBattle.follower(@scene.battle)}"].position
    #end
    for i in 0...16
      @viewport.color.alpha -= 16
      #@scene.wait
    end
  end
  #-----------------------------------------------------------------------------
  #  disposes all sprites
  #-----------------------------------------------------------------------------
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  #-----------------------------------------------------------------------------
  #  checks if disposed
  #-----------------------------------------------------------------------------
  def disposed?; return @disposed; end
  #-----------------------------------------------------------------------------
  #  compatibility for pbFadeOutAndHide
  #-----------------------------------------------------------------------------
  def color; end
  def color=(val); end
  #-----------------------------------------------------------------------------
  #  fetches secondary parameters for the animations
  #-----------------------------------------------------------------------------
  def getParameters(trainerid)
    # method used to check if battling against a registered evil team member
    #@evilteam = EliteBattle.canTransition?("evilTeam", trainerid, @form)
    # methods used to determine special variants
    @variant = "trainer"
    #for ext in EliteBattle.smTransitions?
    #  @variant = ext if EliteBattle.canTransition?("#{ext}SM", trainerid, @form)
    #end
  end
  #-----------------------------------------------------------------------------
end
 
#===============================================================================
#  function used to alter selected graphics based on trainer context
#===============================================================================
def checkForTrainerVariant(files, trainerid, evilteam = false, teamskull = false)
  for i in 0...files.length
    str = sprintf("%s%s", files[i], trainerid)
    str2 = sprintf("%s_%s", files[i], trainerid)
    evl = files[i] + "Evil"
    skl = files[i] + "Skull"
    files[i] = evl if pbResolveBitmap(evl) && evilteam
    files[i] = skl if pbResolveBitmap(skl) && teamskull
    files[i] = str if pbResolveBitmap(str)
    files[i] = str2 if pbResolveBitmap(str2)
  end
  return files
end
#===============================================================================
#  New class used to render the Sun & Moon styled VS background
#===============================================================================
class SunMoonDefaultBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @teamskull = teamskull
    @disposed = false
    @speed = 1
    @sprites = {}
    # reverts to default
    files = ["Graphics/Transitions/Default/background",
          "Graphics/Transitions/Default/layer",
          "Graphics/Transitions/Default/final"
         ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the 3 background layers
    for i in 0...3
      @sprites["bg#{i}"] = ScrollingSprite.new(@viewport)
      @sprites["bg#{i}"].setBitmap(files[i], false, (i > 0))
      @sprites["bg#{i}"].z = 200
      @sprites["bg#{i}"].center!(true)
      @sprites["bg#{i}"].angle = - 8 if $PokemonSystem.screensize < 2
      @sprites["bg#{i}"].color = Color.black
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    for i in 0...3
      @sprites["bg#{i}"].speed = val*(i + 1)
    end
  end
  # updates the background
  def update
    return if self.disposed?
    for i in 0...3
      @sprites["bg#{i}"].update
    end
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for i in 0...3
      @sprites["bg#{i}"].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show; end
end
#===============================================================================
#  New class used to render the special Sun & Moon styled VS background
#===============================================================================
class SunMoonSpecialBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    # get files
    files = [
      "Graphics/Transitions/Special/background",
      "Graphics/Transitions/Special/ring",
      "Graphics/Transitions/Special/particle"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background
    @sprites["background"] = RainbowSprite.new(@viewport)
    @sprites["background"].setBitmap(files[0])
    @sprites["background"].color = Color.black
    @sprites["background"].z = 200
    @sprites["background"].center!(true)
    # handles the particles for the animation
    @vsFp = {}
    @fpDx = []
    @fpDy = []
    @fpIndex = 0
    # loads ring effect
    @sprites["ring"] = Sprite.new(@viewport)
    @sprites["ring"].bitmap = pbBitmap(files[1])
    @sprites["ring"].center!
    @sprites["ring"].x = @viewport.width/2
    @sprites["ring"].y = @viewport.height
    @sprites["ring"].zoom_x = 0
    @sprites["ring"].zoom_y = 0
    @sprites["ring"].z = 500
    @sprites["ring"].visible = false
    @sprites["ring"].color = Color.black
    # loads sparkle particles
    for j in 0...32
      @sprites["s#{j}"] = Sprite.new(@viewport)
      @sprites["s#{j}"].bitmap = pbBitmap(files[2])
      @sprites["s#{j}"].center!
      @sprites["s#{j}"].opacity = 0
      @sprites["s#{j}"].z = 220
      @sprites["s#{j}"].color = Color.black
      @fpDx.push(0)
      @fpDy.push(0)
    end
    @fpSpeed = []
    @fpOpac = []
    # loads scrolling particles
    for j in 0...3
      k = j+1
      speed = 2 + rand(5)
      @sprites["p#{j}"] = ScrollingSprite.new(@viewport)
      @sprites["p#{j}"].setBitmap("Graphics/Transitions/Special/glow#{j}")
      @sprites["p#{j}"].speed = speed*4
      @sprites["p#{j}"].direction = -1
      @sprites["p#{j}"].opacity = 0
      @sprites["p#{j}"].z = 220
      @sprites["p#{j}"].zoom_y = 1 + rand(10)*0.005
      @sprites["p#{j}"].color = Color.black
      @sprites["p#{j}"].center!(true)
      @fpSpeed.push(speed)
      @fpOpac.push(4) if j > 0
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    val = 16 if val > 16
    for j in 0...3
      @sprites["p#{j}"].speed = val*2
    end
  end
  # updates the background
  def update
    return if self.disposed?
    # updates background
    @sprites["background"].update
    # updates ring
    if @sprites["ring"].visible && @sprites["ring"].opacity > 0
      @sprites["ring"].zoom_x += 0.2
      @sprites["ring"].zoom_y += 0.2
      @sprites["ring"].opacity -= 16
    end
    # updates sparkle particles
    for j in 0...32
      next if !@sprites["ring"].visible
      next if !@sprites["s#{j}"] || @sprites["s#{j}"].disposed?
      next if j > @fpIndex/4
      if @sprites["s#{j}"].opacity <= 1
        width = @viewport.width
        height = @viewport.height
        x = rand(width*0.75) + width*0.125
        y = rand(height*0.50) + height*0.25
        @fpDx[j] = x + rand(width*0.125)*(x < width/2 ? -1 : 1)
        @fpDy[j] = y - rand(height*0.25)
        z = [1,0.75,0.5,0.25][rand(4)]
        @sprites["s#{j}"].zoom_x = z
        @sprites["s#{j}"].zoom_y = z
        @sprites["s#{j}"].x = x
        @sprites["s#{j}"].y = y
        @sprites["s#{j}"].opacity = 255
        @sprites["s#{j}"].angle = rand(360)
      end
      @sprites["s#{j}"].x -= (@sprites["s#{j}"].x - @fpDx[j])*0.05
      @sprites["s#{j}"].y -= (@sprites["s#{j}"].y - @fpDy[j])*0.05
      @sprites["s#{j}"].opacity -= @sprites["s#{j}"].opacity*0.05
      @sprites["s#{j}"].zoom_x -= @sprites["s#{j}"].zoom_x*0.05
      @sprites["s#{j}"].zoom_y -= @sprites["s#{j}"].zoom_y*0.05
    end
    # updates scrolling particles
    for j in 0...3
      next if !@sprites["p#{j}"] || @sprites["p#{j}"].disposed?
      @sprites["p#{j}"].update
      if j == 0
        @sprites["p#{j}"].opacity += 5 if @sprites["p#{j}"].opacity < 155
      else
        @sprites["p#{j}"].opacity += @fpOpac[j-1]*(@fpSpeed[j]/2)
      end
      next if @fpIndex < 24
      @fpOpac[j-1] *= -1 if (@sprites["p#{j}"].opacity >= 255 || @sprites["p#{j}"].opacity < 65)
    end
    @fpIndex += 1 if @fpIndex < 150
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      @sprites[key].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    for j in 0...3
      @sprites["p#{j}"].visible = true
    end
    @sprites["ring"].visible = true
    @fpIndex = 0
  end
end
#===============================================================================
#  New class used to render the Sun & Moon kahuna VS background
#===============================================================================
class SunMoonEliteBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    @fpIndex = 0
    # checks for appropriate files
    bg = ["Graphics/Transitions/Elite/background",
          "Graphics/Transitions/Elite/vacuum",
          "Graphics/Transitions/Elite/shine"
         ]
    # gets specific graphics
    bg = checkForTrainerVariant(bg, trainerid, @evilteam, @teamskull)
    # creates the background
    @sprites["background"] = Sprite.new(@viewport)
    @sprites["background"].bitmap = pbBitmap(bg[0])
    @sprites["background"].center!(true)
    @sprites["background"].color = Color.black
    @sprites["background"].z = 200
    # creates particles flying out of the center
    for j in 0...16
      @sprites["e#{j}"] = Sprite.new(@viewport)
      bmp = pbBitmap("Graphics/Transitions/Elite/particle")
      @sprites["e#{j}"].bitmap = Bitmap.new(bmp.width,bmp.height)
      w = bmp.width/(1 + rand(3))
      @sprites["e#{j}"].bitmap.stretch_blt(Rect.new(0,0,w,bmp.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
      @sprites["e#{j}"].oy = @sprites["e#{j}"].bitmap.height/2
      @sprites["e#{j}"].angle = rand(360)
      @sprites["e#{j}"].opacity = 0
      @sprites["e#{j}"].x = @viewport.width/2
      @sprites["e#{j}"].y = @viewport.height/2
      @sprites["e#{j}"].speed = (4 + rand(5))
      @sprites["e#{j}"].z = 220
      @sprites["e#{j}"].color = Color.black
    end
    # creates vacuum waves
    for j in 0...3
      @sprites["ec#{j}"] = Sprite.new(@viewport)
      @sprites["ec#{j}"].bitmap = pbBitmap(bg[1])
      @sprites["ec#{j}"].center!(true)
      @sprites["ec#{j}"].zoom_x = 1.5
      @sprites["ec#{j}"].zoom_y = 1.5
      @sprites["ec#{j}"].opacity = 0
      @sprites["ec#{j}"].z = 205
      @sprites["ec#{j}"].color = Color.black
    end
    # creates center glow
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(bg[2])
    @sprites["shine"].center!(true)
    @sprites["shine"].z = 210
    @sprites["shine"].visible = false
  end
  # sets the speed of the sprites
  def speed=(val); end
  # updates the background
  def update
    return if self.disposed?
    # background and shine
    @sprites["background"].angle += 1 if $PokemonSystem.screensize < 2
    @sprites["shine"].angle -= 1 if $PokemonSystem.screensize < 2
    # updates (and resets) the particles flying from the center
    for j in 0...16
      next if !@sprites["shine"].visible
      if @sprites["e#{j}"].ox < -(@sprites["e#{j}"].viewport.width/2)
        @sprites["e#{j}"].speed = 4 + rand(5)
        @sprites["e#{j}"].opacity = 0
        @sprites["e#{j}"].ox = 0
        @sprites["e#{j}"].angle = rand(360)
        bmp = pbBitmap("Graphics/Transitions/Elite/particle")
        @sprites["e#{j}"].bitmap.clear
        w = bmp.width/(1 + rand(3))
        @sprites["e#{j}"].bitmap.stretch_blt(Rect.new(0,0,w,bmp.height),bmp,Rect.new(0,0,bmp.width,bmp.height))
      end
      @sprites["e#{j}"].opacity += @sprites["e#{j}"].speed
      @sprites["e#{j}"].ox -=  @sprites["e#{j}"].speed
    end
    # updates the vacuum waves
    for j in 0...3
      next if j > @fpIndex/50
      if @sprites["ec#{j}"].zoom_x <= 0
        @sprites["ec#{j}"].zoom_x = 1.5
        @sprites["ec#{j}"].zoom_y = 1.5
        @sprites["ec#{j}"].opacity = 0
      end
      @sprites["ec#{j}"].opacity +=  8
      @sprites["ec#{j}"].zoom_x -= 0.01
      @sprites["ec#{j}"].zoom_y -= 0.01
    end
    @fpIndex += 1 if @fpIndex < 150
  end
  # used to show other elements
  def show
    @sprites["shine"].visible = true
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      @sprites[key].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
 
end
#===============================================================================
#  New class used to render the Mother Beast Lusamine styled VS background
#===============================================================================
class SunMoonCrazyBackground
  attr_accessor :speed
  # main method to create the background
  def initialize(viewport,trainerid,evilteam=false,teamskull=false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    # draws a black backdrop
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].create_rect(@viewport.width,@viewport.height,Color.black)
    @sprites["bg"].z = 200
    @sprites["bg"].color = Color.black
    # draws the 3 circular patterns that change hue
    for j in 0...3
      @sprites["b#{j}"] = RainbowSprite.new(@viewport)
      @sprites["b#{j}"].setBitmap("Graphics/Transitions/Crazy/ring#{j}",8)
      @sprites["b#{j}"].center!(true)
      @sprites["b#{j}"].zoom_x = 0.6 + 0.6*j
      @sprites["b#{j}"].zoom_y = 0.6 + 0.6*j
      @sprites["b#{j}"].opacity = 64 + 64*(1+j)
      @sprites["b#{j}"].z = 250
      @sprites["b#{j}"].color = Color.black
    end
    # draws all the particles
    for j in 0...64
      @sprites["p#{j}"] = Sprite.new(@viewport)
      @sprites["p#{j}"].z = 300
      width = 16 + rand(48)
      height = 16 + rand(16)
      @sprites["p#{j}"].bitmap = Bitmap.new(width,height)
      bmp = pbBitmap("Graphics/Transitions/Crazy/particle")
      @sprites["p#{j}"].bitmap.stretch_blt(Rect.new(0,0,width,height),bmp,Rect.new(0,0,bmp.width,bmp.height))
      @sprites["p#{j}"].bitmap.hue_change(rand(360))
      @sprites["p#{j}"].ox = width/2
      @sprites["p#{j}"].oy = height + 192 + rand(32)
      @sprites["p#{j}"].angle = rand(360)
      @sprites["p#{j}"].speed = 1 + rand(4)
      @sprites["p#{j}"].x = @viewport.width/2
      @sprites["p#{j}"].y = @viewport.height/2
      @sprites["p#{j}"].zoom_x = (@sprites["p#{j}"].oy/192.0)*1.5
      @sprites["p#{j}"].zoom_y = (@sprites["p#{j}"].oy/192.0)*1.5
      @sprites["p#{j}"].color = Color.black
    end
    @frame = 0
  end
  # sets the speed of the sprites
  def speed=(val); end
  # updates the background
  def update
    return if self.disposed?
    # updates the 3 circular patterns changing their hue
    for j in 0...3
      @sprites["b#{j}"].zoom_x -= 0.025
      @sprites["b#{j}"].zoom_y -= 0.025
      @sprites["b#{j}"].opacity -= 4
      if @sprites["b#{j}"].zoom_x <= 0 || @sprites["b#{j}"].opacity <= 0
        @sprites["b#{j}"].zoom_x = 2.25
        @sprites["b#{j}"].zoom_y = 2.25
        @sprites["b#{j}"].opacity = 255
      end
      @sprites["b#{j}"].update if @frame%8==0
    end
    # animates all the particles
    for j in 0...64
      @sprites["p#{j}"].angle -= @sprites["p#{j}"].speed
      @sprites["p#{j}"].opacity -= @sprites["p#{j}"].speed
      @sprites["p#{j}"].oy -= @sprites["p#{j}"].speed/2 if @sprites["p#{j}"].oy > @sprites["p#{j}"].bitmap.height
      @sprites["p#{j}"].zoom_x = (@sprites["p#{j}"].oy/192.0)*1.5
      @sprites["p#{j}"].zoom_y = (@sprites["p#{j}"].oy/192.0)*1.5
      if @sprites["p#{j}"].zoom_x <= 0 || @sprites["p#{j}"].oy <= 0 || @sprites["p#{j}"].opacity <= 0
        @sprites["p#{j}"].angle = rand(360)
        @sprites["p#{j}"].oy = @sprites["p#{j}"].bitmap.height + 192 + rand(32)
        @sprites["p#{j}"].zoom_x = (@sprites["p#{j}"].oy/192.0)*1.5
        @sprites["p#{j}"].zoom_y = (@sprites["p#{j}"].oy/192.0)*1.5
        @sprites["p#{j}"].opacity = 255
        @sprites["p#{j}"].speed = 1 + rand(4)
      end
    end
    @frame += 1
    @frame = 0 if @frame > 128
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      @sprites[key].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show; end
 
end
#===============================================================================
#  New class used to render the ultra squad Sun & Moon styled VS background
#===============================================================================
class SunMoonUltraBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @fpIndex = 0
    @sprites = {}
    # allows for custom graphics as well
    files = ["Graphics/Transitions/Ultra/background",
             "Graphics/Transitions/Ultra/overlay",
             "Graphics/Transitions/Ultra/shine",
             "Graphics/Transitions/Ultra/ring",
             "Graphics/Transitions/Ultra/particle"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background layer
    @sprites["background"] = RainbowSprite.new(@viewport)
    @sprites["background"].setBitmap(files[0],2)
    @sprites["background"].color = Color.black
    @sprites["background"].z = 200
    @sprites["background"].center!(true)
    @sprites["paths"] = RainbowSprite.new(@viewport)
    @sprites["paths"].setBitmap(files[1],2)
    @sprites["paths"].center!(true)
    @sprites["paths"].color = Color.black
    @sprites["paths"].z = 200
    @sprites["paths"].opacity = 215
    @sprites["paths"].toggle = 1
    @sprites["paths"].visible = false
    # creates the shine effect
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(files[2])
    @sprites["shine"].center!(true)
    @sprites["shine"].color = Color.black
    @sprites["shine"].z = 200
    # creates the hexagonal zoom patterns
    for i in 0...12
      @sprites["h#{i}"] = Sprite.new(@viewport)
      @sprites["h#{i}"].bitmap = pbBitmap(files[3])
      @sprites["h#{i}"].center!(true)
      @sprites["h#{i}"].color = Color.black
      @sprites["h#{i}"].z = 220
      z = 1
      @sprites["h#{i}"].zoom_x = z
      @sprites["h#{i}"].zoom_y = z
      @sprites["h#{i}"].opacity = 255
    end
    for i in 0...16
      @sprites["p#{i}"] = Sprite.new(@viewport)
      @sprites["p#{i}"].bitmap = pbBitmap(files[4])
      @sprites["p#{i}"].oy = @sprites["p#{i}"].bitmap.height/2
      @sprites["p#{i}"].x = @viewport.width/2
      @sprites["p#{i}"].y = @viewport.height/2
      @sprites["p#{i}"].angle = rand(360)
      @sprites["p#{i}"].color = Color.black
      @sprites["p#{i}"].z = 210
      @sprites["p#{i}"].visible = false
    end
    160.times do
      self.update(true)
    end
  end
  # sets the speed of the sprites
  def speed=(val)
  end
  # updates the background
  def update(skip=false)
    return if self.disposed?
    if !skip
      @sprites["background"].update
      @sprites["shine"].angle -= 1 if $PokemonSystem.screensize < 2
      @sprites["paths"].update
      @sprites["paths"].opacity -= @sprites["paths"].toggle*2
      @sprites["paths"].toggle *= -1 if @sprites["paths"].opacity <= 85 || @sprites["paths"].opacity >= 215
    end
    for i in 0...12
      next if i > @fpIndex/32
      if @sprites["h#{i}"].opacity <= 0
        @sprites["h#{i}"].zoom_x = 1
        @sprites["h#{i}"].zoom_y = 1
        @sprites["h#{i}"].opacity = 255
      end
      @sprites["h#{i}"].zoom_x += 0.003*(@sprites["h#{i}"].zoom_x**2)
      @sprites["h#{i}"].zoom_y += 0.003*(@sprites["h#{i}"].zoom_y**2)
      @sprites["h#{i}"].opacity -= 1
    end
    for i in 0...16
      next if i > @fpIndex/8
      if @sprites["p#{i}"].opacity <= 0
        @sprites["p#{i}"].ox = 0
        @sprites["p#{i}"].angle = rand(360)
        @sprites["p#{i}"].zoom_x = 1
        @sprites["p#{i}"].zoom_y = 1
        @sprites["p#{i}"].opacity = 255
      end
      @sprites["p#{i}"].opacity -= 2
      @sprites["p#{i}"].ox -= 4
      @sprites["p#{i}"].zoom_x += 0.001
      @sprites["p#{i}"].zoom_y += 0.001
    end
    @fpIndex += 1 if @fpIndex < 512
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      @sprites[key].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    for i in 0...16
      @sprites["p#{i}"].visible = true
    end
    @sprites["paths"].visible = true
  end
end
#===============================================================================
#  New class used to render a custom Sun & Moon styled VS background
#===============================================================================
class SunMoonDigitalBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    @tiles = []
    @data = []
    @fpIndex = 0
    # allows for custom graphics as well
    files = ["Graphics/Transitions/Digital/background",
             "Graphics/Transitions/Digital/particle",
             "Graphics/Transitions/Digital/shine"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(files[0])
    @sprites["bg"].z = 200
    @sprites["bg"].color = Color.black
    @sprites["bg"].center!(true)
    for i in 0...16
      @sprites["p#{i}"] = Sprite.new(@viewport)
      @sprites["p#{i}"].bitmap = pbBitmap(files[1])
      @sprites["p#{i}"].z = 205
      @sprites["p#{i}"].color = Color.black
      @sprites["p#{i}"].oy = @sprites["p#{i}"].bitmap.height/2
      @sprites["p#{i}"].x = @viewport.width/2
      @sprites["p#{i}"].y = @viewport.height/2
      @sprites["p#{i}"].angle = rand(16)*22.5
      @sprites["p#{i}"].visible = false
    end
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(files[2])
    @sprites["shine"].center!
    @sprites["shine"].x = @viewport.width/2
    @sprites["shine"].y = @viewport.height/2
    @sprites["shine"].color = Color.black
    @sprites["shine"].z = 210
    @sprites["shine"].toggle = 1
    # draws all the little tiles
    tile_size = 32.0
    opacity = 25
    offset = 2
    @x = (@viewport.width/tile_size).ceil
    @y = (@viewport.height/tile_size).ceil
    for i in 0...@x
      for j in 0...@y
        sprite = Sprite.new(@viewport)
        sprite.bitmap = Bitmap.new(tile_size,tile_size)
        sprite.bitmap.fill_rect(offset,offset,tile_size-offset*2,tile_size-offset*2,Color.new(255,255,255,opacity))
        sprite.x = i * tile_size
        sprite.y = j * tile_size
        sprite.color = Color.black
        sprite.visible = false
        sprite.z = 220
        o = opacity + rand(156)
        sprite.opacity = 0
        @tiles.push(sprite)
        @data.push([o,rand(5)+4])
      end
    end
  end
  # sets the speed of the sprites
  def speed=(val)
  end
  # updates the background
  def update(skip=false)
    return if self.disposed?
    for i in 0...@tiles.length
      @tiles[i].opacity += @data[i][1]
      @data[i][1] *= -1 if @tiles[i].opacity <= 0 || @tiles[i].opacity >= @data[i][0]
    end
    for i in 0...16
      next if i > @fpIndex/16
      if @sprites["p#{i}"].ox < - @viewport.width/2
        @sprites["p#{i}"].angle = rand(16)*22.5
        @sprites["p#{i}"].ox = 0
        @sprites["p#{i}"].opacity = 255
        @sprites["p#{i}"].zoom_x = 1
        @sprites["p#{i}"].zoom_y = 1
      end
      @sprites["p#{i}"].zoom_x += 0.001
      @sprites["p#{i}"].zoom_y += 0.001
      @sprites["p#{i}"].opacity -= 4
      @sprites["p#{i}"].ox -= 4
    end
    @sprites["shine"].zoom_x += 0.04*@sprites["shine"].toggle
    @sprites["shine"].zoom_y += 0.04*@sprites["shine"].toggle
    @sprites["shine"].toggle *= -1 if @sprites["shine"].zoom_x <= 1 || @sprites["shine"].zoom_x >= 1.4
    @fpIndex += 1 if @fpIndex < 256
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for tile in @tiles
      tile.color.alpha -= factor
    end
    for key in @sprites.keys
      next if key == "bg"
      @sprites[key].color.alpha -= factor
    end
    self.update
  end
  # disposes of everything
  def dispose
    @disposed = true
    for tile in @tiles
      tile.dispose
    end
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    for i in 0...16
      @sprites["p#{i}"].visible = true
    end
    for tile in @tiles
      tile.visible = true
    end
    @sprites["bg"].color.alpha = 0
  end
end
#===============================================================================
#  New class used to render a custom Sun & Moon styled VS background
#===============================================================================
class SunMoonPlasmaBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    @tiles = []
    @data = []
    @fpIndex = 0
    # allows for custom graphics as well
    files = ["Graphics/Transitions/Plasma/background",
             "Graphics/Transitions/Plasma/beam",
             "Graphics/Transitions/Plasma/streaks",
             "Graphics/Transitions/Plasma/shine",
             "Graphics/Transitions/Plasma/particle"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(files[0])
    @sprites["bg"].z = 200
    @sprites["bg"].color = Color.black
    @sprites["bg"].center!(true)
    # creates plasma beam
    for i in 0...2
      @sprites["beam#{i}"] = ScrollingSprite.new(@viewport)
      @sprites["beam#{i}"].setBitmap(files[i+1])
      @sprites["beam#{i}"].speed = [32,48][i]
      @sprites["beam#{i}"].center!
      @sprites["beam#{i}"].x = @viewport.width/2
      @sprites["beam#{i}"].y = @viewport.height/2 - 16
      @sprites["beam#{i}"].zoom_y = 0
      @sprites["beam#{i}"].z = 210
      @sprites["beam#{i}"].color = Color.black
    end
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(files[3])
    @sprites["shine"].center!
    @sprites["shine"].x = @viewport.width
    @sprites["shine"].y = @viewport.height/2 - 16
    @sprites["shine"].z = 220
    @sprites["shine"].visible = false
    @sprites["shine"].toggle = 1
    for i in 0...32
      @sprites["p#{i}"] = Sprite.new(@viewport)
      @sprites["p#{i}"].bitmap = pbBitmap(files[4])
      @sprites["p#{i}"].center!
      @sprites["p#{i}"].opacity = 0
      @sprites["p#{i}"].z = 215
      @sprites["p#{i}"].visible = false
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    @speed = val
  end
  # updates the background
  def update(skip=false)
    return if self.disposed?
    @sprites["shine"].angle += 8 if $PokemonSystem.screensize < 2
    @sprites["shine"].zoom_x -= 0.04*@sprites["shine"].toggle
    @sprites["shine"].zoom_y -= 0.04*@sprites["shine"].toggle
    @sprites["shine"].toggle *= -1 if @sprites["shine"].zoom_x <= 0.8 || @sprites["shine"].zoom_x >= 1.2
    for i in 0...2
      @sprites["beam#{i}"].update
    end
    for i in 0...32
      next if i > @fpIndex/4
      if @sprites["p#{i}"].opacity <= 0
        @sprites["p#{i}"].x = @sprites["shine"].x
        @sprites["p#{i}"].y = @sprites["shine"].y
        r = 256 + rand(129)
        cx, cy = randCircleCord(r)
        @sprites["p#{i}"].ex = @sprites["shine"].x - (cx - r).abs
        @sprites["p#{i}"].ey = @sprites["shine"].y - r/2 + cy/2
        z = 0.4 + rand(7)/10.0
        @sprites["p#{i}"].zoom_x = z
        @sprites["p#{i}"].zoom_y = z
        @sprites["p#{i}"].opacity = 255
      end
      @sprites["p#{i}"].opacity -= 8
      @sprites["p#{i}"].x -= (@sprites["p#{i}"].x - @sprites["p#{i}"].ex)*0.1
      @sprites["p#{i}"].y -= (@sprites["p#{i}"].y - @sprites["p#{i}"].ey)*0.1
    end
    @fpIndex += 1 if @fpIndex < 512
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      next if key == "bg"
      @sprites[key].color.alpha -= factor
    end
    for i in 0...2
      @sprites["beam#{i}"].zoom_y += 0.1 if @sprites["beam#{i}"].color.alpha <= 164 && @sprites["beam#{i}"].zoom_y < 1
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    @sprites["bg"].color.alpha = 0
    for key in @sprites.keys
      @sprites[key].visible = true
    end
  end
end
#===============================================================================
#  New class used to render a custom Sun & Moon styled VS background
#===============================================================================
class SunMoonGoldBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    @tiles = []
    @data = []
    @fpIndex = 0
    # allows for custom graphics as well
    files = ["Graphics/Transitions/Gold/background",
             "Graphics/Transitions/Gold/swirl",
             "Graphics/Transitions/Gold/particleA"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(files[0])
    @sprites["bg"].z = 200
    @sprites["bg"].color = Color.black
    @sprites["bg"].center!(true)
 
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(files[1])
    @sprites["shine"].center!(true)
    @sprites["shine"].z = 210
    @sprites["shine"].toggle = 1
    for i in 0...32
      @sprites["p#{i}"] = Sprite.new(@viewport)
      @sprites["p#{i}"].bitmap = pbBitmap(files[2])
      @sprites["p#{i}"].center!
      @sprites["p#{i}"].opacity = 0
      @sprites["p#{i}"].z = 215
      @sprites["p#{i}"].visible = false
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    @speed = val
  end
  # updates the background
  def update(skip=false)
    return if self.disposed?
    @sprites["shine"].angle += 2 if $PokemonSystem.screensize < 2
    @sprites["shine"].zoom_x -= 0.005*@sprites["shine"].toggle
    @sprites["shine"].zoom_y -= 0.005*@sprites["shine"].toggle
    @sprites["shine"].toggle *= -1 if @sprites["shine"].zoom_x <= 0.9 || @sprites["shine"].zoom_x >= 1.1
    for i in 0...32
      next if i > @fpIndex/4
      if @sprites["p#{i}"].opacity <= 0
        @sprites["p#{i}"].x = @sprites["shine"].x
        @sprites["p#{i}"].y = @sprites["shine"].y
        r = 192 + rand(64)
        cx, cy = randCircleCord(r)
        @sprites["p#{i}"].ex = @sprites["shine"].x - (cx - r)
        @sprites["p#{i}"].ey = @sprites["shine"].y - r/2 + cy/2
        z = 0.8 + rand(7)/10.0
        @sprites["p#{i}"].zoom_x = z
        @sprites["p#{i}"].zoom_y = z
        @sprites["p#{i}"].opacity = 255
      end
      @sprites["p#{i}"].opacity -= 6
      @sprites["p#{i}"].x -= (@sprites["p#{i}"].x - @sprites["p#{i}"].ex)*0.08
      @sprites["p#{i}"].y -= (@sprites["p#{i}"].y - @sprites["p#{i}"].ey)*0.08
    end
    @fpIndex += 1 if @fpIndex < 512
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      @sprites[key].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    for key in @sprites.keys
      @sprites[key].visible = true
    end
  end
end
#===============================================================================
#  New class used to render a custom Sun & Moon styled VS background
#===============================================================================
class SunMoonCrystalBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @disposed = false
    @speed = 1
    @sprites = {}
    @tiles = []
    @data = []
    @fpIndex = 0
    @fpDx = []
    @fpDy = []
    # allows for custom graphics as well
    files = ["Graphics/Transitions/Crystal/background",
             "Graphics/Transitions/Crystal/overlay"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(files[0])
    @sprites["bg"].z = 200
    @sprites["bg"].color = Color.black
    @sprites["bg"].center!(true)
    # creates overlay
    @sprites["overlay"] = Sprite.new(@viewport)
    @sprites["overlay"].bitmap = pbBitmap(files[1])
    @sprites["overlay"].z = 200
    @sprites["overlay"].color = Color.black
    @sprites["overlay"].visible = false
    @sprites["overlay"].opacity = 0
    @sprites["overlay"].toggle = 1
    @sprites["overlay"].center!(true)
    # draws the crystalline shine
    for i in 1..26
      o = i < 10 ? 64 : 128
      @sprites["c#{i}"] = Sprite.new(@viewport)
      bmp = pbBitmap(sprintf("Graphics/Transitions/Crystal/cr%03d",i))
      @sprites["c#{i}"].bitmap = Bitmap.new(bmp.width,bmp.height)
      @sprites["c#{i}"].bitmap.blt(0,0,bmp,bmp.rect,o-rand(64))
      bmp.dispose
      @sprites["c#{i}"].opacity = 0
      @sprites["c#{i}"].toggle = 1
      @sprites["c#{i}"].speed = 1 + rand(4)
      @sprites["c#{i}"].param = 128 - rand(92)
      @sprites["c#{i}"].end_y = rand(32)
      @sprites["c#{i}"].z = 200
      @sprites["c#{i}"].center!(true)
    end
    # loads sparkle particles
    for j in 0...32
      @sprites["s#{j}"] = Sprite.new(@viewport)
      @sprites["s#{j}"].bitmap = pbBitmap("Graphics/Transitions/Crystal/particle")
      @sprites["s#{j}"].ox = @sprites["s#{j}"].bitmap.width/2
      @sprites["s#{j}"].oy = @sprites["s#{j}"].bitmap.height/2
      @sprites["s#{j}"].opacity = 0
      @sprites["s#{j}"].z = 220
      @sprites["s#{j}"].color = Color.black
      @sprites["s#{j}"].visible = false
      @fpDx.push(0)
      @fpDy.push(0)
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    @speed = val
  end
  # updates the background
  def update(skip=false)
    return if self.disposed?
    @speed = 16 if @speed > 16
    # updates overlay
    @sprites["overlay"].opacity += 4*@sprites["overlay"].toggle
    @sprites["overlay"].toggle *= -1 if @sprites["overlay"].opacity <= 0 || @sprites["overlay"].opacity >= 255
    # updates crystal particles
    for i in 1..26
      next if @fpIndex < @sprites["c#{i}"].end_y
      @sprites["c#{i}"].opacity += @sprites["c#{i}"].toggle*@sprites["c#{i}"].speed*(@speed/4)
      @sprites["c#{i}"].toggle *= -1 if @sprites["c#{i}"].opacity <= 0 || @sprites["c#{i}"].opacity >= @sprites["c#{i}"].param
    end
    # updates sparkle particles
    for j in 0...32
      next if !@sprites["s#{j}"] || @sprites["s#{j}"].disposed?
      next if j > @fpIndex/4
      if @sprites["s#{j}"].opacity <= 1
        width = @viewport.width
        height = @viewport.height
        x = rand(width*0.75) + width*0.125
        y = rand(height*0.50) + height*0.25
        @fpDx[j] = x + rand(width*0.125)*(x < width/2 ? -1 : 1)
        @fpDy[j] = y - rand(height*0.25)
        z = [1,0.75,0.5,0.25][rand(4)]
        @sprites["s#{j}"].zoom_x = z
        @sprites["s#{j}"].zoom_y = z
        @sprites["s#{j}"].x = x
        @sprites["s#{j}"].y = y
        @sprites["s#{j}"].opacity = 255
        @sprites["s#{j}"].angle = rand(360)
      end
      @sprites["s#{j}"].x -= (@sprites["s#{j}"].x - @fpDx[j])*0.05
      @sprites["s#{j}"].y -= (@sprites["s#{j}"].y - @fpDy[j])*0.05
      @sprites["s#{j}"].opacity -= @sprites["s#{j}"].opacity*0.05
      @sprites["s#{j}"].zoom_x -= @sprites["s#{j}"].zoom_x*0.05
      @sprites["s#{j}"].zoom_y -= @sprites["s#{j}"].zoom_y*0.05
    end
    @fpIndex += 1 if @fpIndex < 512
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for key in @sprites.keys
      next if key == "bg"
      @sprites[key].color.alpha -= factor
    end
    self.update
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    @sprites["bg"].color.alpha = 0
    @sprites["overlay"].visible = true
    for j in 0...32
      @sprites["s#{j}"].visible = true
    end
  end
end
#===============================================================================
#  New class used to render the Sun & Moon styled VS background
#===============================================================================
class SunMoonSpaceBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @teamskull = teamskull
    @disposed = false
    @speed = 1
    @sprites = {}
    # reverts to default
    files = [
      "Graphics/Transitions/Space/background"
    ]
    # gets specific graphics
    files = checkForTrainerVariant(files, trainerid, @evilteam, @teamskull)
    # creates the background
    @sprites["bg1"] = Sprite.new(@viewport)
    @sprites["bg1"].bitmap = pbBitmap(files[0])
    @sprites["bg1"].color = Color.black
    @sprites["bg1"].z = 200
    @sprites["bg1"].center!(true)
    # creates all the star particles
    for i in 0...64
      @sprites["s#{i}"] = Sprite.new(@viewport)
      @sprites["s#{i}"].bitmap = pbBitmap(sprintf("Graphics/Transitions/Space/star%03d",rand(6)+1))
      @sprites["s#{i}"].center!
      zm = [0.4,0.4,0.5,0.6,0.7][rand(5)]
      @sprites["s#{i}"].zoom_x = zm
      @sprites["s#{i}"].zoom_y = zm
      @sprites["s#{i}"].x = rand(@viewport.width + 1)
      @sprites["s#{i}"].y = rand(@viewport.height + 1)
      o = 85 + rand(130)
      s = 2 + rand(4)
      @sprites["s#{i}"].speed = s
      @sprites["s#{i}"].toggle = 1
      @sprites["s#{i}"].param = o
      @sprites["s#{i}"].opacity = o
      @sprites["s#{i}"].z = 200
      @sprites["s#{i}"].visible = false
    end
    # initializes particles
    @sprites["shine2"] = Sprite.new(@viewport)
    @sprites["shine2"].bitmap = pbBitmap("Graphics/Transitions/Space/shine002")
    @sprites["shine2"].center!(true)
    @sprites["shine2"].z = 200
    @sprites["shine2"].toggle = 1
    @sprites["shine2"].speed = 1
    # initializes particles
    for j in 0...16
      @sprites["p#{j}"] = Sprite.new(@viewport)
      @sprites["p#{j}"].bitmap = pbBitmap("Graphics/Transitions/Space/shine001")
      @sprites["p#{j}"].center!(true)
      @sprites["p#{j}"].z = 200
      x, y = randCircleCord(256)
      p = rand(100)
      @sprites["p#{j}"].end_x = @sprites["p#{j}"].x - 256 + x
      @sprites["p#{j}"].end_y = @sprites["p#{j}"].y - 256 + y
      @sprites["p#{j}"].x -= (@sprites["p#{j}"].x - @sprites["p#{j}"].end_x)*(p/100.0)
      @sprites["p#{j}"].y -= (@sprites["p#{j}"].y - @sprites["p#{j}"].end_y)*(p/100.0)
      @sprites["p#{j}"].speed = 4
      @sprites["p#{j}"].opacity = 255 - 255*(p/100.0)
    end
  end
  # sets the speed of the sprites
  def speed=(val)
    @sprites["shine2"].speed = val/4
  end
  # updates the background
  def update
    return if self.disposed?
    # updates star particles
    for i in 0...64
      @sprites["s#{i}"].opacity += @sprites["s#{i}"].speed*@sprites["s#{i}"].toggle
      if @sprites["s#{i}"].opacity > @sprites["s#{i}"].param || @sprites["s#{i}"].opacity < 10
        @sprites["s#{i}"].toggle *= -1
      end
    end
    # updates particle effect
    for j in 0...16
      if @sprites["p#{j}"].opacity == 0
        @sprites["p#{j}"].opacity = 255
        @sprites["p#{j}"].center!(true)
        x, y = randCircleCord(256)
        @sprites["p#{j}"].end_x = @sprites["p#{j}"].x - 256 + x
        @sprites["p#{j}"].end_y = @sprites["p#{j}"].y - 256 + y
      end
      @sprites["p#{j}"].x -= (@sprites["p#{j}"].x - @sprites["p#{j}"].end_x)*0.01*@sprites["p#{j}"].speed
      @sprites["p#{j}"].y -= (@sprites["p#{j}"].y - @sprites["p#{j}"].end_y)*0.01*@sprites["p#{j}"].speed
      @sprites["p#{j}"].opacity -= 2*@sprites["p#{j}"].speed
    end
    # updates particle effect
    @sprites["shine2"].toggle *= -1 if @sprites["shine2"].zoom_x >= 1.16 || @sprites["shine2"].zoom_x <= 0.84
    @sprites["shine2"].zoom_x += 0.005*@sprites["shine2"].toggle*@sprites["shine2"].speed
    @sprites["shine2"].zoom_y += 0.005*@sprites["shine2"].toggle*@sprites["shine2"].speed
  end
  # used to fade in from black
  def reduceAlpha(factor)
    @sprites["bg1"].color.alpha -= factor
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    for i in 0...64
      @sprites["s#{i}"].visible = true
    end
  end
end
#===============================================================================
#  New class used to render the Sun & Moon styled VS background
#===============================================================================
class SunMoonForestBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @teamskull = teamskull
    @disposed = false
    @speed = 1
    @fpIndex = 0
    @sprites = {}
    # reverts to default
    # reverts to default
    bg = ["Graphics/Transitions/Forest/background",
          "Graphics/Transitions/Forest/overlay",
          "Graphics/Transitions/Forest/glow",
          "Graphics/Transitions/Forest/radial",
          "Graphics/Transitions/Forest/shine",
          "Graphics/Transitions/Forest/ray"
         ]
    # gets specific graphics
    bg = checkForTrainerVariant(bg, trainerid, @evilteam, @teamskull)
    # creates the background
    @sprites["bg1"] = Sprite.new(@viewport)
    @sprites["bg1"].bitmap = pbBitmap(bg[0])
    @sprites["bg1"].color = Color.black
    @sprites["bg1"].z = 200
    @sprites["bg1"].center!(true)
    # creates glow
    @sprites["glow"] = Sprite.new(@viewport)
    @sprites["glow"].bitmap = pbBitmap(bg[2])
    @sprites["glow"].color = Color.black
    @sprites["glow"].toggle = 1
    @sprites["glow"].z = 200
    @sprites["glow"].center!(true)
    # creates spinning element
    @sprites["rad"] = Sprite.new(@viewport)
    @sprites["rad"].bitmap = pbBitmap(bg[3])
    @sprites["rad"].center!(true)
    #@sprites["rad"].color = Color.black
    @sprites["rad"].z = 200
    # creates the overlay
    @sprites["ol1"] = Sprite.new(@viewport)
    @sprites["ol1"].bitmap = pbBitmap(bg[1])
    @sprites["ol1"].z = 202
    @sprites["ol1"].visible = false
    @sprites["ol1"].center!(true)
    # initializes particles
    @sprites["shine"] = Sprite.new(@viewport)
    @sprites["shine"].bitmap = pbBitmap(bg[4])
    @sprites["shine"].center!(true)
    @sprites["shine"].z = 200
    # initializes light rays
    rangle = []
    for i in 0...8; rangle.push((360/8)*i +  15); end
    for j in 0...8
      @sprites["r#{j}"] = Sprite.new(@viewport)
      @sprites["r#{j}"].bitmap = pbBitmap(bg[5])
      @sprites["r#{j}"].ox = 0
      @sprites["r#{j}"].oy = @sprites["r#{j}"].bitmap.height/2
      @sprites["r#{j}"].opacity = 0
      @sprites["r#{j}"].zoom_x = 0
      @sprites["r#{j}"].zoom_y = 0
      @sprites["r#{j}"].x = @viewport.width/2
      @sprites["r#{j}"].y = @viewport.height/2
      a = rand(rangle.length)
      @sprites["r#{j}"].angle = rangle[a]
      @sprites["r#{j}"].z = 200
      @sprites["r#{j}"].visible = false
      rangle.delete_at(a)
    end
  end
  # sets the speed of the sprites
  def speed=(val); end
  # updates the background
  def update
    return if self.disposed?
    # updates the rays
    for j in 0...8
      next if j > @fpIndex/8
      if @sprites["r#{j}"].opacity == 0
        @sprites["r#{j}"].opacity = 255
        @sprites["r#{j}"].zoom_x = 0
        @sprites["r#{j}"].zoom_y = 0
      end
      @sprites["r#{j}"].opacity -= 3
      @sprites["r#{j}"].zoom_x += 0.02
      @sprites["r#{j}"].zoom_y += 0.02
    end
    # updates particle effect
    @sprites["shine"].angle -= 1 if $PokemonSystem.screensize < 2
    # bg animation
    @sprites["rad"].angle += 1 if $PokemonSystem.screensize < 2
    @sprites["glow"].opacity -= @sprites["glow"].toggle
    @sprites["glow"].toggle *= -1 if @sprites["glow"].opacity <= 125 || @sprites["glow"].opacity >= 255
    @fpIndex += 1 if @fpIndex < 256
  end
  # used to fade in from black
  def reduceAlpha(factor)
    @sprites["bg1"].color.alpha -= factor
    @sprites["glow"].color.alpha -= factor
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    @sprites["ol1"].visible = true
    for j in 0...8
      @sprites["r#{j}"].visible = true
    end
    @sprites["shine"].visible = true
  end
end
#===============================================================================
#  New class used to render the Sun & Moon styled VS background
#===============================================================================
class SunMoonWavesBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @teamskull = teamskull
    @disposed = false
    @reveal = false
    @speed = 1
    @sprites = {}
    # reverts to default
    bg = ["Graphics/Transitions/Waves/waves1",
          "Graphics/Transitions/Waves/waves2",
          "Graphics/Transitions/Waves/waves3",
          "Graphics/Transitions/Waves/background"
         ]
    # gets specific graphics
    bg = checkForTrainerVariant(bg, trainerid, @evilteam, @teamskull)
    # create background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(bg[3])
    @sprites["bg"].color = Color.new(0, 0, 0, 160)
    @sprites["bg"].z = 200
    @sprites["bg"].center!(true)
    # creates the 3 wave layers
    for i in 0...3
      @sprites["w#{i}"] = ScrollingSprite.new(@viewport)
      @sprites["w#{i}"].direction = 1 * (i%2 == 0 ? 1 : -1)
      @sprites["w#{i}"].speed = 6 + 4*(i)
      @sprites["w#{i}"].setBitmap(bg[i])
      @sprites["w#{i}"].z = 210
      @sprites["w#{i}"].center!(true)
      @sprites["w#{i}"].color = Color.black
    end
    # create bubbles
    for i in 0...18
      @sprites["b#{i}"] = Sprite.new(@viewport)
      @sprites["b#{i}"].z = 205
      @sprites["b#{i}"].y = -32
    end
  end
  # sets the speed of the sprites
  def speed=(val); end
  # updates the background
  def update
    return if self.disposed?
    for i in 0...3
      @sprites["w#{i}"].update
    end
    return if !@reveal
    for i in 0...18
      if @sprites["b#{i}"].y <= -32
        r = rand(12)
        @sprites["b#{i}"].bitmap = Bitmap.new(16 + r*4, 16 + r*4)
        @sprites["b#{i}"].bitmap.bmp_circle
        @sprites["b#{i}"].center!
        @sprites["b#{i}"].y = @viewport.height + 32
        @sprites["b#{i}"].x = 32 + rand(@viewport.width - 64)
        @sprites["b#{i}"].ex = @sprites["b#{i}"].x
        @sprites["b#{i}"].toggle = rand(2) == 0 ? 1 : -1
        @sprites["b#{i}"].speed = 1 + 10/((r + 1)*0.4)
        @sprites["b#{i}"].opacity = 32 + rand(65)
      end
      min = @viewport.height/4
      max = @viewport.height/2
      scale = (2*Math::PI)/((@sprites["b#{i}"].bitmap.width/64.0)*(max - min) + min)
      @sprites["b#{i}"].y -= @sprites["b#{i}"].speed
      @sprites["b#{i}"].x = @sprites["b#{i}"].ex + @sprites["b#{i}"].bitmap.width*0.25*Math.sin(@sprites["b#{i}"].y*scale)*@sprites["b#{i}"].toggle
    end
  end
  # used to fade in from black
  def reduceAlpha(factor)
    for i in 0...3
      @sprites["w#{i}"].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    @sprites["bg"].color.alpha = 0
    @reveal = true
  end
end
#===============================================================================
#  New class used to render the Sun & Moon styled VS background
#===============================================================================
class SunMoonFlamesBackground
  attr_reader :speed
  # main method to create the background
  def initialize(viewport, trainerid, evilteam = false, teamskull = false)
    @viewport = viewport
    @trainerid = trainerid
    @evilteam = evilteam
    @teamskull = teamskull
    @disposed = false
    @reveal = false
    @speed = 1
    @frame = 0
    @fpIndex = 0
    @sprites = {}
    # reverts to default
    bg = ["Graphics/Transitions/Flames/fire",
          "Graphics/Transitions/Flames/streak",
          "Graphics/Transitions/Flames/background",
          "Graphics/Transitions/Flames/overlay"
         ]
    # gets specific graphics
    bg = checkForTrainerVariant(bg, trainerid, @evilteam, @teamskull)
    # create background layer
    @sprites["bg"] = Sprite.new(@viewport)
    @sprites["bg"].bitmap = pbBitmap(bg[2])
    @sprites["bg"].color = Color.new(0, 0, 0, 160)
    @sprites["bg"].z = 200
    @sprites["bg"].center!(true)
    @sprites["ol"] = Sprite.new(@viewport)
    @sprites["ol"].bitmap = pbBitmap(bg[3])
    @sprites["ol"].color = Color.black
    @sprites["ol"].z = 220
    @sprites["ol"].center!(true)
    # create streak
    @sprites["st"] = Sprite.new(@viewport)
    @sprites["st"].bitmap = pbBitmap(bg[1])
    @sprites["st"].z = 220
    @sprites["st"].visible = false
    @sprites["st"].center!(true)
    # create fire particles
    @amt = @viewport.rect.width/32 + 1
    for k in 0...@amt*2
      i = (@amt*2 - 1) - k
      @sprites["f#{i}"] = Sprite.new(@viewport)
      @sprites["f#{i}"].bitmap = pbBitmap(bg[0])
      @sprites["f#{i}"].src_rect.width /= 4
      @sprites["f#{i}"].src_rect.x = rand(4)*@sprites["f#{i}"].src_rect.width
      @sprites["f#{i}"].ox = @sprites["f#{i}"].src_rect.width/2
      @sprites["f#{i}"].x = 32*(i%@amt)
      @sprites["f#{i}"].y = @viewport.height - 108
      @sprites["f#{i}"].param = rand(@amt*2)
      @sprites["f#{i}"].color = Color.black
      @sprites["f#{i}"].speed = 8
      @sprites["f#{i}"].toggle = 2
      if i >= @amt
        @sprites["f#{i}"].x += 16
        @sprites["f#{i}"].opacity = 164 - rand(33)
        @sprites["f#{i}"].z = 210
      else
        @sprites["f#{i}"].src_rect.height -= 8
        @sprites["f#{i}"].z = 210 - rand(2)
      end
      @sprites["f#{i}"].oy = @sprites["f#{i}"].src_rect.height
      @sprites["f#{i}"].zoom_y = 0.6 + rand(41)/100.0
    end
  end
  # sets the speed of the sprites
  def speed=(val); end
  # updates the background
  def update
    return if self.disposed?
    @sprites["st"].x += 32
    @sprites["st"].x = -@viewport.width if @sprites["st"].x > @viewport.width*8
    # updates fire particles
    @frame += 1
    for i in 0...@amt*2
      next if @frame < 3
      @sprites["f#{i}"].src_rect.x += @sprites["f#{i}"].src_rect.width
      @sprites["f#{i}"].src_rect.x = 0 if @sprites["f#{i}"].src_rect.x >= @sprites["f#{i}"].bitmap.width
      next if @sprites["f#{i}"].param > @fpIndex/2
      @sprites["f#{i}"].color.alpha += @sprites["f#{i}"].toggle*@sprites["f#{i}"].speed if @reveal
      @sprites["f#{i}"].zoom_y += @sprites["f#{i}"].toggle*0.02
      @sprites["f#{i}"].toggle *= -1 if @sprites["f#{i}"].color.alpha <= 0 || @sprites["f#{i}"].color.alpha >= 128
    end
    @frame = 0 if @frame > 2
    @fpIndex += 1 if @fpIndex < 512
    return if !@reveal
 
  end
  # used to fade in from black
  def reduceAlpha(factor)
    @sprites["bg"].color.alpha -= factor
    for i in 0...@amt*2
      @sprites["f#{i}"].color.alpha -= factor
    end
  end
  # disposes of everything
  def dispose
    @disposed = true
    pbDisposeSpriteHash(@sprites)
  end
  # checks if disposed
  def disposed?; return @disposed; end
  # used to show other elements
  def show
    @sprites["bg"].color.alpha = 0
    @sprites["ol"].color.alpha = 0
    @sprites["st"].visible = true
    for i in 0...@amt*2
      c = [
        Color.new(234,202,91,0),
        Color.new(236,177,89,0),
        Color.new(200,56,52,0)
      ]
      @sprites["f#{i}"].color = c[rand(c.length)]
    end
    @reveal = true
  end
end