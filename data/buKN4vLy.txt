const fs = require('fs')
const performance = require('perf_hooks').performance
const eol = require('os').EOL

let startTime = performance.now()
let part1 = part2 = Infinity
let input = fs.readFileSync(__dirname + "/data.txt", 'utf8').split(eol)

const edges = [
    [0, -1],
    [0, 1],
    [-1, 0],
    [1, 0]
]
let start, end
// create a 2d array with all the nodes
let map = input.map((row, y) => {
    return row.split('').map((char, x) => {
        let node = {
            x,
            y,
            visited: false,
            height: char.charCodeAt(0) - 96,
            distance: Infinity
        }
        if (char == 'S')
            node.height = 1, start = node
        if (char == 'E')
            node.height = 26, end = node
        return node
    })
})
// calculate all connected nodes per node
map.map(r => {
    r.map(node => {
        let nodes = []
        for (let edge of edges) {
            if (!map[node.y + edge[1]]) continue
            let n = map[node.y + edge[1]][node.x + edge[0]]
            n && nodes.push(n)
        }
        node.edgeNodes = nodes
    })
})
// reset all nodes
function reset() {
    map.map(r => {
        r.map(n => {
            n.distance = Infinity
            n.visited = false
        })
    })
}
// calculate length of shortest path
function solve(start) {
    start.distance = 0
    let queue = [start]
    while (queue.length) {
        queue.sort((a, b) => b.distance - a.distance)
        let node = queue.pop()
        for (const edge of node.edgeNodes) {
            if (!edge.visited && (edge.height - node.height) < 2) {
                let distance = node.distance + 1
                if (edge.x == end.x && edge.y == end.y && distance < edge.distance) {
                    edge.distance = distance
                    end = edge
                } else {
                    edge.visited = true;
                    edge.distance = Math.min(distance, edge.distance)
                    queue.push(edge)
                }
            }
        }
    }
    return end.distance
}

part1 = solve(start)
map.map(r => {
    reset();
    part2 = Math.min(part2, solve(r[0]))
})
let time = performance.now() - startTime
console.log(`Part 1: ${part1}\nPart 2: ${part2}\nTimer: ${time} ms`)