#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

//#define int long long
#define mp make_pair
#define pb push_back

#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx2")

typedef long long ll;

constexpr int N = (int)1e6+11;
constexpr __int128 INF = (__int128)2e18*(__int128)1e10+111;
constexpr int md = (int)1e9+7;
constexpr int K = (int)60;

void add(int& a,int b){
    a = (a+b >= md ? a+b-md : a+b);
}
void sub(ll& a,ll b){
    a = (a-b < 0 ? a-b+md : a-b);
}

mt19937 rnd(time(nullptr));

struct Line {
    int k;
    __int128 b;

    Line(int k, __int128 b): k(k), b(b) {}

    Line(): k(0), b(INF) {}

    __int128 operator()(__int128 x) {
        return k * x + b;
    }
};

struct LiChaoSegmentTree {
    static const ll T = (1 << 23);

    ll ptr = 2;
//    Line tree[T];
//    ll L[T],R[T];
    struct node{
        Line L;
        node *l = nullptr, *r = nullptr;
        node(){}
        void createL(){
            if(l == nullptr){
                l = new node();
            }
        }
        void createR(){
            if(r == nullptr){
                r = new node();
            }
        }
    };
//    unordered_map<ll,Line> T;

    ll n;
    node* rt;

    void init(ll len) {
        n = len;
//        for(ll i = 0; i < T; i++)
//            L[i] = -1, R[i] = -1;
        rt = new node();
        return;
    }

    void insertLine(node* v, ll l, ll r, Line newLine) {
        bool dominateLeft = (newLine(l) < v->L(l));
        ll mid = (1ll*r + l) / 2;
        bool dominateMid = (newLine(mid) < v->L(mid));
        if (dominateMid) {
            swap(newLine, v->L);
        }
        if (l + 1 == r) {
            return;
        }
        if (dominateLeft == dominateMid) {
            v->createL();
            insertLine(v->l, mid, r, newLine);
        } else {
            v->createR();
            insertLine(v->r, l, mid, newLine);
        }
    }

    void insertLineOnSegment(node* v, ll l, ll r, ll ql, ll qr, Line newLine) {
        if (r <= ql || qr <= l) {
            return;
        }
        if (ql <= l && r <= qr) {
            insertLine(v, l, r, newLine);
            return;
        }
        ll mid = (1ll*r + l) / 2;
        v->createL();
        v->createR();
        insertLineOnSegment(v->l, l, mid, ql, qr, newLine);
        insertLineOnSegment(v->r, mid, r, ql, qr, newLine);
    }

    void insertLineOnSegment(ll ql, ll qr, Line newLine) {
        insertLineOnSegment(rt, 0, n, ql, qr, newLine);
    }

    __int128 getValue(node* v, ll l, ll r, ll pos) {
        __int128 ans = v->L(pos);
        if (l + 1 != r) {
            ll mid = (1ll*r + l) / 2;
            if (pos < mid) {
                v->createL();
                ans = min(ans, getValue(v->l, l, mid, pos));
            } else {
                v->createR();
                ans = min(ans, getValue(v->r, mid, r, pos));
            }
        }
        return ans;
    }

    __int128 getValue(ll pos) {
        return getValue(rt, 0, n, pos);
    }
    void fullDelete(node* v){
        if(v->l != nullptr)
            fullDelete(v->l);
        if(v->r != nullptr)
            fullDelete(v->r);
        delete v;
    }
    void DeleteTree(node* v,ll l,ll r,ll tl,ll tr,node* pr){
        if (r <= tl || tr <= l) {
            return;
        }
        if (tl <= l && r <= tr) {
            if(pr->l == v)
                pr->l = nullptr;
            if(pr->r == v)
                pr->r = nullptr;
            fullDelete(v);
            return;
        }
        ll m = (l+r)>>1;
        if(v->l != nullptr)
            DeleteTree(v->l,l,m,tl,min(tr,m),v);
        if(v->r != nullptr)
            DeleteTree(v->r,m,r,max(tl,m),tr,v);
        return;
    }
    void DeleteTree(ll l,ll r){
        node* pr = nullptr;
        DeleteTree(rt,0,n,l,r,pr);
        return;
    }

} segTree;

void solve(){
    long long n,B,C;
    cin >> n >> B >> C;

    long long x[n+1],p[n+1];
    x[0] = 0;
    for(ll i = 1; i <= n; i++){
        cin >> x[i] >> p[i];
    }

    segTree.init((long long)3e9+10);

    segTree.insertLineOnSegment(0,1,Line(0,0));
    ll last = 0;

    for(ll i = 1; i <= n; i++){
        segTree.DeleteTree(x[i-1],x[i]-1);
        __int128 prVal = segTree.getValue(x[i]);
        if(prVal > B)
            break;
        segTree.insertLineOnSegment(x[i],min((long long)3e9+10,x[i]+C+1),Line(p[i],prVal-p[i]*(x[i])));
        prVal = segTree.getValue(last);
        if(prVal > B)
            continue;
        segTree.insertLineOnSegment(last,min((ll)3e9+10,x[i]+C+1),Line(p[i],prVal-p[i]*(last)));
        last = x[i] + C;
    }

//    for(ll i = 0; i < 10; i++){
//        cout << (long long)segTree.getValue(i) << " ";
//    }
//    cout << "\n";

    long long l = 0, r = (long long)3e9 + 2;
    while(r - l > 1){
        ll m = (l+r)>>1;
        if(segTree.getValue(m) > B)
            r = m;
        else
            l = m;
    }

    cout << l << "\n";

    return;
}

signed main(){
    ios::sync_with_stdio(false); cin.tie(nullptr);cout.tie(nullptr);
//    freopen("input.txt","r",stdin);
//    freopen("output.txt","w",stdout);
    ll tests = 1;
//    cin >> tests;
    for(ll test = 1; test <= tests; test++){
        solve();
    }
    return 0;
}
/**
10 10
0 1 2 3 5 6 7 8 9 11
1 2 3 4 5 6 7 8 9 10
**/
