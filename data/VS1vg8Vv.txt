// psVar10[-1] is the eventual target address for the angle. -1 and 0xFFFF are the same value, meaning no movement.

// more code above

if ((iVar4 == 0) && (((DAT_0072279c & 0x40000000) == 0 || (local_14 != 0x20)))) {
	*psVar10 = 0;
	psVar10[-1] = -1;
}
else {
	uVar5 = DAT_0072279c & 0x40000000;
	if (uVar5 != 0) {
		local_1b = '\x01';
	}
	*psVar10 = local_1b + -1;
	if (((short)(local_1b + -1) < 1) || (((uVar11 & 0x90000000) != 0 && (uVar5 == 0)))) {
		/* Digital mode */
		*psVar10 = 0;
		if ((local_8 & 0xf000) == 0) {
			/* Digital: No input */
			uVar2 = 0xffff;
		}
		else {
			/* Digital: Digital input */
			uVar2 = *(short *)(&DAT_0065089c + ((int)(local_8 & 0xf000) >> 0xc) * 2) + (short)MovementInputCameraCompensation_DAT_006c03a4 & 0xfff;
		}
		psVar10[-1] = uVar2;
	}
	else {
		/* Analogue/Digital mode */
		uVar5 = local_8 & 0xf000;
		if (uVar5 == 0) {
			/* Analogue/Digital: Analogue */
			local_24[0] = (short)((int)((local_18 >> 0x10 & 0xff) - 0x80) / 8 << 8);
			local_20 = (short)((int)((local_18 >> 0x18) - 0x80) / 8 << 8);
			if ((((local_24[0] < -0x7ff) || (0x7ff < local_24[0])) || (local_20 < -0x7ff)) || (0x7ff < local_20)) {
				/* Analogue/Digital: Analogue: Analogue Input */
				sVar1 = MovementAnalogue_FUN_0040b612(local_24);
				sVar1 = sVar1 + (short)MovementInputCameraCompensation_DAT_006c03a4;
			}
			else {
				/* Analogue/Digital: Analogue: No input */
				sVar1 = -1;
			}
			psVar10[-1] = sVar1;
			FUN_0040abca(&local_8,&local_1c);
			uVar11 = DAT_0072279c;
			uVar3 = local_c;
		}
		else {
			/* Analogue/Digital: Digital */
			if (uVar5 == 0) {
				/* Analogue/Digital: Digital: No input */
				uVar2 = 0xffff;
			}
			else {
				/* Analogue/Digital: Digital: Digital input */
				uVar2 = *(short *)(&DAT_0065089c + ((int)uVar5 >> 0xc) * 2) + (short)MovementInputCameraCompensation_DAT_006c03a4 & 0xfff;
			}
			*psVar10 = 0;
			psVar10[-1] = uVar2;
		}
		*(uint *)(psVar10 + 1) = local_18;
		if (((uVar11 & 0x8000000) != 0) && ((DAT_006c03a0 & 0xf000) == 0)) {
			*psVar10 = 0;
			psVar10[-1] = -1;
		}
	}
	_DAT_006c03a8 = _DAT_006c03a8 | 1 << ((byte)local_10 & 0x1f);
}
*psVar10 = 0;
/* Digital override */
if ((local_8 & 0xf000) == 0) {
	/* Digital override: No input */
	uVar2 = 0xffff;
}
else {
	/* Digital override: Digital input */
	uVar2 = *(short *)(&DAT_0065089c + ((int)(local_8 & 0xf000) >> 0xc) * 2) + (short)MovementInputCameraCompensation_DAT_006c03a4 & 0xfff;
}
psVar10[-1] = uVar2;

// more code below