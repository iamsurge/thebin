# Вспомогательная функция для критерия Пирсона(вероятность попадания в интервал (a,b))
def R01Prob(a, b):
    return b - a

# Критерий Пирсона (проверка распределения на равномерность)
def Pearson(x):
    x_var = np.sort(x)
    h = 1 / 30
    x = np.arange(0, 1 + h, h)
    x_exp = np.array([])

    for i in range(1, len(x)):
        N = 0
        for j in range(len(x_var)):
            if x_var[j] >= x[i - 1] and x_var[j] <= x[i]:
                N += 1
        x_exp = np.append(x_exp, N / len(x_var))

    #hi^2
    hi = 0
    for i in range(len(x) - 1):
        hi += ((R01Prob(x[i], x[i + 1]) - x_exp[i]) ** 2) / R01Prob(x[i], x[i + 1])
    return hi

# Метод инверсий (полученное значение должно попасть в интервал (-1.96,1.96))
def InvMeth(x):
    inversion = 0 #inversions

    for i in range(len(x)):
        for j in range(i + 1, len(x)):
            if x[i] >= x[j]:
                inversion += 1
    return (inversion - (len(x) * (len(x) - 1)) / 4) / (np.sqrt((2 * len(x) ** 3 + 3 * len(x) ** 2 - 54) / 72))

# Проверка на независимость (возвращает коэффициент корреляции)
def CheckIndependence(x):
    K = 0
    D = 0
    # mean
    XMean = 0

    for i in range(len(x)):
        XMean += x[i]
    
    XMean /= len(x)
    
    for i in range(len(x)-1):
        K += (x[i] - XMean) * (x[i + 1] - XMean)

    K /= (len(x) - 1)
    
    for i in range(len(x)):
        D += (x[i] - XMean) ** 2
    
    K /= len(x)
    return K/D

R = RStandart(100)

hi = Pearson(R)
InversionMeth = InvMeth(R)
CheckInd = CheckIndependence(R)

print("hi^2 = %.5f" %(hi))
print("Inversion method = %.5f" %(InversionMeth))
print("Independence = %.5f" %(CheckInd))