#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "hash_table.h"

#define SIZE_OF_STRING 64

using namespace std;

class WordNote {
public:
    friend istream &operator>>(istream &stream, WordNote &data) {
        return stream >> data.word_ >> data.number_of_occurrences_;
    }

    friend ostream &operator<<(ostream &stream, const WordNote &data) {
        return stream << data.word_ << " " << data.number_of_occurrences_;
    }

private:
    char word_[SIZE_OF_STRING];
    uint64_t number_of_occurrences_{0};

public:
    WordNote() = default;

    WordNote(const WordNote &other) = default;

    WordNote(WordNote &&other) noexcept = default;

    WordNote &operator=(const WordNote &other) = default;

    WordNote &operator=(WordNote &&other) noexcept = default;

    WordNote(const string &word, uint64_t number_of_occurrences)
            : number_of_occurrences_(number_of_occurrences), word_() {
        memcpy(word_, word.data(), SIZE_OF_STRING - 1);
        word_[SIZE_OF_STRING - 1] = '\0';
    }

    void setWord(const string &word) {
        memcpy(word_, word.data(), SIZE_OF_STRING - 1);
        word_[SIZE_OF_STRING - 1] = '\0';
    }

    string getWord() const {
        return string(word_);
    }

    uint64_t getNumberOfOccurrences() const {
        return number_of_occurrences_;
    }

    void setNumberOfOccurrences(uint64_t numberOfOccurrences) {
        number_of_occurrences_ = numberOfOccurrences;
    }

    static WordNote read(istream &);

    static void write(ostream &, const WordNote &);
};

WordNote WordNote::read(istream &stream) {
    WordNote word{};
    stream.read(reinterpret_cast<char *>(&word), sizeof(word));
    return word;
}

void WordNote::write(ostream &stream, const WordNote &data) {
    stream.write(reinterpret_cast<const char *>(&data), sizeof(data));
}


class FrequencyDictionary {
    string path_;
    fstream data_;
    hash_table<std::string, size_t> map;

public:
    void update(const string &word) {
        if (!data_.is_open()) {
            throw exception("Fail of file");
        }
        data_.seekg(0, ios_base::beg);
        auto result = map.find(word);
        if (result) {
            data_.seekg(result.value(), ios_base::beg);
            WordNote data = WordNote::read(data_);
            if (data.getWord() == word) {
                data.setNumberOfOccurrences(data.getNumberOfOccurrences() + 1);
                data_.seekg(result.value(), ios_base::beg);
                WordNote::write(data_, data);
                data_.seekg(0, ios_base::beg);
            }
        } else {
            data_.seekg(0, ios_base::end);
            auto end = data_.tellg();
            WordNote word_note(word, 1);
            WordNote::write(data_, word_note);
            map.insert(word, static_cast<size_t>(end));
            data_.seekg(0, ios_base::beg);
        }
    }

    void erase(const string &word) {
        if (!data_.is_open()) {
            throw exception("Fail of file");
        }
        data_.seekg(0, ios_base::beg);
        auto start = data_.tellg();
        data_.seekg(0, ios_base::end);
        auto end = data_.tellg();

        data_.seekg(0, ios_base::beg);

        vector<WordNote> new_notes;

        for (; start != end; start += sizeof(WordNote)) {
            data_.seekg(start, ios_base::beg);
            WordNote data = WordNote::read(data_);
            if (data.getWord() != word) {
                new_notes.push_back(data);
            }
        }
        data_.close();
        bind(path_);
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
        for (auto it = new_notes.begin(); it != new_notes.end(); ++it) {
            WordNote::write(data_, *it);
        }
    }

    void bind(const string &file_name) {
        data_.open(file_name, ios_base::binary | ios_base::out | ios_base::in);
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
        data_.seekg(0, ios_base::beg);
        auto start = data_.tellg();
        data_.seekg(0, ios_base::end);
        auto end = data_.tellg();

        data_.seekg(0, ios_base::beg);

        for (; start != end; start += sizeof(WordNote)) {
            data_.seekg(start, ios_base::beg);
            auto current = data_.tellg();
            WordNote data = WordNote::read(data_);
            map.insert(data.getWord(), static_cast<size_t>(current));
        }
        path_ = file_name;
    }

    void clear() {
        data_.close();
        data_.open(path_, ios_base::out);
        data_.close();
        data_.open(path_, ios_base::binary | ios_base::out | ios_base::in);
        map.clear();
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
    }

    void fill(istream &stream) {
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
        clear();
        string word;
        while (stream >> word) {
            update(word);
        }
    }

    string maxWord() {
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
        WordNote max_word_note{};

        data_.seekg(0, ios_base::beg);
        auto start = data_.tellg();
        data_.seekg(0, ios_base::end);
        auto end = data_.tellg();

        data_.seekg(0, ios_base::beg);

        for (; start != end; start += sizeof(WordNote)) {
            data_.seekg(start, ios_base::beg);
            WordNote data = WordNote::read(data_);
            if (data.getNumberOfOccurrences() > max_word_note.getNumberOfOccurrences()) {
                max_word_note = data;
            }
        }
        return max_word_note.getWord();
    }

    void out(ostream &stream, char separator = '\n') {
        if (!data_.is_open()) {
            throw exception("Bad open!");
        }
        data_.seekg(0, ios_base::beg);
        auto start = data_.tellg();
        data_.seekg(0, ios_base::end);
        auto end = data_.tellg();

        data_.seekg(0, ios_base::beg);

        for (; start != end; start += sizeof(WordNote)) {
            data_.seekg(start, ios_base::beg);
            WordNote data = WordNote::read(data_);
            stream << data << separator;
        }
    }
};

void secondTaskRun() {
    FrequencyDictionary frequency_dictionary;
    while (true) {
        try {
            cout << "1) Open file" << endl;
            cout << "2) Update item" << endl;
            cout << "3) Erase item" << endl;
            cout << "4) Most frequently occurring word" << endl;
            cout << "5) Out in console" << endl;
            cout << "6) Out in file" << endl;
            cout << "7) Fill file" << endl;
            cout << "0) Exit" << endl;

            int num_of_operation;
            cin >> num_of_operation;
            if (num_of_operation == 1) {
                cout << "Enter the path:" << endl;
                string path;
                cin >> path;
                frequency_dictionary.bind(path);
            } else if (num_of_operation == 2) {
                cout << "Enter the word:" << endl;
                string word;
                cin >> word;
                frequency_dictionary.update(word);
            } else if (num_of_operation == 3) {
                cout << "Enter the word:" << endl;
                string word;
                cin >> word;
                frequency_dictionary.erase(word);
            } else if (num_of_operation == 4) {
                cout << frequency_dictionary.maxWord() << endl;
            } else if (num_of_operation == 5) {
                frequency_dictionary.out(cout);
            } else if (num_of_operation == 6) {
                cout << "Enter the path:" << endl;
                string path;
                cin >> path;
                ofstream out(path);
                if (!out) {
                    throw exception("Bad open!");
                }
                frequency_dictionary.out(out);
            } else if (num_of_operation == 7) {
                cout << "Enter the path:" << endl;
                string path;
                cin >> path;
                ifstream in(path);
                if (!in) {
                    throw exception("Bad open!");
                }
                frequency_dictionary.fill(in);
            } else {
                return;
            }
        } catch (exception &exception) {
            cout << exception.what() << endl;
        }
    }
}

int main() {
    secondTaskRun();
}