#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
//#define sqrt sqrtl
#define F first
#define S second
#define all(vc666) vc666.begin(), vc666.end()

const ll INF = (ll) 1e9 + 7;
const ll MOD = (ll) 1e9;
ld EPS = 1e-6;
ld PI = 3.1415926535897932384;
mt19937_64 gen(time(0));

struct Vec {
    ld x, y;
    Vec(ld _x = 0, ld _y = 0) {
        x = _x;
        y = _y;
    }
    Vec(Vec a, Vec b) {
        x = b.x - a.x;
        y = b.y - a.y;
    }
};

Vec emp;

int sign(ld res) {
    if (fabs(res) <= EPS) {
        return 0;
    } else if (res > EPS) {
        return 1;
    } else {
        return -1;
    }
}

ld dot(Vec& a, Vec& b) {
    return a.x * b.x + a.y * b.y;
}

ld cross_product(Vec& a, Vec& b) {
    return a.x * b.y - a.y * b.x;
}

ld point_to_point(Vec& a, Vec& b) {
    return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

bool cmp(Vec a, Vec b) {
    if (sign(cross_product(a, b)) == 0) {
        return point_to_point(a, emp) < point_to_point(b, emp);
    } else {
        return sign(cross_product(a, b)) <= 0;
    }
}

bool is_point_in_angle(Vec a1, Vec o1, Vec b1, Vec p1) {
    Vec a(o1, a1);
    Vec b(o1, b1);
    Vec p(o1, p1);
    if (sign(cross_product(b, a)) >= 0) {
        if (sign(cross_product(b, p)) >= 0 && sign(cross_product(p, a)) >= 0) {
            return true;
        } else {
            return false;
        }
    } else {
        if (sign(cross_product(a, p)) >= 0 && sign(cross_product(p, b)) >= 0) {
            return true;
        } else {
            return false;
        }
    }
}

bool is_in_triangle(Vec& a, Vec& b, Vec& c, Vec& p) {
    return is_point_in_angle(a, b, c, p) && is_point_in_angle(b, c, a, p) && is_point_in_angle(c, a, b, p);
}


struct Hull {
    vector<Vec> h;
    Vec st = { INF, INF };
    void build(vector<Vec>& a) {
        for (int i = 0; i < a.size(); i++) {
            if (a[i].x < st.x) {
                st = a[i];
            } else {
                if (a[i].x == st.x && a[i].y < st.y) {
                    st = a[i];
                }
            }
        }
        for (int i = 0; i < a.size(); i++) {
            a[i].x -= st.x;
            a[i].y -= st.y;
        }
        sort(a.begin(), a.end(), cmp);
        a.push_back(a[0]);
        for (int i = 0; i < a.size(); i++) {
            while (h.size() > 1) {
                int j = h.size() - 1;
                Vec f(h[j - 1], h[j]);
                Vec s(h[j], a[i]);
                if (sign(cross_product(f, s)) >= 0) {
                    h.pop_back();
                } else {
                    break;
                }
            }
            h.push_back(a[i]);
        }
        h.pop_back();
        for (int i = 0; i < h.size(); i++) {
            h[i].x += st.x;
            h[i].y += st.y;
        }
    }
    void build2(vector<Vec>& a) {
        h = a;
    }
    ld get_area() {
        ld ans = 0;
        int n = h.size();
        for (int i = 0; i < n; i++) {
            ans += cross_product(h[i], h[(i + 1) % n]);
        }
        return ans / 2.0;
    }
    bool is_point_in_hull(Vec& p) {
        int r = h.size() - 1, l = 1, m;
        if (!is_point_in_angle(h[r], h[0], h[l], p)) {
            return false;
        }
        while (r - l > 1) {
            m = (l + r) / 2;
            if (is_point_in_angle(h[m], h[0], h[l], p)) {
                r = m;
            } else {
                l = m;
            }
        }
        return is_in_triangle(h[r], h[0], h[l], p);
    }
};

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) {
        int n, m, k, i, j, ans = 0;
        cin >> n >> m >> k;
        vector<Vec> a(n);
        for (i = 0; i < n; i++) {
            cin >> a[i].x >> a[i].y;
        }
        Hull b;
        b.build(a);
        Vec p;
        while (m--) {
            cin >> p.x >> p.y;
            if (b.is_point_in_hull(p)) ans++;
        }
        if (ans >= k) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
}
//Deisgned by skimono