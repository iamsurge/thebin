#include<iostream>
#include<algorithm>
#include<vector>
#include<random>
using namespace std;
namespace {
    template<typename T> using V=vector<T>;
    template<typename T1,typename T2=T1> using P=pair<T1,T2>;
    using ll=long long;
    using lll=__int128;
}
constexpr int INF=0x3f3f3f3f;
constexpr ll LINF=(ll)INF<<32|INF;
constexpr ll maxn=1'000'000'000;
struct point{ll x,y;int i;bool islow,isfront;};
mt19937 mt(hash<string>()(":poop:"));
struct node{
    node *l,*r;
    int v; point a,b;
    node(point x,point y):v(mt()),a(x),b(y){
        l=r=nullptr;
        if(a.x>b.x) swap(a,b);
    }
};
node* merge(node* a,node* b){
    if(!a||!b) return a?:b;
    if(a->v<b->v)
        return a->r=merge(a->r,b),a;
    return b->l=merge(a,b->l),b;
}
static inline lll cross(point o,point a,point b){
    return (lll)(a.x-o.x)*(b.y-o.y)-(lll)(a.y-o.y)*(b.x-o.x);
}
void split(node* p,point k,node*& a,node*& b){
    if(!p){a=b=nullptr;return;}
    if(cross(p->a,k,p->b)<0)
        a=p,split(a->r,k,a->r,b);
    else
        b=p,split(b->l,k,a,b->l);
}
node* find_r(node* p){
    if(!p) return nullptr;
    if(p->r) return find_r(p->r);
    return p;
}
node* erase_l(node* p){
    if(p->l) return p->l=erase_l(p->l),p;
    return p->r;
}
void print(node* p){
    if(!p) return;
    print(p->l);
    cerr<<p->a.i<<' ';
    print(p->r);
}
static inline void solve(){
    int n;ll p;cin>>n>>p;
    V<P<point>> seg(n+1);
    V<point> v(2*n+2);
    seg[0]={point{p,maxn+1,0,true,true},point{maxn+1,maxn+2,0,false,false}};
    v[0]=seg[0].first,v[1]=seg[0].second;
    for(int i=1;i<=n;i++){
        auto& [a,b]=seg[i];
        cin>>a.x>>a.y>>b.x>>b.y;
        if(a.y>b.y) swap(a,b);
        a.islow=true,b.islow=false;
        a.isfront=a.x<b.x;
        b.isfront=b.x<a.x;
        a.i=b.i=i;
        v[i<<1]=a,v[i<<1|1]=b;
    }
    sort(v.begin(),v.end(),[](const auto& a,const auto& b){
        if(a.x!=b.x) return a.x<b.x;
        if(a.isfront!=b.isfront) return a.isfront>b.isfront;
        return a.y<b.y;
    });
    V<int> e(n+1,-2);
    node *l,*r,*root=nullptr;
    for(auto& i:v){
        split(root,i,l,r);
        if(i.islow){
            node* ret=find_r(l);
            e[i.i]=ret?ret->a.i:-1;
        }
        if(i.isfront)
            l=merge(l,new node(seg[i.i].first,seg[i.i].second));
        else
            r=erase_l(r);
        root=merge(l,r);
//        cerr<<":",print(root),cerr<<endl;
    }
//    for(auto i:e)
//        cerr<<i<<' ';
//    cerr<<endl;
    int ans=0;
    while(~e[ans]) ans=e[ans];
    cout<<seg[ans].first.x<<endl;
}
int main(){
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    int T=1;
//    cin>>T;
    while(T--)
        solve();
    return 0;
}
