#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define ld long double
#define len(v) (int)v.size()
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define pii pair<int, int>
#define vi vector<int>
#define vii vector<vector<int>>
#define vpii vector<pair<int, int>>
#define ull unsigned long long
//#define int long long
//#define ll ull
const int N = 1e6 + 1;
const int maxn = 310;
const int C = 20;
const int logn = 20;
const int inf = 1e9;
const ll mod = 1e9 + 7;
const int M = 1e9;
const ull M2 = 998244353;
const ld eps = 1e-6;
using namespace std;

// random
std::mt19937_64 gen(std::chrono::steady_clock::now().time_since_epoch().count());

template<class T>
istream &operator>>(istream &in, vector<T> &a) {
    for (auto &i : a)
        in >> i;
    return in;
}

template<class T>
ostream &operator<<(ostream &out, vector<T> &a) {
    for (auto &i : a)
        out << i << ' ';
    return out;
}

int n, m;
vector<string> a(maxn);
int pr[maxn][maxn], pc[maxn][maxn];
bool used[maxn][maxn][4];
bool check1(int i, int j1, int j2) { // j1 ... j2
    if (j2 >= m || j1 < 0) return false;
    return (pr[i][j2] - (j1 > 0 ? pr[i][j1 - 1] : 0)) == 0;
}
bool check2(int j, int i1, int i2) { // i1 .... i2
    if (i2 >= n || i1 < 0) return false;
    return (pc[i2][j] - (i1 > 0 ? pc[i1 - 1][j] : 0)) == 0;
}
bool acc = false;
void dfs(vector<int> v, int len) {
    if (len == 2) {
        cout << "";
    }
    vector<int> t;
    used[v[0]][v[1]][v[2]] = true;
    if (v[1] == m - 1 && v[2] == 0) {
        acc = true;
        return;
    }
    // UP OR DOWN
    if (v[2] == 0) {
        if (v[0] - len + 1 > 0 && check2(v[1], v[0] - len, v[0] - 1) && !used[v[0] - 1][v[1]][v[2]]) {
            t = v;
            t[0]--;
            dfs(t, len);
        }
        if (v[0] + 1 < m && check2(v[1], v[0] - len + 2, v[0] + 1) && !used[v[0] + 1][v[1]][v[2]]) {
            t = v;
            t[0]++;
            dfs(t, len);
        }
    }
    if (v[2] == 2) {
        if (v[0] > 0 && check2(v[1], v[0] - 1, v[0] + len - 2) && !used[v[0] - 1][v[1]][v[2]]) {
            t = v;
            t[0]--;
            dfs(t, len);
        }
        if (v[0] + len < m && check2(v[1], v[0] + 1, v[0] + len) && !used[v[0] + 1][v[1]][v[2]]) {
            t = v;
            t[0]++;
            dfs(t, len);
        }
    }
    if (v[2] == 1) {
        if (v[1] > 0 && check1(v[0], v[1] - 1, v[1] + len - 2) && !used[v[0]][v[1] - 1][v[2]]) {
            t = v;
            t[1]--;
            dfs(t, len);
        }
        if (v[1] + len < m && check1(v[0], v[1] + 1, v[1] + len) && !used[v[0]][v[1] + 1][v[2]]) {
            t = v;
            t[1]++;
            dfs(t, len);
        }
    }
    if (v[2] == 3) {
        if (v[1] - len + 1 > 0 && check1(v[0], v[1] - len, v[1] - 1) && !used[v[0]][v[1] - 1][v[2]]) {
            t = v;
            t[1]--;
            dfs(t, len);
        }
        if (v[1] + 1 < m && check1(v[0], v[1] - len + 2, v[1] + 1) && !used[v[0]][v[1] + 1][v[2]]) {
            t = v;
            t[1]++;
            dfs(t, len);
        }
    }
    // TURN BY ANGLE
    if (v[2] != 0) {
        if (check2(v[1], v[0] - len + 1, v[0]) && !used[v[0]][v[1]][0]) {
            t = v;
            t[2] = 0;
            dfs(t, len);
        }
    }
    if (v[2] != 1) {
        if (check1(v[0], v[1], v[1] + len - 1) && !used[v[0]][v[1]][1]) {
            t = v;
            t[2] = 1;
            dfs(t, len);
        }
    }
    if (v[2] != 2) {
        if (check2(v[1], v[0], v[0] + len - 1) && !used[v[0]][v[1]][2]) {
            t = v;
            t[2] = 2;
            dfs(t, len);
        }
    }
    if (v[2] != 3) {
        if (check1(v[0], v[1] - len + 1, v[1]) && !used[v[0]][v[1]][3]) {
            t = v;
            t[2] = 3;
            dfs(t, len);
        }
    }
    // REVERSE VERTEX
    if (v[2] == 0 && !used[v[0] - len + 1][v[1]][2]) {
        t = v;
        t[0] = v[0] - len + 1;
        t[2] = 2;
        dfs(t, len);
    }
    if (v[2] == 1 && !used[v[0]][v[1] + len - 1][3]) {
        t = v;
        t[1] = v[1] + len - 1;
        t[2] = 3;
        dfs(t, len);
    }
    if (v[2] == 2 && !used[v[0] + len - 1][v[1]][0]) {
        t = v;
        t[0] = v[0] + len - 1;
        t[2] = 0;
        dfs(t, len);
    }
    if (v[2] == 3 && !used[v[0]][v[1] - len + 1][1]) {
        t = v;
        t[1] = v[1] - len + 1;
        t[2] = 1;
        dfs(t, len);
    }

}

void solve() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }

    for (int i = 0; i < n; ++i) {
        pr[i][0] = (a[i][0] == '#');
        for (int j = 1; j < m; ++j) {
            pr[i][j] = pr[i][j - 1];
            if (a[i][j] == '#')
                pr[i][j]++;
        }
    }
    for (int j = 0; j < m; ++j) {
        pc[0][j] = (a[0][j] == '#');
        for (int i = 1; i < n; ++i) {
            pc[i][j] = pc[i - 1][j];
            if (a[i][j] == '#')
                pc[i][j]++;
        }
    }

    int l = 0;
    int r = n + 1;
    while (l + 1 < r) {
        for (int i = 0; i < maxn; ++i) {
            for (int j = 0; j < maxn; ++j) {
                for (int k = 0; k < 4; ++k)
                    used[i][j][k] = false;
            }
        }
        int mid = (l + r) / 2;
        acc = false;
        vi v = {-1, 0, 0};
        for (int i = mid - 1; i < n; ++i) {
            if (!check2(0, i - mid + 1, i)) continue;
            v[0] = i;
            dfs(v, mid);
        }
        if (acc) l = mid;
        else r = mid;
    }
    cout << l;

}


signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int T = 1;
    //cin >> T;
    while (T--) {
        solve();
    }
}