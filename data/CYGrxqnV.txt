////////////////////////////////////////////////////////////////////////////////////////////////////////
// GOOGLE DRIVE: https://drive.google.com/drive/folders/1eNXlQ50LanvYKPj_qr-Qr2qJmPa2o_Ze?usp=sharing //
////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////
//            Graph.h            //
///////////////////////////////////

#pragma once
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <utility>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;

const int INF = 1e9 + 7;

/// <summary>
/// Граф 
/// </summary>
/// <typeparam name="Vertice"> тип вершин графа </typeparam>
/// <typeparam name="Weight"> тип ребер графа (int по умолчанию) </typeparam>
template <class Vertice, class Weight = int>
class Graph
{
	/// <summary>
	/// Количество вершин и ребер в графе
	/// </summary>
	int _N = 0, _M = 0;

	/// <summary>
	/// Критерий ориентированности и взвешенности графа 
	/// </summary>
	bool IsDirected = false, IsWeighted = false;

	/// <summary>
	/// Список смежности графа 
	/// </summary>
	map <Vertice, map<Vertice, Weight>> graph;

public:

	/// <summary>
	/// Конструктор по умолчанию
	/// </summary>
	Graph() {};

	/// <summary>
	/// Конструктор, создающий пустой граф, определяющий 
	/// ориентированность и взвешенность графа 
	/// </summary>
	/// <param name="direction"> критерий ориентированности </param>
	/// <param name="weighting"> критерий взвешенности </param>
	Graph(string direction, string weighting)
	{
		if (direction == "directed") IsDirected = true;
		if (weighting == "weighted") IsWeighted = true;
	}

	/// <summary>
	/// Конструктор, считывающий информацию из файла 
	/// или из консоли (stdin)
	/// </summary>
	/// <param name="filePath"> путь к файлу или ключевое слово stdin </param>
	Graph(string filePath)
	{
		ifstream fin;

		if (filePath == "stdin") fin = ifstream(stdin);
		else fin = ifstream(filePath);

		string cmd, direction, weighting;
		fin >> cmd >> direction >> weighting;

		*this = Graph(direction, weighting);

		fin >> cmd >> _N;

		for (int i = 0; i < _N; ++i)
		{
			Vertice v; fin >> v;
			graph.insert(pair<Vertice, map<Vertice, Weight>>(v, map<Vertice, Weight>()));
		}

		fin >> cmd >> _M;

		for (int i = 0; i < _M; ++i)
		{
			Vertice u, v; Weight w; fin >> u >> v;

			if (!IsWeighted) w = 1;
			else fin >> w;

			graph[u].insert(pair<Vertice, Weight>(v, w));
			if (!IsDirected) graph[v].insert(pair<Vertice, Weight>(u, w));
		}

		if (filePath != "stdin") fin.close();
	}

	/// <summary>
	/// Количество вершин графа 
	/// </summary>
	/// <returns> количество вершин графа </returns>
	int n() { return _N; }

	/// <summary>
	/// Количество ребер графа 
	/// </summary>
	/// <returns> количество ребер графа </returns>
	int m() { return _M; }

	/// <summary>
	/// Метод, выдающий информацию об
	/// ориентированности графа
	/// </summary>
	/// <returns> true, если граф ориентированный, иначе - false </returns>
	bool isDirected() { return IsDirected; }

	/// <summary>
	/// Метод, выдающий информацию о
	/// взвешенности графа 
	/// </summary>
	/// <returns> true, если граф взвешенный, иначе - false </returns>
	bool isWeighted() { return IsWeighted; }

	/// <summary>
	/// Метод, возращающий список смежности графа
	/// </summary>
	/// <returns> список смежности графа </returns>
	map<Vertice, map<Vertice, Weight>> edges() { return graph; }

	/// <summary>
	/// Добавление вершины в граф 
	/// </summary>
	/// <param name="v"> добавляемая в граф вершина </param>
	void addVertice(Vertice v)
	{
		try
		{
			if (graph.find(v) != graph.end()) throw "Добавление вершины: заданная вершина уже есть в графе";
			else
			{
				++_N;
				graph.insert(pair<Vertice, map<Vertice, Weight>>(v, map<Vertice, Weight>()));
			}
		}
		catch (const char* msg)
		{
			cout << msg << "\n";
		}
	}

	/// <summary>
	/// Удаление вершины из графа 
	/// </summary>
	/// <param name="v"> удаляемая из графа вершина </param>
	void removeVertice(Vertice v)
	{
		try
		{
			if (graph.find(v) == graph.end()) throw "Удаление вершины: в графе отсутствует заданная вершина";
			else
			{
				--_N; _M -= graph[v].size();

				graph.erase(v);

				for (auto p : graph)
					if (graph[p.first].find(v) != graph[p.first].end())
					{
						if (IsDirected) --_M;
						graph[p.first].erase(v);
					}
			}
		}
		catch (const char* msg)
		{
			cout << msg << "\n";
		}
	}

	/// <summary>
	/// Добавление ребра в граф 
	/// </summary>
	/// <param name="u"> первая вершина ребра </param>
	/// <param name="v"> вторая вершина ребра </param>
	/// <param name="w"> вес ребра (для невзвешенных графов w = 1) </param>
	void addEdge(Vertice u, Vertice v, Weight w)
	{
		try
		{
			if (graph.find(u) == graph.end() || graph.find(v) == graph.end()) throw "Добавление ребра: в графе отсутствует(ют) заданная(ые) вершина(ы)";
			else if (!IsDirected && u == v) throw "Добавление ребра: невозможно добавить петлю в неориентированный граф";
			else if (graph[u].find(v) != graph[u].end()) throw "Добавление ребра: заданное ребро уже есть в графе";
			else
			{
				++_M;
				graph[u][v] = w;
				if (!IsDirected) graph[v][u] = w;
			}
		}
		catch (const char* msg)
		{
			cout << msg << "\n";
		}
	}

	/// <summary>
	/// Удаление ребра из графа 
	/// </summary>
	/// <param name="u"> первая вершина ребра </param>
	/// <param name="v"> вторая вершина ребра </param>
	void removeEdge(Vertice u, Vertice v)
	{
		try
		{
			if (graph.find(u) == graph.end() || graph.find(v) == graph.end()) throw "Удаление ребра: в графе отсутствует(ют) заданная(ые) вершина(ы)";
			else
			{
				if (graph[u].find(v) == graph[u].end()) throw "Удаление ребра: в графе отсутствует заданное ребро";
				else
				{
					--_M;
					graph[u].erase(v);
					if (!IsDirected) graph[v].erase(u);
				}
			}
		}
		catch (const char* msg)
		{
			cout << msg << "\n";
		}
	}

	/// <summary>
	/// Очищение графа (ориентированность 
	/// и взвешенность остаются прежними)
	/// </summary>
	void clear()
	{
		_N = 0; _M = 0;
		graph.clear();
	}

	/// <summary>
	/// Вывод информации о графе в файл или
	/// на консоль (stdout)
	/// </summary>
	/// <param name="filePath"> путь к файлу или ключевое слово stdout </param>
	void print(string filePath)
	{
		ofstream fout;

		if (filePath == "stdout") fout = ofstream(stdout);
		else fout = ofstream(filePath);

		if (filePath != "stdout")
		{
			fout << "GRAPH ";

			if (IsDirected) fout << "directed ";
			else fout << "undirected ";

			if (IsWeighted) fout << "weighted\n";
			else fout << "unweighted\n";

			fout << "VERTICES: " << _N << "\n";

			for (auto p : graph)
				fout << p.first << "\n";

			fout << "EDGES: " << _M << "\n";

			for (auto p1 : graph)
			{
				Vertice u = p1.first;

				for (auto p2 : p1.second)
				{
					Vertice v = p2.first; Weight w = p2.second;

					if (IsDirected || u < v)
					{
						fout << u << " " << v << " ";
						if (IsWeighted) fout << w;
						fout << "\n";
					}
				}
			}

			fout.close();
		}
		else
		{
			fout << "GRAPH ";

			if (IsDirected) fout << "directed ";
			else fout << "undirected ";

			if (IsWeighted) fout << "weighted\n";
			else fout << "unweighted\n";

			fout << "VERTICES: " << _N << "\n";

			for (auto p : graph)
				fout << p.first << "\n";

			fout << "EDGES: " << _M << "\n";

			for (auto p1 : graph)
			{
				Vertice u = p1.first;

				fout << u << ": ";

				for (auto p2 : p1.second)
				{
					Vertice v = p2.first; Weight w = p2.second;

					if (!IsWeighted) fout << v << " ";
					else fout << "(" << v << ", " << w << ") ";
				}

				fout << "\n";
			}
		}
	}
};

template <class Weight>
struct Edge
{
	Weight f, c; // поток и пропускная способность

	Edge() {}
	Edge(Weight c) : f(0), c(c) {}; 
};

template <class Vertice, class Weight>
Weight DFS(map<Vertice, map<Vertice, Edge<Weight>>>& edges, map<Vertice, bool> &used, Vertice u, Vertice t, Weight c, Weight B)
{
	used[u] = true;

	if (u == t) return c;

	for (auto p : edges[u])
	{
		Vertice v = p.first;
		Edge<Weight> e = p.second;

		if (!used[v] && (e.c - e.f) >= B)
		{
			Weight r = DFS(edges, used, v, t, min(c, e.c - e.f), B);

			if (r > 0)
			{
				edges[u][v].f += r; // r (литров) жижи течет по ребру u->v
				edges[v][u].f -= r; // -r (литров) жижи течет по обратному ребру v->u

				return r;
			}
		}
	}

	return 0;
}

template <class Vertice, class Weight>
void FordFalkerson(Graph <Vertice, Weight>& g, Vertice s, Vertice t)
{
	map <Vertice, map<Vertice, Weight>> _edges = g.edges();
	map <Vertice, map<Vertice, Edge<Weight>>> edges;

	for (auto p1 : _edges)
	{
		Vertice u = p1.first;
		edges[u] = map<Vertice, Edge<Weight>>();

		for (auto p2 : _edges[u])
		{
			Vertice v = p2.first;
			Weight c = p2.second;

			edges[u][v] = Edge<Weight>(c);
		}
	}

	int B = 1ll << 30; // 2^30

	for (; B > 0; B /= 2)
	{
		while (true)
		{
			map <Vertice, bool> used;
			for (auto p : edges) used[p.first] = false;

			Weight r = DFS(edges, used, s, t, INF, B);

			if (r == 0) break;
		}
	}

	Weight max_flow = 0;

	for (auto p : edges[s])
	{
		Edge<Weight> e = p.second;
		max_flow += e.f;
	}

	cout << "Максимальный поток равен: " << max_flow << "\n";

	for (auto p : edges)
	{
		Vertice s = p.first;

		cout << s << ": ";

		for (auto p : edges[s])
		{
			Vertice v = p.first;
			Edge<Weight> e = p.second;

			if (e.f > 0) cout << "(" << v << ", " << e.f << ") ";
		}

		cout << "\n";
	}
}

//////////////////////////////////////////////
//            ConsoleInterface.h            //
//////////////////////////////////////////////

#pragma once
#include "Graph.h"
#include <vector>
#include <string>

/// <summary>
/// Консольный интерфейс, работающий с одним графом 
/// </summary>
/// <typeparam name="Vertice"> тип вершин графа </typeparam>
/// <typeparam name="Weight"> тип ребер графа </typeparam>
template <class Vertice, class Weight = int>
class ConsoleInterface
{
	/// <summary>
	/// Граф 
	/// </summary>
	Graph<Vertice, Weight> g;

	/// <summary>
	/// Вывод на консоль списка доступных команд
	/// </summary>
	void Hint()
	{
		cout << "+---------------------------------------+\n";
		cout << "|             СПИСОК КОМАНД             |\n";
		cout << "+---------------------------------------+\n";
		cout << "|  1. CREATE GRAPH direction weighting  |\n";
		cout << "|  2. CREATE GRAPH filePath             |\n";
		cout << "|  3. ADD VERTICE v                     |\n";
		cout << "|  4. REMOVE VERTICE v                  |\n";
		cout << "|  5. ADD EDGE u v [w]                  |\n";
		cout << "|  6. REMOVE EDGE u w                   |\n";
		cout << "|  7. CLEAR GRAPH                       |\n";
		cout << "|  8. PRINT GRAPH filePath              |\n";
		cout << "|  9. MAX FLOW s t                      |\n";
		cout << "|  10. GET HINT                         |\n";
		cout << "|  11. EXIT                             |\n";
		cout << "+---------------------------------------+\n";
	}

public:

	/// <summary>
	/// Конструктор по умолчанию
	/// </summary>
	ConsoleInterface() {};

	/// <summary>
	/// Запуск интерфейса
	/// </summary>
	void Start()
	{
		Hint();

		while (true)
		{
			cout << ">> ";

			string w1; cin >> w1;

			if (w1 == "CREATE")
			{
				string w2, w3; cin >> w2 >> w3;

				if (w3 == "directed" || w3 == "undirected")
				{
					string w4; cin >> w4;
					g = Graph<Vertice, Weight>(w3, w4);
				}
				else g = Graph<Vertice, Weight>(w3);
			}
			else if (w1 == "ADD")
			{
				string w2; cin >> w2;

				if (w2 == "VERTICE")
				{
					Vertice w3; cin >> w3;
					g.addVertice(w3);
				}
				else
				{
					Vertice w3, w4; Weight w5; cin >> w3 >> w4;

					if (!g.isWeighted()) w5 = 1;
					else cin >> w5;

					g.addEdge(w3, w4, w5);
				}
			}
			else if (w1 == "REMOVE")
			{
				string w2; cin >> w2;

				if (w2 == "VERTICE")
				{
					Vertice w3; cin >> w3;
					g.removeVertice(w3);
				}
				else
				{
					Vertice w3, w4; cin >> w3 >> w4;
					g.removeEdge(w3, w4);
				}
			}
			else if (w1 == "CLEAR")
			{
				string w2; cin >> w2;
				g.clear();
			}
			else if (w1 == "PRINT")
			{
				string w2, w3; cin >> w2 >> w3;
				g.print(w3);
			}
			else if (w1 == "MAX")
			{
				string w2; cin >> w2;
				Vertice w3, w4; cin >> w3 >> w4;

				FordFalkerson(g, w3, w4);
			}
			else if (w1 == "GET")
			{
				string w2; cin >> w2;
				Hint();
			}
			else if (w1 == "EXIT")
			{
				break;
			}
		}
	}
};

/////////////////////////////////////
//            Graph.cpp            //
/////////////////////////////////////

#include "ConsoleInterface.h"
#include <Windows.h>

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	ConsoleInterface<int, int> consoleInterface;
	consoleInterface.Start();

	return 0;
}