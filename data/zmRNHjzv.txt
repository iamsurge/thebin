using System;
using System.Linq;
using System.Text;
using System.IO;

namespace CW_RC5
{
    public class RC5CryptoManager
    {
        public bool IsPassPhraseCorrect = false;
        private readonly int w = 64;
        private readonly int R = 16;

        private const UInt64 Pw = 0xB7E151628AED2A6B;
        private const UInt64 Qw = 0x9E3779B97F4A7C15;

        private UInt64[] L;
        private UInt64[] S;
        private int t;
        private int b;
        private int u;
        private int c;                                       

        public void GenerateKey (byte[] key)
        {
            u = w >> 3;
            b = key.Length;
            c = b % u > 0 ? b / u + 1 : b / u;
            KeyToWords(key);
            ExtendKey();
            Mixing();
        }
        public void KeyToWords(byte[] key)
        {
            int i;
            L = new UInt64[c];

            for (i = b - 1; i >= 0; i--)
            {
                L[i / u] = ROL(L[i / u], 8) + key[i];
            }
        }
        public void ExtendKey()
        {
            int i;
            t = 2 * (R + 1);
            S = new UInt64[t];
            S[0] = Pw;
            for (i = 1; i < t; i++)
            {
                S[i] = S[i - 1] + Qw;
            }
        }
        public void Mixing()
        {
            UInt64 x, y;
            int i, j, n;
            x = y = 0;
            i = j = 0;
            n = 3 * Math.Max(t, c);

            for (int k = 0; k < n; k++)
            {
                x = S[i] = ROL((S[i] + x + y), 3);
                y = L[j] = ROL((L[j] + x + y), (int)(x + y));
                i = (i + 1) % t;
                j = (j + 1) % c;
            }
        }

        private UInt64 ROL(UInt64 a, int offset)
        {
            UInt64 r1, r2;
            r1 = a << offset;
            r2 = a >> (w - offset);
            return (r1 | r2);

        }

        
        private UInt64 ROR(UInt64 a, int offset)
        {
            UInt64 r1, r2;
            r1 = a >> offset;
            r2 = a << (w - offset);
            return (r1 | r2);

        }

        
        private static UInt64 BytesToUInt64(byte[] b, int p)
        {
            UInt64 r = 0;
            for (int i = p + 7; i > p; i--)
            {
                r |= (UInt64)b[i];
                r <<= 8;
            }
            r |= (UInt64)b[p];
            return r;
        }

       
        private static void UInt64ToBytes(UInt64 a, byte[] b, int p)
        {
            for (int i = 0; i < 7; i++)
            {
                b[p + i] = (byte)(a & 0xFF);
                a >>= 8;
            }
            b[p + 7] = (byte)(a & 0xFF);
        }

        
        public byte[] EncryptBlock(byte[] inBuf)
        {
            UInt64 a = BytesToUInt64(inBuf, 0);
            UInt64 b = BytesToUInt64(inBuf, 8);

            a = a + S[0];
            b = b + S[1];

            for (int i = 1; i < R + 1; i++)
            {
                a = ROL((a ^ b), (int)b) + S[2 * i];
                b = ROL((b ^ a), (int)a) + S[2 * i + 1];
            }
            byte[] outBuf = new byte[16];
            UInt64ToBytes(a, outBuf, 0);
            UInt64ToBytes(b, outBuf, 8);
            return outBuf;
        }

        
        public byte[] DecryptBlock(byte[] inBuf)
        {
            UInt64 a = BytesToUInt64(inBuf, 0);
            UInt64 b = BytesToUInt64(inBuf, 8);

            for (int i = R; i > 0; i--)
            {
                b = ROR((b - S[2 * i + 1]), (int)a) ^ a;
                a = ROR((a - S[2 * i]), (int)b) ^ b;
            }

            b = b - S[1];
            a = a - S[0];

            byte[] outBuf = new byte[16];
            UInt64ToBytes(a, outBuf, 0);
            UInt64ToBytes(b, outBuf, 8);
            return outBuf;
        }
        public byte[] Decrypt(byte[] data, string password)
        {
            // set extract key to private field key
            byte[] key = Encoding.Unicode.GetBytes(password);
            GenerateKey(key);
           
            byte[] datakey = new byte[key.Length];
            data = AlignArray(data, 16);
            byte[] res = new byte[data.Length];
            byte[] input = new byte[16];

            for (int i = 0; i < data.Length / 16; i++)
            {
                Array.Copy(data, i * 16, input, 0, 16);
                Array.Copy(DecryptBlock(input), 0, res, i * 16, 16);
            }
            Array.Copy(res, 0, datakey, 0, key.Length);
            byte[] result = new byte[res.Length - key.Length];
            Array.Copy(res, key.Length, result, 0, res.Length - key.Length);

            IsPassPhraseCorrect = datakey.SequenceEqual(key);

            return result;
        }

        public byte[] Encrypt(byte[] data, string password)
        {
            byte[] key = Encoding.Unicode.GetBytes(password);
            GenerateKey(key);
            byte[] buf;
            using (var mstream = new MemoryStream())
            using (var writer = new BinaryWriter(mstream))
            {
                writer.Write(key);
                writer.Write(data);
                buf = AlignArray(mstream.ToArray(), 16);
                //buf = mstream.ToArray();
            }


            //byte[] buf = AlignArray(DataWithKey(data, password), 16);
            byte[] res = new byte[buf.Length];
            byte[] input = new byte[16];

            for (int i = 0; i < buf.Length / 16; i++)
            {
                Array.Copy(buf, i * 16, input, 0, 16);
                Array.Copy(EncryptBlock(input), 0, res, i * 16, 16);
            }
            return res;
        }

        public byte[] AlignArray(byte[] bytes, int m)
        {

            byte[] buf;
            int padding = (int)(bytes.Length % m);
            if (padding != 0)
            {
                padding = m - padding;
                buf = new byte[padding + bytes.Length];
                Array.Copy(bytes, 0, buf, 0, bytes.Length);
                return buf;
            }
            return bytes;

        }
        public byte[] DataWithKey(byte[] data, string pass)
        {
            byte[] key = Encoding.Unicode.GetBytes(pass);
            byte[] data_with_key = new byte[data.Length + key.Length];
            Array.Copy(key, 0, data_with_key, 0, key.Length);
            Array.Copy(data, 0, data_with_key, key.Length, data.Length);
            return data_with_key;
        }
        public bool[] CheckPasswordPhrase(string key, bool includeDigit, bool includeLowerCase, bool includeUpperCase, bool includeSpecChar)
        {
            bool[] res = new bool[4];

            res[0] = !includeDigit || key.Any(ch => !char.IsDigit(ch));
            res[1] = !includeLowerCase || key.Any(ch => !char.IsLower(ch));
            res[2] = !includeUpperCase || key.Any(ch => !char.IsUpper(ch));
            res[3] = !includeSpecChar || key.Any(ch => !char.IsLetterOrDigit(ch));

            if (res[0] && res[1] && res[2] && res[3]) return null;
            return res;
        }
    }
}