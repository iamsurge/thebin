#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

#define int long long
#define pb push_back
#define mp make_pair

#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("avx2")

constexpr int N = (int)1e5 + 111;
//constexpr int md = (int)998244353;
constexpr long long INF = (long long)1e18 + 11231;
constexpr int K = (int)80;

//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());
//
//int bpow(int a,int b,int m){
//    if(b == 0)
//        return 1;
//    if(b % 2 == 0){
//        int t = bpow(a,b>>1,m);
//        return (t*t)%m;
//    }
//    return a * bpow(a,b-1,m) % m;
//}

vector<int> g[N];
int sz[N];
int c[N];
int l[N],r[N];
int heavy[N];

void dfs1(int v){
    sz[v] = 1;
    heavy[v] = -1;
    for(auto& to : g[v]){
        dfs1(to);
        if(heavy[v] == -1 || sz[to] > sz[heavy[v]])
            heavy[v] = to;
        sz[v] += sz[to];
    }
    return;
}

int ans = 0;
int cnt[N];
int S[N];
bool can = true;

void dfs(int v,set<pair<int,pair<int,int>>>& st){
    if(!can)
        return;
    if(heavy[v] == -1){
        cnt[v] += l[v];
        ans += l[v] * c[v];
        S[v] = l[v];
        if(r[v] - l[v] > 0)
            st.insert(mp(c[v],mp(r[v]-l[v],v)));
//        cerr << "leaf " << v << " " << cnt[v] << "\n";
        return;
    }
    dfs(heavy[v],st);
    S[v] += S[heavy[v]];
    for(auto& to : g[v]){
        if(to == heavy[v])
            continue;
        set<pair<int,pair<int,int>>> nw;
        dfs(to,nw);
        S[v] += S[to];
        if(nw.size() > st.size())
            swap(nw,st);
        for(auto& x : nw)
            st.insert(x);
    }
    if(S[v] > r[v]){
        can = false;
        return;
    }
    int need = l[v] - S[v];
    st.insert(mp(c[v],mp(r[v],v)));
    while(need > 0 && !st.empty()){
        int val = st.begin()->first, cur_cnt = st.begin()->second.first, id = st.begin()->second.second;
        st.erase(st.begin());
        int t = min(need,cur_cnt);
        cur_cnt -= t;
        cnt[id] += t;
        need -= t;
        ans += t * val;
        if(cur_cnt > 0)
            st.insert(mp(val,mp(cur_cnt,id)));
    }
    S[v] = max(S[v],l[v]);
    int bon = r[v] - S[v];
    int cnt = 0;
    set<pair<int,pair<int,int>>> nw;
    int cur_S = 0;
    for(auto& cv : st){
        int x = cv.first, y = cv.second.first, id = cv.second.second;
        int t = min(bon,y);
        bon -= t;
        y = t;
        cur_S += y;
        if(y > 0)
            nw.insert(mp(x,mp(y,id)));
        if(bon == 0)
            break;
        cnt++;
    }
    swap(st,nw);
    assert(bon == 0);

    return;
}

void solve(){
    int n;
    cin >> n;

    ans = 0;
    can = true;
    for(int i = 1; i <= n; i++){
        g[i].clear();
        cnt[i] = 0;
        sz[i] = 0;
        heavy[i] = 0;
        l[i] = r[i] = c[i] = 0;
        S[i] = 0;
    }

    for(int i = 2; i <= n; i++){
        int p;
        cin >> p;
        g[p].pb(i);
    }

    for(int i = 1; i <= n; i++){
        cin >> c[i];
    }
    for(int i = 1; i <= n; i++){
        cin >> l[i] >> r[i];
    }

    dfs1(1);

    set<pair<int,pair<int,int>>> st;
    dfs(1,st);
    if(can == false){
        cout << "-1\n";
        return;
    }

    cout << ans << "\n";
    for(int i = 1; i <= n; i++)
        cout << cnt[i] << " ";
    cout << "\n";

    return;
}

signed main(){
    ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
//    freopen("output.txt","w",stdout);
//    init();
    int tests = 1;
    cin >> tests;
    for(int test = 1; test <= tests; test++){
//        cout << "Case #" << test << ": ";
        solve();
    }
    return 0;
}
/**

void dfs(int v,set<pair<int,int>>& st){
    dfs(heavy[v],st);

    for(auto& to : g[v]){
        if(to == heavy[v]) continue;
        set<pair<int,int>> nw;
        dfs(to,nw);
        if(nw.size() > st.size())
            swap(nw,st);
        for(auto& x : nw)
            st.insert(x);
    }
}

**/
