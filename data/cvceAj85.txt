import axios from 'axios';
import { useState, useEffect, useMemo, useRef } from 'react';
import * as React from 'react';
import MaterialTable from 'material-table-formik';
import useStyles from './welcomeStyles/styles';
import { Card, CardContent, Paper, TextField } from '@material-ui/core';
import * as yup from 'yup';
import { useAuthContext } from '@asgardeo/auth-react';
import { AppConfig } from '../config';

import {
  checkIfRoleExists,
  financeRole,
  superAdminRole
} from '../containers/Roles';
import { useUserContext } from '../contexts/UserContext';
import { tableIcons } from './TableIcons/tableIcons';
import StatusSnackbar from './cc/StatusSnackbar';
import { AuthContext } from '../contexts/AuthContext';

const FORM_VALIDATION = yup.object().shape({
  // id:yup.string().required('Required'),
  cc_provider_code: yup.string().required('Required'),
  cc_number: yup
    .string('Please Enter a valid code')
    //.matches(/\d{3}[-]?\d{4}/, 'GL Code is not valid')
    .required('Required'),
  employee_email: yup.string().email('Invalid Email.').required('Required'),
  entity: yup.string().required(),
  status: yup.string('Please Enter a valid status').required('Required'),
  comment: yup.string('Please Enter a valid comment').notRequired().nullable(),
  // added_by: yup
  // .string('Please Enter a valid word')
  // .email('Invalid Email.')
  // .required('Required'),
  // updated_by: yup.string('Please Enter a valid word').email('Invalid Email .'),
  lead_email: yup.string().email('Invalid Email').required('Required')
});

export default function DataGridDemo() {
  const tableRef = useRef();
  var classes = useStyles();
  const { email } = useUserContext();
  const { id, setId, CheckIdToken, HandleRefreshToken } =
    React.useContext(AuthContext);

  const [data, setData] = useState([]);
  const [departments, setDep] = useState({});
  const [AccStatus, setAccstatus] = useState({});
  const [CcStatus, setCcstatus] = useState({});
  const [CcProvider, setCcProvider] = useState({});

  //snackbar
  const [snackbarStatus, setSnackbarStatus] = useState('');
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const { signOut } = useAuthContext();

  const [isloading, setIsLoading] = useState(false);

  useEffect(() => {
    getData(getDataUrl);
  }, []);

  //crud end point urls

  let getDataUrl = AppConfig.baseUrl + AppConfig.allCCEndpoint;
  let createDataUrl = AppConfig.baseUrl + AppConfig.newCCEndpoint;
  let updateDataUrl = AppConfig.baseUrl + AppConfig.updateCCEndpoint;
  let deleteDataUrl = AppConfig.baseUrl + AppConfig.deleteCCEndpoint;
  let leadChangedPendingUpdateUrl =
    AppConfig.baseUrl + AppConfig.leadChangedPendingCc;

  //Fuction to handle snackbars based on error status codesS
  const HandleError = (status) => {
    if (status === 400) {
      setSnackbarStatus('error');
      setSnackbarMessage('A connection issue or Invalid Data');
    }
    if (status == 401) {
      setSnackbarStatus('error');
      setSnackbarMessage('Unauthorized to view the content');
      signOut();
    } else if (status > 401 && status <= 500) {
      // revokeAccessToken();
      // console.log(error);
      setSnackbarStatus('error');
      setSnackbarMessage('Error connecting to the server');
    } else {
      setSnackbarStatus('error');
      setSnackbarMessage('Something went wrong');
    }
  };

  const HandleSuccess = (requestType) => {
    switch (requestType) {
      case 'get':
        setSnackbarStatus('success');
        setSnackbarMessage('Data Retrieved successfully');
        break;
      case 'add':
        setSnackbarStatus('success');
        setSnackbarMessage('Record Added Successfully');
        break;
      case 'update':
        setSnackbarStatus('success');
        setSnackbarMessage('Record Updated Successfully');
        break;
      case 'delete':
        setSnackbarStatus('success');
        setSnackbarMessage('Record Status set to Inactive Successfully ');
        break;
      default:
    }
  };

  const HandleErrorpendingLead = () => {
    setSnackbarStatus('error');
    setSnackbarMessage(
      'Data May not be updated. Error sending Emails to the Approver'
    );
  };

  const HandleSuccesspendingLead = () => {
    setSnackbarStatus('success');
    setSnackbarMessage('A Remainder Email was sent to the Approver');
  };

  const getData = (url) => {
    console.log(url);
    // setId('Abc');
    //CheckIdToken();
    console.log('id', id);

    let headers = {
      apiKey: id
    };

    axios
      .get(url, { headers })

      .then((response) => {
        setIsLoading(false);
        response.data.map((row) => (CcStatus[row.status] = row.status));
        setCcstatus(CcStatus);
        response.data.map(
          (row) => (CcProvider[row.cc_provider_code] = row.cc_provider_code)
        );
        setCcProvider(CcProvider);
        setData(response.data);

        setData(response.data);

        if (!(response.status == 200) || response.success == false) {
          HandleError(response.status);
        }
      })
      .catch((error) => {
        console.log('hererere');
        setIsLoading(false);
        HandleError(error.response.status);
      });
  };

  const handleOnRowAdd = (url, newData, resolve) => {
    newData.added_by = email;
    console.log("for adding   " + url);
    //CheckIdToken();
    let request = {
      method: 'POST',

      body: JSON.stringify(newData)
    };
    console.log(JSON.stringify(newData));

    axios
      .post(url, newData)
      .then((response) => {
        console.log(response);
        if (response.status == 201) {
          HandleSuccess('add');
        } else {
          console.log('in error');
          HandleError(response.status);
        }
        setTimeout(() => {
          setData(getData(getDataUrl));
          resolve();
        }, 500);
      })
      .catch((err) => {
        HandleError(err.status);

        setTimeout(() => {
          setData(getData(getDataUrl));
          resolve();
        }, 500);
      });
    // setData([...data,newData])
  };

  const handleOnRowUpdate = (url, newData, oldData, resolve) => {
    console.log('for updating   ' + url);
    newData.updated_by = email;

    //CheckIdToken();
    let request = {
      method: 'PUT',

      headers: {
        // "content-type":"application/json",
        'content-type': 'application/x-www-form-urlencoded',
        apiKey: id
      },
      body: JSON.stringify(newData)
    };

    fetch(url + oldData.id, request)
      .then((res) => {
        if (!res.ok) {
          HandleError(res.status);
          if (url === leadChangedPendingUpdateUrl) {
            HandleErrorpendingLead();
          }
        } else {
          HandleSuccess('update');
          const dataUpdate = [...data];
          const index = oldData.tableData.id;
          dataUpdate[index] = newData;
          setData([...dataUpdate]);
          if (url === leadChangedPendingUpdateUrl) {
            HandleSuccesspendingLead();
          }
        }
        setTimeout(() => {
          resolve();
        }, 500);
      })
      .catch((err) => {
        HandleError(err.status);
        setData(getData(getDataUrl));
        setTimeout(() => resolve(), 500);
      });
  };

  const handleOnRowDelete = (url, selectedRow, resolve) => {
    selectedRow.status = 'Inactive';
    CheckIdToken();
    let request = {
      method: 'DELETE',

      headers: {
        'content-type': 'application/json',
        apiKey: id
      }
    };
    fetch(url + selectedRow.id, request)
      .then((res) => {
        if (!res.ok) {
          const dataUpdate = [...data];
          const index = selectedRow.tableData.id;
          dataUpdate[index.status] = selectedRow.status;
          setData([...dataUpdate]);
        } else {
          HandleSuccess('delete');
        }
        setTimeout(() => {
          resolve();
        }, 500);
      })
      .catch((err) => {
        HandleError(err.status);
        setData(getData(getDataUrl));
        setTimeout(() => resolve(), 500);
      });
  };

  return (
    <Paper container className={classes.root}>
      <StatusSnackbar
        message={snackbarMessage}
        status={snackbarStatus}
        setStatus={setSnackbarStatus}
      />
      <Card sx={{ minWidth: 500 }}>
        <CardContent>
          <MaterialTable
            validationSchema={FORM_VALIDATION}
            tableRef={tableRef}
            style={{ fontFamily: 'Roboto', padding: '16 8px' }}
            title="Credit Cards"
            data={data}
            icons={tableIcons}
            //columns are added here inside material table component becouse of a
            //glitch in the Material table package version 1.69
            //In case the there is an error (memory leak error) in browser when moving from 1 table to another in consecutive times
            //just look at here whether someone has moved it to inside the datagridDemo function
            //Issue :https://github.com/mbrn/material-table/issues/2650
            //url https://stackoverflow.com/questions/69214615/why-memory-leak-happend-and-render-slowing-down-when-i-close-and-re-open-react-c
            columns={[
              {
                field: 'id',
                title: 'ID',
                searchable: true,
                type: 'numeric',
                cellStyle: { width: 150, minWidth: 150 },
                hidden: true
              },
              {
                field: 'cc_provider_code',
                title: 'CREDIT CARD PROVIDER',
                emptyValue: () => <em>null</em>,
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 },
                validate: (rowData) =>
                  rowData.internal_id === ''
                    ? {
                        isValid: false,
                        helperText: 'Internal Id cannot be empty'
                      }
                    : true,
                lookup: CcProvider
              },
              {
                field: 'cc_number',
                title: 'CC NUMBER',
                searchable: true
              },
              {
                field: 'employee_email',
                title: 'EMPLOYEE EMAIL',
                emptyValue: () => <em>null</em>,
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 }
              },
              {
                field: 'entity',
                title: 'ENTITY',
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 }
              },
              {
                field: 'status',
                title: 'STATUS',
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 },
                lookup: CcStatus
              },
              {
                field: 'comment',
                title: 'COMMENT',
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 }
              },
              {
                field: 'added_by',
                title: 'ADDED BY',
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 },
                editable: 'onAdd',
                editComponent: (props) => (
                  <TextField
                    variant="outlined"
                    disabled
                    fullWidth
                    label={props.columnDef.title}
                    type="text"
                    defaultValue={email}
                    onChange={(e) => props.onChange(e.target.value)}
                    error={props.error}
                    helperText={props.helperText}
                    placeholder={props.columnDef.title}
                  />
                )
              },
              {
                field: 'lead_email',
                title: 'APPROVER',
                searchable: true,
                cellStyle: { width: 150, minWidth: 150 }
              }
            ]}
            rowsPerPageOptions={[100]}
            checkboxSelection
            disableSelectionOnClick
            isLoading={isloading}
            options={{
              actionsColumnIndex: -1,
              headerStyle: { size: '20px' },
              // filtering: true,
              pageSizeOptions: [10, 20, 50, 100],
              pageSize: 10,
              paginationType: 'stepped',
              paginationPosition: 'bottom',
              addRowPosition: 'first',
              columnsButton: true,
              exportButton: {
                csv: true,
                pdf: false
              },
              rowStyle: (data, index) =>
                index % 2 === 1
                  ? {
                      backgroundColor: '#EEE',
                      fontFamily: 'Roboto',
                      fontSize: 13
                    }
                  : { fontFamily: 'Roboto', fontSize: 13 }
            }}
            editable={
              true
                ? {
                    isDeletable: (row) => row.status === 'Active',
                    onRowAddCancelled: (rowData) => {
                      setSnackbarStatus('warning');
                      setSnackbarMessage('Row adding cancelled');
                    },
                    onRowUpdateCancelled: (rowData) => {
                      setSnackbarStatus('warning');
                      setSnackbarMessage('Row editing cancelled');
                    },
                    onRowAdd: (newData) =>
                      new Promise((resolve, reject) =>
                        handleOnRowAdd(createDataUrl, newData, resolve)
                      ),
                    onRowUpdate: (newData, oldData) =>
                      new Promise((resolve, reject) => {
                        if (
                          newData.status === 'Pending' &&
                          newData.lead_email !== oldData.lead_email
                        ) {
                          newData.old_lead = oldData.lead_email;
                          handleOnRowUpdate(
                            leadChangedPendingUpdateUrl,
                            newData,
                            oldData,
                            resolve
                          );
                        } else {
                          handleOnRowUpdate(
                            updateDataUrl,
                            newData,
                            oldData,
                            resolve
                          );
                        }
                      }),
                    onRowDelete: (selectedRow) =>
                      new Promise((resolve, reject) =>
                        handleOnRowDelete(deleteDataUrl, selectedRow, resolve)
                      )
                  }
                : null
            }
          />
        </CardContent>
      </Card>
    </Paper>
  );
}
