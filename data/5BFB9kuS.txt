defmodule DayEight do
  Mix.install([:arrays])
  @input_path "input_sample.txt"

  def get_input() do
    grid =
      @input_path
      |> File.read!()
      |> String.split("\n", trim: true)
      |> Enum.map(fn line ->
        line
        |> String.split("", trim: true)
        |> Enum.map(&String.to_integer/1)
        |> Arrays.new()
      end)
      |> Arrays.new()

    [grid, Arrays.get(grid, 0) |> Arrays.size(), Arrays.size(grid)]
  end

  def scan(visible_trees, grid, range_width, range_height, dir_x, dir_y) do
    Enum.reduce(range_width, visible_trees, fn y, visible_trees_outer ->
      Enum.reduce_while(range_height, visible_trees_outer, fn x, visible_trees_inner ->
        height_current = grid |> Arrays.get(y) |> Arrays.get(x)
        height_prev = grid |> Arrays.get(y + dir_y) |> Arrays.get(x + dir_x)

        cond do
          height_prev < height_current ->
            if Map.has_key?(visible_trees_inner, [x, y]),
              do: {:cont, visible_trees_inner},
              else: {:cont, Map.put(visible_trees_inner, [x, y], height_current)}

          height_prev == height_current ->
            {:cont, visible_trees_inner}

          true ->
            {:halt, visible_trees_inner}
        end
      end)
    end)
  end

  def part_one([grid, width, height]) do
    %{}
    |> scan(grid, 1..(width - 2), 1..(height - 2), -1, 0)
    |> scan(grid, (width - 2)..1, (height - 2)..1, 1, 0)
    |> scan(grid, 1..(width - 2), 1..(height - 2), 0, -1)
    |> scan(grid, (width - 2)..1, (height - 2)..1, 0, 1)
    |> count_visible_trees(width, height)
  end

  def count_visible_trees(visible_inner_trees, width, height) do
    map_size(visible_inner_trees) + width * 2 + (height - 2) * 2
  end

  def run() do
    data = get_input()
    IO.puts("Part one: #{part_one(data)}.")
    # IO.puts("Part two: #{part_two(data)}.")
  end
end

DayEight.run()
