use std::env;
use std::io::{self, prelude::*, BufReader};
use std::fs::File;

const DIM: usize = 99; // Sample=5

fn visible_trees(tree_map: &Vec<Vec<u32>>) -> usize {
    let mut num_visible = 0;
    for y in 0..DIM {
        'srch: for x in 0..DIM {
            // Handle edges
            if x == 0 || y == 0 || x == DIM-1 || y == DIM-1 { num_visible += 1; continue 'srch; }
            let v = tree_map[x][y];
            // Scan -y
            let mut visible = true;
            'ym: for y0 in 0..y {
                if tree_map[x][y0] >= v { visible = false; break 'ym; }
            }
            if visible { num_visible += 1; continue 'srch; }
            // Scan +y
            let mut visible = true;
            'yp: for y0 in y+1..DIM {
                if tree_map[x][y0] >= v { visible = false; break 'yp; }
            }
            if visible { num_visible += 1; continue 'srch; }
            // Scan -x
            let mut visible = true;
            'xm: for x0 in 0..x {
                if tree_map[x0][y] >= v { visible = false; break 'xm; }
            }
            if visible { num_visible += 1; continue 'srch; }
            // Scan +x
            let mut visible = true;
            'xp: for x0 in x+1..DIM {
                if tree_map[x0][y] >= v { visible = false; break 'xp; }
            }
            if visible { num_visible += 1; continue 'srch; }
        }
    }
    num_visible
}

fn scenic_score(tree_map: &Vec<Vec<u32>>) -> usize {
    let mut max_scenic = 0;
    for y in 0..DIM {
        'srch: for x in 0..DIM {
            // Handle edges
            if x == 0 || y == 0 || x == DIM-1 || y == DIM-1 { continue 'srch; } // Zero scenic
            let v = tree_map[x][y];
            // Scan -y
            let mut dist_ym = 0;
            'ym: for y0 in (0..y).rev() {
                if tree_map[x][y0] <= v { dist_ym += 1; }
                if tree_map[x][y0] >= v { break 'ym; }
            }
            // Scan +y
            let mut dist_yp = 0;
            'yp: for y0 in y+1..DIM {
                if tree_map[x][y0] <= v { dist_yp += 1; }
                if tree_map[x][y0] >= v { break 'yp; }
            }
            // Scan -x
            let mut dist_xm = 0;
            'xm: for x0 in (0..x).rev() {
                if tree_map[x0][y] <= v { dist_xm += 1; }
                if tree_map[x0][y] >= v { break 'xm; }
            }
            // Scan +x
            let mut dist_xp = 0;
            'xp: for x0 in x+1..DIM {
                if tree_map[x0][y] <= v { dist_xp += 1; }
                if tree_map[x0][y] >= v { break 'xp; }
            }
            max_scenic = std::cmp::max(max_scenic, dist_ym * dist_yp * dist_xp * dist_xm);
        }
    }
    max_scenic
}

fn solve(input: &str) -> io::Result<()> {
    let file = File::open(input).expect("Input file not found.");
    let reader = BufReader::new(file);

    // Input
    let input: Vec<String> = match reader.lines().collect() {
        Err(err) => panic!("Unknown error reading input: {}", err),
        Ok(result) => result,
    };

    // Build tree map
    let mut tree_map = vec![vec![0; DIM]; DIM];
    for (y,line) in input.iter().enumerate() {
        for (x,c) in line.chars().enumerate() {
            tree_map[x][y] = c.to_digit(10).unwrap();
        }
    }

    // Outputs
    println!("Part 1: {}",visible_trees(&tree_map)); // 1693
    println!("Part 2: {}",scenic_score(&tree_map)); // 422059

    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let filename = &args[1];
    solve(&filename).unwrap();
}
