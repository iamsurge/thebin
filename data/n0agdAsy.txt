import sys
from copy import deepcopy
from random import choice
from time import perf_counter
from typing import List, Tuple


def idebug(*args):
    # return
    print(*args, file=sys.stderr, flush=True)


def debug(*args):
    # return
    print(*args, file=sys.stderr, flush=True)


# Auto-generated code below aims at helping you parse
# the standard input according to the problem statement.

vampire_count, zombie_count, ghost_count = [int(i) for i in input().split()]
idebug(vampire_count, zombie_count, ghost_count)

monsters: dict = {'V': vampire_count, 'Z': zombie_count, 'G': ghost_count}

size = int(input())
idebug(size)

line = input()
idebug(line)
can_see_from_top: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_bottom: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_left: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_right: List[int] = list(map(int, line.split()))

grid: List[str] = []
for i in range(size):
    row = input()
    idebug(row)
    grid.append(list(row))

"""
    There are two types of mirror:
    -\: Diagonal down.
    -/: Diagonal up.
"""

DIRECTIONS: dict = {'TOP': (0, 1), 'BOTTOM': (0, -1), 'LEFT': (1, 0), 'RIGHT': (-1, 0)}
can_see_from: dict = {'TOP': can_see_from_top, 'BOTTOM': can_see_from_bottom, 'LEFT': can_see_from_left, 'RIGHT': can_see_from_right}


# debug(grid)


# Write an answer using print
# To debug: print("Debug messages...", file=sys.stderr, flush=True)

def fill_manor_random(grid: List[str], monsters: dict) -> List[str]:
    """
        Generate a random disposition of monsters inside the manor
    :param grid: 
    :param monsters: 
    :return: 
    """
    new_grid = deepcopy(grid)
    monsters_copy = deepcopy(monsters)
    for i in range(size):
        for j in range(size):
            if new_grid[i][j] == '.':
                avail_monsters = [k for k, v in monsters_copy.items() if v > 0]
                monster: str = choice(avail_monsters)
                new_grid[i][j] = monster
                monsters_copy[monster] -= 1
    return new_grid


def check_manor_from(_dir: str, grid: List[str]) -> bool:
    """
        Verify if the statement are true
    :param _dir: direction of window
    :param grid: grid including monsters
    :return: 
    """
    for i in range(size):
        ray = DIRECTIONS[_dir]
        monsters_count, mirror = 0, False
        x, y = (i, 0) if _dir == 'TOP' else (i, size - 1) if _dir == 'BOTTOM' else (0, i) if _dir == 'LEFT' else (size - 1, i)
        # debug(f'dir {_dir} - start = {(x, y)}')
        while 0 <= x < size and 0 <= y < size:
            if grid[y][x] == '\\':
                ray = ray[1], ray[0]
                mirror = True
            elif grid[y][x] == '/':
                ray = -ray[1], -ray[0]
                mirror = True
            elif (grid[y][x] == 'G' and mirror) or (grid[y][x] == 'Z') or (grid[y][x] == 'V' and not mirror):
                monsters_count += 1
            x, y = x + ray[0], y + ray[1]
        if monsters_count != can_see_from[_dir][i]:
            # debug(f'check_manor_from {_dir}: False')
            return False
    # debug(f'check_manor_from {_dir}: True')
    return True


def is_valid_manor(grid: List[str]) -> bool:
    """
        check if a grid is valid (for all directions) according to the statement
    :param grid: 
    :return: 
    """
    # debug(f'checking new grid: {grid}')
    for _dir in DIRECTIONS:
        if not check_manor_from(_dir, grid):
            return False
    return True


start: float = perf_counter()

iterations_count = 0

while True:
    iterations_count += 1
    manor: List[str] = fill_manor_random(grid, monsters)
    if is_valid_manor(manor):
        break

for i in range(size):
    print(''.join([row for row in manor[i]]))

elapsed_time = perf_counter() - start
debug(f'elapsed time = {round(elapsed_time * 1000, 2)} ms - iterations_count = {iterations_count}')
