/* В приют привозят собак разных пород. 
 * В словаре shelter по названию хранится количество особей каждого вида на текущий момент. 
 * Приют может принять определённое количество собак каждой породы. 
 * Оно указано в словаре max_amount.
 * Напишите функцию, которая будет на основании вектора с породами поступивших собак 
 * обновлять словарь shelter и возвращать общее количество попавших в приют собак. 
 * Гарантируется, что никакие другие собаки, кроме известных из словаря max_amount, 
 * в приют не приедут.
 
 map<string, int> shelter = {{"landseer"s, 1}, {"otterhound"s, 2}, {"pekingese"s, 2}, {"pointer"s, 3}};
 const map<string, int> max_amount = {{"landseer"s, 2}, {"otterhound"s, 3}, {"pekingese"s, 4}, {"pointer"s, 7}};
 const vector<string> new_dogs = {"landseer"s, "otterhound"s, "otterhound"s, "otterhound"s, "pointer"s};
 */

#include <algorithm>
#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <map>

using namespace std;

int CountAndAddNewDogs(const vector<string>& new_dogs, const map<string,int>& max_amount, map<string,int>& shelter) {
    map<string,int> new_dogs_map;					// словарь с прибывающими собаками
    set<string> zero_in_shelter;					// если в shelter изначально есть ключи с нулевыми значениями, то запомним их тут
    
    for(const auto& x : shelter)                    //заполняем zero_in_shelter
        if(!x.second) 
            zero_in_shelter.insert(x.first);
    
    for(const auto& x : new_dogs)					// заполняем new_dogs_map, пробегая по вектору new_dogs
        ++new_dogs_map[x];
    
    const int total_accepted = count_if(new_dogs.begin(),new_dogs.end(),
                                        [&shelter,&max_amount,&new_dogs_map]
                                        (const string& breed) {
        int num = new_dogs_map[breed];							// количество собак породы breed, которых надо заселить в shelter
        int allowed  = max_amount.at(breed)-shelter[breed];		// остаток мест в приюте для породы breed
        int accepted = num<=allowed ? num : allowed;			// столько прибывших собак фактически возможно заселить в приют
        shelter[breed] += accepted;								// заселяем
        return (accepted != 0);									// отметим, что заселение произошло
    } );
  																// если в процессе подсчёта count_if в shelter были созданы ключи
																// с нулевыми значениями, которых изначально там не было, то удалим их
        														// дабы сохранить структуру shelter целостной:
    for(auto it = shelter.begin(); it != shelter.end(); ) {		
        if(it->second == 0 && !zero_in_shelter.count(it->first))  
            it = shelter.erase(it);
        else ++it;
	}
    
    return total_accepted;
}

void PrintMap(const map<string,int>& new_map) {
    for(const auto& [breed,num] : new_map)
        cout<<breed<<' '<<num<<endl;
} 

int main() {
    map<string,int> shelter = {{"landseer"s, 1}, {"otterhound"s, 0}, {"pekingese"s, 2}, {"pointer"s, 3}};
    const map<string, int> max_amount = {{"pudel",0},{"landseer"s, 2}, {"otterhound"s, 3}, {"pekingese"s, 4}, {"pointer"s, 7}};
    const vector<string> new_dogs = {"pudel","pudel","landseer"s, "pudel", "pudel", "pointer"s,"pudel"};    
    
    cout<<CountAndAddNewDogs(new_dogs,max_amount,shelter)<<endl;
    PrintMap(shelter);
    return 0;
}