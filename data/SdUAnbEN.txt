#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

const int max_size = 5e5 + 1;

int viz[max_size], lant, ult;
vector <int> muchii[max_size], sate, noduri_parcurse;
queue <int> q;

void bfs (int nod)
{ /// voi realiza bfs deoarece la dfs risc sa omor memoria
    viz[nod] = 1;
    lant = 1;
    q.push(nod);
    while (!q.empty())
    {
        nod = q.front();
        q.pop();
        noduri_parcurse.push_back(nod);
        for (auto f : muchii[nod])
        {
            if (!viz[f])
            {
                viz[f] = viz[nod] + 1;
                lant = max(lant, viz[f]);
                q.push(f);
                ult = f;
            }
        }
    }
}

int main ()
{
    int n, m, maxlant = 0, buget;
    cin >> n >> m >> buget;
    while (m--)
    {
        int x, y;
        cin >> x >> y;
        muchii[x].push_back(y);
        muchii[y].push_back(x);
    }
    for (int i = 1; i <= n; i++)
    {
        if (viz[i] == 0)
        {
            lant = 0;
            noduri_parcurse.clear();
            bfs(i);
            for (auto f : noduri_parcurse)
            { /// noi nu trebuie sa resetam toate nodurile din graf
             /// ci doar cele din satul curent, altfel riscam sa ajungem
             /// la O(N^2)
                viz[f] = 0;
            }
            bfs(ult);
            if (lant > maxlant)
            {
                maxlant = lant;
                sate.clear();
            }
            cout << lant << " ";
            if (lant == maxlant)
            { /// fiindca arborele se va parcurge de doua ori
              /// noi avem doar noduriparcurse / 2 noduri in arborele nostru
                sate.push_back(noduri_parcurse.size() / 2);
            }
        }
    }
    int ans = 0;
    sort(sate.begin(), sate.end());
    for (auto f : sate)
    {
        if (buget - f >= 0)
        {
            ans++;
            buget -= f;
        }
    }
    cout << ans;
    return 0;
}
