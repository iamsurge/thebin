#include <cstddef>
#include <array>
#include <utility>
#include <algorithm>
#include <numeric>

namespace NMatrix {

template <class vt, size_t h, size_t v>
class matrix {
public:

    matrix() : data_({{}}) {}

    explicit matrix(const vt& num) {
        for (auto& i : data_)
            for (auto& j : i)
                j = num;
    }

    bool operator==(const matrix& other) const {
        for (int i = 0; i < h; ++i)
            for (int j = 0; j < v; ++j)
                if (data_[i][j] != other.data_[i][j])
                    return false;
        return true;
    }

    bool operator!=(const matrix& other) const {
        return !operator==(other);
    }

    matrix& operator+=(const vt& x) {
        for (auto& i : data_)
            for (auto& j : i)
                j += x;
        return *this;
    }

    matrix& operator-=(const vt& x) {
        for (auto& i : data_)
            for (auto& j : i)
                j -= x;
        return *this;
    }

    matrix& operator*=(const vt& x) {
        for (auto& i : data_)
            for (auto& j : i)
                j *= x;
        return *this;
    }

    matrix& operator/=(const vt& x) {
        for (auto& i : data_)
            for (auto& j : i)
                j /= x;
        return *this;
    }

    matrix& operator+=(const matrix& oth) {
        for (int i = 0; i < h; ++i)
            for (int j = 0; j < v; ++j)
                data_[i][j] += oth.data_[i][j];
        return *this;
    }

    matrix& operator-=(const matrix& oth) {
        for (int i = 0; i < h; ++i)
            for (int j = 0; j < v; ++j)
                data_[i][j] -= oth.data_[i][j];
        return *this;
    }


    matrix& operator*=(const matrix<vt, v, v>& oth) {
        auto tmp = data_;
        data_ = {};
        for (int i = 0; i < h; ++i)
            for (int j = 0; j < v; ++j) {
                for (int k = 0; k < v; ++k)
                    data_[i][j] += tmp[i][k] * oth.at(k,j);
            }
        return *this;
    }

    const matrix operator+() const {
        return *this;
    }

    const matrix operator-() const {
        matrix tmp;
        tmp -= *this;
        return tmp;
    }

    vt& at(size_t i, size_t j) {
        return data_[i][j];
    }

    const vt& at(size_t i, size_t j) const {
        return data_[i][j];
    }

    auto transposed() const {
        matrix<vt, v, h> res;
        for (int i = 0; i < h; ++i)
            for (int j = 0; j < v; ++j)
                res.at(j, i) = data_[i][j];
        return res;
    }

    vt trace() const {
        vt ans(0);
        for (int i = 0; i < v; ++i)
            ans += data_[i][i];
        return ans;
    }

    vt det() const {
        std::array<int, v> p;
        vt ans = 0;
        for (int i = 0; i < v; ++i)
            p[i] = i;
        do {
            vt cur(1);
            for (int i = 0; i < v; ++i) {
                cur *= data_[i][p[i]];
            }

            int sign = parity(p);

            if (sign % 2 == 0)
                ans += cur;
            else
                ans -= cur;
            
        } while (std::next_permutation(p.begin(), p.end()));
        return ans;
    }

private:
    static bool parity(const std::array<vt, v> &p) {
        int n = p.size();
        if (n == 1) return false;
        std::array<int, v> cur;
        std::array<int, v> inv_cur;
        std::iota(cur.begin(), cur.end(), 0);
        std::iota(inv_cur.begin(), inv_cur.end(), 0);
        auto do_cycle = [&](int i, int j, int k) {
            int tmp = cur[k];
            cur[k] = cur[j];
            cur[j] = cur[i];
            cur[i] = tmp;

            inv_cur[cur[i]] = i;
            inv_cur[cur[j]] = j;
            inv_cur[cur[k]] = k;
        };
        for (int i = 0; i < n - 2; i++) {
            if (cur[i] != p[i]) {
                int j = inv_cur[p[i]];
                if (j != n - 1) {
                    do_cycle(n - 1, j, i);
                } else {
                    do_cycle(n - 2, j, i);
                }
            }
        }
        return cur[n - 1] != p[n - 1];
    }
    std::array<std::array<vt, v>, h> data_;
};

///////////////////////////// scalar operators {

template <class vt, size_t h, size_t v>
auto operator+(const matrix<vt, h, v>& m, int x) {
    auto tmp = m;
    tmp += x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator+(int x, const matrix<vt, h, v>& m) {
    auto tmp = m;
    tmp += x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator-(const matrix<vt, h, v>& m, int x) {
    auto tmp = m;
    tmp -= x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator-(int x, const matrix<vt, h, v>& m) {
    auto tmp = -m;
    tmp += x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator*(const matrix<vt, h, v>& m, int x) {
    auto tmp = m;
    tmp *= x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator*(int x, const matrix<vt, h, v>& m) {
    auto tmp = m;
    tmp *= x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator/(const matrix<vt, h, v>& m, int x) {
    auto tmp = m;
    tmp /= x;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator/(int x, const matrix<vt, h, v>& m) {
    auto tmp = m;
    tmp /= x;
    return tmp;
}

///////////////////////////// } scalar operators
///////////////////////////// matrix operators {

template <class vt, size_t h, size_t v>
auto operator+(const matrix<vt, h, v>& a, const matrix<vt, h, v>& b) {
    auto tmp = a;
    tmp += b;
    return tmp;
}

template <class vt, size_t h, size_t v>
auto operator-(const matrix<vt, h, v>& a, const matrix<vt, h, v>& b) {
    auto tmp = a;
    tmp -= b;
    return tmp;
}

template <class vtype, size_t a, size_t b, size_t c>
auto operator*(const matrix<vtype, a, b>& A, const matrix<vtype, b, c>& B) {
    matrix<decltype(std::declval<vtype>() * std::declval<vtype>()), a, c> res;
    for (int i = 0; i < a; ++i)
        for (int j = 0; j < c; ++j)
            for (int k = 0; k < b; ++k)
                res.at(i,j) += A.at(i,k) * B.at(k,j);
    return res;
}

///////////////////////////// } matrix operators

} // namespace NMatrix

using namespace NMatrix;

#ifdef LOCAL
#include <iostream>
int main() {
    matrix<int, 2, 2> a;
    a.at(0, 0) = 1;
    a.at(1, 1) = 1;
    a.at(0, 1) = 2;
    a.at(1, 0) = 2;
    std::cout << a.det() << '\n';
}
#endif