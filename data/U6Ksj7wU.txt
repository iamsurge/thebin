import sys
from copy import deepcopy
from random import choice
from typing import List


def idebug(*args):
    return
    print(*args, file=sys.stderr, flush=True)


def debug(*args):
    # return
    print(*args, file=sys.stderr, flush=True)


"""
    There are two types of mirror:
    -\: Diagonal down.
    -/: Diagonal up.
"""

DIRECTIONS = [(-1, 0), (0, 1), (1, 0), (0, -1)]
diag_down = lambda x, y: (y, x)
diag_up = lambda x, y: (-y, -x)

# Auto-generated code below aims at helping you parse
# the standard input according to the problem statement.

vampire_count, zombie_count, ghost_count = [int(i) for i in input().split()]
idebug(vampire_count, zombie_count, ghost_count)

monsters: dict = {'V': vampire_count, 'Z': zombie_count, 'G': ghost_count}

size = int(input())
idebug(size)

line = input()
idebug(line)
can_see_from_top: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_bottom: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_left: List[int] = list(map(int, line.split()))

line = input()
idebug(line)
can_see_from_right: List[int] = list(map(int, line.split()))

grid: List[str] = []
for i in range(size):
    row = input()
    idebug(row)
    grid.append(list(row))

debug(grid)


# Write an answer using print
# To debug: print("Debug messages...", file=sys.stderr, flush=True)

def fill_manor_random(grid: List[str], monsters: dict) -> List[str]:
    new_grid = deepcopy(grid)
    monsters_copy = deepcopy(monsters)
    for i in range(size):
        for j in range(size):
            if new_grid[i][j] == '.':
                avail_monsters = [k for k, v in monsters_copy.items() if v > 0]
                monster: str = choice(avail_monsters)
                new_grid[i][j] = monster
                monsters_copy[monster] -= 1
    return new_grid


def check_manor_from_top(grid: List[str]) -> bool:
    ray = (0, 1)
    for j in range(size):
        x, y, monsters_count, mirror = j, 0, 0, False
        while 0 <= x < size and 0 <= y < size:
            if grid[y][x] == '\\':
                ray = diag_down(*ray)
                mirror = True
            elif grid[y][x] == '/':
                ray = diag_up(*ray)
                mirror = True
            elif (grid[y][x] == 'G' and mirror) or (grid[y][x] == 'Z') or (grid[y][x] == 'V' and not mirror):
                monsters_count += 1
            x, y = x + ray[0], y + ray[1]
        if monsters_count != can_see_from_top[j]:
            return False
    return True


def check_manor_from_bottom(grid: List[str]) -> bool:
    ray = (0, -1)
    for j in range(size):
        x, y, monsters_count, mirror = j, size - 1, 0, False
        while 0 <= x < size and 0 <= y < size:
            if grid[y][x] == '\\':
                ray = diag_down(*ray)
                mirror = True
            elif grid[y][x] == '/':
                ray = diag_up(*ray)
                mirror = True
            elif (grid[y][x] == 'G' and mirror) or (grid[y][x] == 'Z') or (grid[y][x] == 'V' and not mirror):
                monsters_count += 1
            x, y = x + ray[0], y + ray[1]
        if monsters_count != can_see_from_top[j]:
            return False
    return True


def check_manor_from_left(grid: List[str]) -> bool:
    ray = (1, 0)
    for i in range(size):
        x, y, monsters_count, mirror = 0, i, 0, False
        while 0 <= x < size and 0 <= y < size:
            if grid[y][x] == '\\':
                ray = diag_down(*ray)
                mirror = True
            elif grid[y][x] == '/':
                ray = diag_up(*ray)
                mirror = True
            elif (grid[y][x] == 'G' and mirror) or (grid[y][x] == 'Z') or (grid[y][x] == 'V' and not mirror):
                monsters_count += 1
            x, y = x + ray[0], y + ray[1]
        if monsters_count != can_see_from_left[i]:
            return False
    return True


def check_manor_from_right(grid: List[str]) -> bool:
    ray = (-1, 0)
    for i in range(size):
        x, y, monsters_count, mirror = size - 1, i, 0, False
        while 0 <= x < size and 0 <= y < size:
            if grid[y][x] == '\\':
                ray = diag_down(*ray)
                mirror = True
            elif grid[y][x] == '/':
                ray = diag_up(*ray)
                mirror = True
            elif (grid[y][x] == 'G' and mirror) or (grid[y][x] == 'Z') or (grid[y][x] == 'V' and not mirror):
                monsters_count += 1
            x, y = x + ray[0], y + ray[1]
        if monsters_count != can_see_from_right[i]:
            return False
    return True


def check_manor(grid: List[str]) -> bool:
    return check_manor_from_bottom(grid) and check_manor_from_top(grid) and check_manor_from_right(grid) and check_manor_from_left(grid)

"""
        ZG/
        ZZG
        /G/
"""
winning_grid = [['Z', 'G', '/'], ['Z', 'Z', 'G'], ['/', 'G', '/']]

print(check_manor(winning_grid))

exit()
while True:
    manor: List[str] = fill_manor_random(grid, monsters)
    if check_manor(manor):
        break

print(manor)
