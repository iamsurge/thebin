#include "test_runner.h"
#include <functional>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

using namespace std;

struct Email {
    string from;
    string to;
    string body;
};

class Worker {
public:
    virtual ~Worker() = default;
    virtual void Process(unique_ptr<Email> email) = 0;
    virtual void Run()
    {
        // только первому worker-у в пайплайне нужно это имплементировать
        throw logic_error("Unimplemented");
    }

protected:
    // реализации должны вызывать PassOn, чтобы передать объект дальше
    // по цепочке обработчиков
    void PassOn(unique_ptr<Email> email) const
    {
        if (next_)
            next_->Process(move(email));
    }

    unique_ptr<Worker> next_;

public:
    void SetNext(unique_ptr<Worker> next)
    {
        if (next_)
            next_->SetNext(move(next));
        else
            next_ = move(next);
    }
};

class Reader : public Worker {
public:
    // реализуйте класс
    explicit Reader(istream& in)
        : in_(in)
    {
    }

    void Run() override
    {
        while (!in_.eof()) {
            unique_ptr<Email> e = make_unique<Email>();
            getline(in_, e->from);
            getline(in_, e->to);
            getline(in_, e->body);
            PassOn(move(e));
        }
    }
    void Process(unique_ptr<Email> email) override
    {
        PassOn(move(email));
        Run();
    }

private:
    istream& in_;
};

class Filter : public Worker {
public:
    using Function = function<bool(const Email&)>;

public:
    // реализуйте класс
    explicit Filter(Function& f)
        : f_(move(f))
    {
    }

private:
    void Process(unique_ptr<Email> email) override
    {
        if (f_(*email))
            PassOn(move(email));
    }
    
    Function f_;
};

class Copier : public Worker {
public:
    // реализуйте класс
    explicit Copier(string& copy_to)
        : copy_to_(move(copy_to))
    {
    }

private:
    void Process(unique_ptr<Email> email) override
    {
        if (email->to != copy_to_) {
            unique_ptr<Email> copy = make_unique<Email>();
            copy->from = email->from;
            copy->to = copy_to_;
            copy->body = email->body;
            PassOn(move(email));
            PassOn(move(copy));
        } else
            PassOn(move(email));
    }

    string copy_to_;
};

class Sender : public Worker {
public:
    // реализуйте класс
    explicit Sender(ostream& out)
        : out_(out)
    {
    }

private:
    void Process(unique_ptr<Email> email) override
    {
        out_ << email->from << '\n'
             << email->to << '\n'
             << email->body << '\n';
        PassOn(move(email));
    }

    ostream& out_;
};

// реализуйте класс
class PipelineBuilder {
public:
    // добавляет в качестве первого обработчика Reader
    explicit PipelineBuilder(istream& in)
        : work(make_unique<Reader>(in))
    {
    }

    // добавляет новый обработчик Filter
    PipelineBuilder& FilterBy(Filter::Function filter)
    {
        work->SetNext(make_unique<Filter>(filter));
        return *this;
    }

    // добавляет новый обработчик Copier
    PipelineBuilder& CopyTo(string recipient)
    {
        work->SetNext(make_unique<Copier>(recipient));
        return *this;
    }

    // добавляет новый обработчик Sender
    PipelineBuilder& Send(ostream& out)
    {
        work->SetNext(make_unique<Sender>(out));
        return *this;
    }

    // возвращает готовую цепочку обработчиков
    unique_ptr<Worker> Build()
    {
        return move(work);
    }

private:
    unique_ptr<Worker> work;
};

void TestSanity()
{
    string input = ("erich@example.com\n"
                    "richard@example.com\n"
                    "Hello there\n"

                    "erich@example.com\n"
                    "ralph@example.com\n"
                    "Are you sure you pressed the right button?\n"

                    "ralph@example.com\n"
                    "erich@example.com\n"
                    "I do not make mistakes of that kind\n");
    istringstream inStream(input);
    ostringstream outStream;

    PipelineBuilder builder(inStream);
    builder.FilterBy([](const Email& email) {
        return email.from == "erich@example.com";
    });
    builder.CopyTo("richard@example.com");
    builder.Send(outStream);
    auto pipeline = builder.Build();

    pipeline->Run();

    string expectedOutput = ("erich@example.com\n"
                             "richard@example.com\n"
                             "Hello there\n"

                             "erich@example.com\n"
                             "ralph@example.com\n"
                             "Are you sure you pressed the right button?\n"

                             "erich@example.com\n"
                             "richard@example.com\n"
                             "Are you sure you pressed the right button?\n");

    ASSERT_EQUAL(expectedOutput, outStream.str());
}

int main()
{
    TestRunner tr;
    RUN_TEST(tr, TestSanity);
    return 0;
}
