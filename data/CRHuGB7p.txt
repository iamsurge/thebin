template <typename T>
void push(box<T>*& head, const T& newData) {
    head = new box<T>(newData, head);
}

template <typename T> 
void push_back(box<T>*& head, const T& newData) {
    if (!head) {
        push(head, newData);
        return;
    }
    box<T>* temp = head;
    while (temp->next != nullptr) {
        temp = temp->next;
    }
    temp->next = new box<T>(newData);
}

template <typename T>
void insertAt(box<T>*& head, const T& newData, size_t index) {
    if (!head) {
        return;
    }
    if (index == 0) {
        push(head, newData);
        return;
    }
    box<T>* temp = head;
    box<T>* prevTemp = nullptr;
    for (size_t i = 0; i < index; ++i) {
        if (temp == nullptr) {
            return;
        }
        prevTemp = temp;
        temp = temp->next;
    }
    if (prevTemp) {
        prevTemp->next = new box<T>(newData, temp);
    }

}

template <typename T>
box<T>* combineBoxes(box<T>* sorted, box<T>* toAdd) {
    if (!sorted || !toAdd) {
        return nullptr;
    }
    box<T>* result = nullptr;
    box<T>* tempSorted = sorted;
    while (tempSorted != nullptr) {
        push_back(result, tempSorted->data);
        tempSorted = tempSorted->next;
    }
    
    box<T>* tempToAdd = toAdd;
    tempSorted = result;
    while (tempToAdd != nullptr) {
        size_t index = 0;
        while (tempSorted != nullptr) {
            if (tempSorted->data > tempToAdd->data) {
                insertAt(result, tempToAdd->data, index);
                break;
            }
            tempSorted = tempSorted->next;
            index++;
        }
        tempSorted = result;
        tempToAdd = tempToAdd->next;
    }

    return result;

}