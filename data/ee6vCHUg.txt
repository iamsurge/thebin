#include <iostream>
#include <vector>
#include <set>
using namespace std;

set<vector<vector<int>>> all_variants;


bool canGoToCell(vector<vector<int>>& matrix, int i, int j) {// проверяет, можно ли попасть в клетку
    if (i < 0 || j < 0 || i >= 5 || j >= 5) {                // если вышли за границы
        return false;
    }
    return matrix[i][j] == 0;// если клетка пустая
}

bool isFill(vector<vector<int>>& matrix) {// проверяет, заполнена ли матрица
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            if (matrix[i][j] == 0) {
                return false;
            }
        }
    }
    return true;
}

bool solution(vector<vector<int>>& matrix, int i, int j, int count, int prev_i, int prev_j) {

    if (count > 25) {
        return false;
    }
    matrix[i][j] = count;// помечаем клетку

    if (count == 25 && isFill(matrix)) {// если все клетки заполнены
        std::vector<vector<int>> v2;
        v2.assign(matrix.begin(), matrix.end());//копируем матрицу

        all_variants.insert(v2);
    }
    if (count > 25) {
        return false;
    }

    if (!(i + 3 == prev_i && prev_j == j) && canGoToCell(matrix, i + 3, j)) {// если можно пойти вниз
        if (solution(matrix, i + 3, j, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 3 == prev_i && prev_j == j) && canGoToCell(matrix, i - 3, j)) {// если можно пойти вверх
        if (solution(matrix, i - 3, j, count + 1, i, j)) {
            return true;
        }
    }

    if (!(i == prev_i && prev_j == j + 3) && canGoToCell(matrix, i, j + 3)) {// если можно пойти вправо
        if (solution(matrix, i, j + 3, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i == prev_i && prev_j == j - 3) && canGoToCell(matrix, i, j - 3)) {// если можно пойти влево
        if (solution(matrix, i, j - 3, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i + 2 == prev_i && prev_j == j + 2) && canGoToCell(matrix, i + 2, j + 2)) {// если можно пойти вниз-вправо
        if (solution(matrix, i + 2, j + 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i + 2 == prev_i && prev_j == j - 2) && canGoToCell(matrix, i + 2, j - 2)) {// если можно пойти вниз-влево
        if (solution(matrix, i + 2, j - 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 2 == prev_i && prev_j == j + 2) && canGoToCell(matrix, i - 2, j + 2)) {// если можно пойти вверх-вправо
        if (solution(matrix, i - 2, j + 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 2 == prev_i && prev_j == j - 2) && canGoToCell(matrix, i - 2, j - 2)) {// если можно пойти вверх-влево
        if (solution(matrix, i - 2, j - 2, count + 1, i, j)) {
            return true;
        }
    }


    matrix[i][j] = 0;// если никуда не попасть, то отмечаем клетку как пустую
    return false;    // и возвращаем false
}

int main() {
    vector<vector<int>> matrix(5, vector<int>(10, 0));


    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            if (i > j) {
                solution(matrix, i, j, 1, -1, -1);// запускаем рекурсивную функцию
            }
        }
    }

    cout << " Count of permutations under diagonal: " << all_variants.size();
    return 0;
}
