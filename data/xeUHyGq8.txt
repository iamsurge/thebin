#include <bits/stdc++.h>

using namespace std;

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	int n, jobtime[11][11];

	cin >> n;

	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
		{
			cin >> jobtime[i][j]; /// i-й работник выполнит j-ю работу за это время
		}

	vector <int> p(n);

	for (int i = 0; i < n; i++)
		p[i] = i; /// i-й работник будет выполнять работу p[i]

	int mn = INT_MAX;

	do /// это другой вариант цикла while, условие проверяется в конце
	{
		int sum = 0;

		for (int i = 0; i < n; i++)
		{
			int j = p[i]; /// номер работы которую выполнит i-й работник

			sum += jobtime[i][j];
		}

		mn = min(mn, sum);
	
	} while (next_permutation(p.begin(), p.end())); /// получаем следующую перестановку в векторе p если она есть

	cout << mn << "\n";
}

/**
Функция next_permutation()

1) меняет текущую перестановку в векторе p на следующую.
2) если у текущей перестановки есть следующая перестановка она еще возвращает значение true,
3) если это самая последняя перестановка тогда возвращает false.

Пример работы next_permutation() для 4-х человек, сейчас p = {0, 1, 2, 3}

далее next_permutation(p.begin(), p.end() меняет вектор p на {0, 1, 3, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {0, 2, 1, 3} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {0, 2, 3, 1} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {0, 3, 1, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {0, 3, 2, 1} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 0, 2, 3} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 0, 3, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 2, 0, 3} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 2, 3, 0} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 3, 0, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {1, 3, 2, 0} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 0, 1, 3} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 0, 3, 1} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 1, 0, 3} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 1, 3, 0} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 3, 0, 1} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {2, 3, 1, 0} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {3, 0, 1, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {3, 0, 2, 1} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {3, 1, 0, 2} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {3, 1, 2, 0} и возращает true
далее next_permutation(p.begin(), p.end() меняет вектор p на {3, 1, 2, 0} и возращает false

так как {3, 1, 2, 0} это самая последняя перестановка тогда next_permutation возращает false
и цикл останавливается.

Всего 4! перестановок, т.е. 24 перестановки начиная от первой {0, 1, 2, 3} до последней {3, 1, 2, 0}

*/