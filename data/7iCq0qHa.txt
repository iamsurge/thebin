# include <cmath>
# include <cstdlib>
# include <cstring>
# include <ctime>
# include <fstream>
# include <iomanip>
# include <iostream>

using namespace std;

# include "brownian_motion_simulation.hpp"

void brownian_displacement_display ( int k, int n, int m, double d, double t, 
  double dsq[], string header )
{
  string command_filename;
  ofstream command;
  string data_filename;
  ofstream data;
  double dsq_ave;
  double dsq_ideal;
  int i;
  int *ii;
  int j;
  int seed;
  double ti;

  seed = 123456789;
//
//  Choose 5 paths at random.
//
  ii = i4vec_uniform_new ( 5, 0, k - 1, seed );
//
//  Create the data file.
//
  data_filename = header + "_data.txt";

  data.open ( data_filename.c_str ( ) );

  for ( j = 0; j < n; j++ )
  {
    ti = ( double ) ( j ) * t / ( double ) ( n - 1 );
    dsq_ave = 0.0;
    for ( i = 0; i < k; i++ )
    {
      dsq_ave = dsq_ave + dsq[i+j*k];
    }
    dsq_ave = dsq_ave / ( double ) k;
    dsq_ideal = 2.0 * m * d * ti;
    data << "  " << ti
         << "  " << dsq[ii[0]+j*k]
         << "  " << dsq[ii[1]+j*k]
         << "  " << dsq[ii[2]+j*k]
         << "  " << dsq[ii[3]+j*k]
         << "  " << dsq[ii[3]+j*k]
         << "  " << dsq_ave
         << "  " << dsq_ideal << "\n";
  }

  data.close ( );

  cout << "\n";
  cout << "  BROWNIAN_DISPLACEMENT data stored in \"" << data_filename << "\".\n";
//
//  Create the command file.
//
  command_filename = header + "_commands.txt";

  command.open ( command_filename.c_str ( ) );

  command << "# " << command_filename << "\n";
  command << "#\n";
  command << "# Usage:\n";
  command << "#  gnuplot < " << command_filename << "\n";
  command << "#\n";
  command << "set term png\n";
  command << "set output '" << header << ".png'\n";
  command << "set xlabel 'T'\n";
  command << "set ylabel 'D^2'\n";
  command << "set title 'Squared displacement (Red), Predicted (Black), Samples (Blue)'\n";
  command << "set grid\n";
  command << "set style data lines\n";
  command << "plot '" << data_filename << "' using 1:2 title 'sample 1' linecolor rgb 'blue', \\\n";
  command << "     '" << data_filename << "' using 1:3 title 'sample 2' linecolor rgb 'blue', \\\n";
  command << "     '" << data_filename << "' using 1:4 title 'sample 3' linecolor rgb 'blue', \\\n";
  command << "     '" << data_filename << "' using 1:5 title 'sample 4' linecolor rgb 'blue', \\\n";
  command << "     '" << data_filename << "' using 1:6 title 'sample 5' linecolor rgb 'blue', \\\n";
  command << "     '" << data_filename << "' using 1:7 title 'Averaged' lw 3 linecolor rgb 'red', \\\n";
  command << "     '" << data_filename << "' using 1:8 title 'Ideal' lw 3 linecolor rgb 'black'\n";
  command << "quit\n";

  command.close ( );

  cout << "  BROWNIAN_DISPLACEMENT plot commands stored in \"" << command_filename << "\".\n";

  delete [] ii;

  return;
}
//****************************************************************************80

double *brownian_displacement_simulation ( int k, int n, int m, double d, 
  double t, int &seed )
{
  double *dsq;
  int i;
  int i2;
  int j;
  double temp;
  double *x;

  dsq = new double[k*n];

  for ( i = 0; i < k; i++ )
  {
    x = brownian_motion_simulation ( m, n, d, t, seed );

    for ( j = 0; j < n; j++ )
    {
      temp = 0.0;
      for ( i2 = 0; i2 < m; i2++ )
      {
        temp = temp + pow ( x[i2+j*m], 2 );
      }
      dsq[i+j*k] = temp;
    }
    delete [] x;
  }

  return dsq;
}

void brownian_motion_display ( int m, int n, double x[], string header )
{
  string command_filename;
  ofstream command;
  string data_filename;
  ofstream data;
  int i;
  double t;

  if ( m != 1 && m != 2 )
  {
    cerr << "\n";
    cerr << "BROWNIAN_MOTION_DISPLAY - Fatal error!\n";
    cerr << "  This routine can only handle M = 1 or 2.\n";
    exit ( 1 );
  }
//
//  Create the data file.
//
  data_filename = header + "_data.txt";

  data.open ( data_filename.c_str ( ) );

  if ( m == 1 )
  {
    for ( i = 0; i < n; i++ )
    {
      t = ( double ) ( i - 1 ) / ( double ) ( n - 1 );
      data << "  " << t
           << "  " << x[0+i*m] << "\n";
    }
  }
  else if ( m == 2 )
  {
    for ( i = 0; i < n; i++ )
    {
      data << "  " << x[0+i*m]
           << "  " << x[1+i*m] << "\n";
    }
  }

  data.close ( );

  cout << "\n";
  cout << "  BROWNIAN_MOTION data stored in \"" << data_filename << "\n";
//
//  Create the command file.
//
  command_filename = header + "_commands.txt";

  command.open ( command_filename.c_str ( ) );

  command << "# " << command_filename << "\n";
  command << "#\n";
  command << "# Usage:\n";
  command << "#  gnuplot < " << command_filename << "\n";
  command << "#\n";
  command << "set term png\n";
  command << "set output '" << header << ".png'\n";
  command << "set xlabel 'X'\n";
  command << "set ylabel 'T'\n";
  command << "set title 'Brownian motion in 1D'\n";
  command << "set grid\n";
  command << "set style data lines\n";
  command << "plot '" << data_filename << "' using 1:2\n";
  command << "quit\n";

  command.close ( );

  cout << "  BROWNIAN_MOTION plot commands stored in \"" << command_filename << "\n";

  return;
}

double *brownian_motion_simulation ( int m, int n, double d, double t, 
  int &seed )
{
  double dt;
  double *dx;
  int i;
  int j;
  double norm_dx;
  double s;
  double *x;

  x = new double[m*n];
//
//  Set the time step.
//
  dt = t / ( double ) ( n - 1 );
//
//  Start at the origin.
//
  for ( i = 0; i < m; i++ )
  {
    x[i+0*m] = 0.0;
  }
//
//  Take N - 1 steps.
//
  for ( j = 1; j < n; j++ )
  {
//
//  S is the stepsize.
//
    s = sqrt ( 2 * m * d * dt ) * r8_normal_01 ( seed );
//
//  Direction DX is random, unit norm.
//
    dx = r8vec_normal_01_new ( m, seed );
    norm_dx = 0.0;
    for ( i = 0; i < m; i++ )
    {
      norm_dx = norm_dx + pow ( dx[i], 2 );
    }
    norm_dx = sqrt ( norm_dx );
    for ( i = 0; i < m; i++ )
    {
      dx[i] = s * dx[i] / norm_dx;
    }
//
//  Add the step to the current position.
//
    for ( i = 0; i < m; i++ )
    {
      x[i+j*m] = x[i+(j-1)*m] + dx[i];
    }
  }
  return x;
}

int *i4vec_uniform_new ( int n, int a, int b, int &seed )
{
  int c;
  int i;
  int i4_huge = 2147483647;
  int k;
  float r;
  int value;
  int *x;
  
  if ( seed == 0 )
  {
    cerr << "\n";
    cerr << "I4VEC_UNIFORM_NEW - Fatal error!\n";
    cerr << "  Input value of SEED = 0.\n";
    exit ( 1 );
  }
//
//  Guarantee A <= B.
//
  if ( b < a )
  {
    c = a;
    a = b;
    b = c;
  }

  x = new int[n];

  for ( i = 0; i < n; i++ )
  {
    k = seed / 127773;

    seed = 16807 * ( seed - k * 127773 ) - k * 2836;

    if ( seed < 0 )
    {
      seed = seed + i4_huge;
    }

    r = ( float ) ( seed ) * 4.656612875E-10;
//
//  Scale R to lie between A-0.5 and B+0.5.
//
    r = ( 1.0 - r ) * ( ( float ) a - 0.5 ) 
      +         r   * ( ( float ) b + 0.5 );
//
//  Use rounding to convert R to an integer between A and B.
//
    value = round ( r );
//
//  Guarantee A <= VALUE <= B.
//
    if ( value < a )
    {
      value = a;
    }
    if ( b < value )
    {
      value = b;
    }

    x[i] = value;
  }

  return x;
}

double r8_normal_01 ( int &seed )
{
  double pi = 3.141592653589793;
  double r1;
  double r2;
  static int used = -1;
  double x;
  static double y = 0.0;

  if ( used == -1 )
  {
    used = 0;
  }
//
//  If we've used an even number of values so far, generate two more, return one,
//  and save one.
//
  if ( ( used % 2 )== 0 )
  {
    for ( ; ; )
    {
      r1 = r8_uniform_01 ( seed );
      if ( r1 != 0.0 )
      {
        break;
      }
    }

    r2 = r8_uniform_01 ( seed );

    x = sqrt ( -2.0 * log ( r1 ) ) * cos ( 2.0 * pi * r2 );
    y = sqrt ( -2.0 * log ( r1 ) ) * sin ( 2.0 * pi * r2 );
  }
  else
  {

    x = y;

  }

  used = used + 1;

  return x;
}

double r8_uniform_01 ( int &seed )
{
  int i4_huge = 2147483647;
  int k;
  double r;

  if ( seed == 0 )
  {
    cerr << "\n";
    cerr << "R8_UNIFORM_01 - Fatal error!\n";
    cerr << "  Input value of SEED = 0.\n";
    exit ( 1 );
  }

  k = seed / 127773;

  seed = 16807 * ( seed - k * 127773 ) - k * 2836;

  if ( seed < 0 )
  {
    seed = seed + i4_huge;
  }
  r = ( double ) ( seed ) * 4.656612875E-10;

  return r;
}

double *r8vec_normal_01_new ( int n, int &seed )
{
  int i;
  int m;
  static int made = 0;
  double pi = 3.141592653589793;
  double *r;
  static int saved = 0;
  double *x;
  int x_hi;
  int x_lo;
  static double y = 0.0;

//
  if ( n < 0 )
  {
    made = 0;
    saved = 0;
    y = 0.0;
    return NULL;
  }
  else if ( n == 0 )
  {
    return NULL;
  }

  x = new double[n];
//
//  Record the range of X we need to fill in.
//
  x_lo = 1;
  x_hi = n;
//
//  Use up the old value, if we have it.
//
  if ( saved == 1 )
  {
    x[0] = y;
    saved = 0;
    x_lo = 2;
  }
//
//  Maybe we don't need any more values.
//
  if ( x_hi - x_lo + 1 == 0 )
  {
  }
//
//  If we need just one new value, do that here to avoid null arrays.
//
  else if ( x_hi - x_lo + 1 == 1 )
  {
    r = r8vec_uniform_01_new ( 2, seed );

    x[x_hi-1] = sqrt ( -2.0 * log ( r[0] ) ) * cos ( 2.0 * pi * r[1] );
    y =         sqrt ( -2.0 * log ( r[0] ) ) * sin ( 2.0 * pi * r[1] );

    saved = 1;

    made = made + 2;

    delete [] r;
  }
//
//  If we require an even number of values, that's easy.
//
  else if ( ( x_hi - x_lo + 1 ) % 2 == 0 )
  {
    m = ( x_hi - x_lo + 1 ) / 2;

    r = r8vec_uniform_01_new ( 2*m, seed );

    for ( i = 0; i <= 2*m-2; i = i + 2 )
    {
      x[x_lo+i-1] = sqrt ( -2.0 * log ( r[i] ) ) * cos ( 2.0 * pi * r[i+1] );
      x[x_lo+i  ] = sqrt ( -2.0 * log ( r[i] ) ) * sin ( 2.0 * pi * r[i+1] );
    }
    made = made + x_hi - x_lo + 1;

    delete [] r;
  }
//
//  If we require an odd number of values, we generate an even number,
//  and handle the last pair specially, storing one in X(N), and
//  saving the other for later.
//
  else
  {
    x_hi = x_hi - 1;

    m = ( x_hi - x_lo + 1 ) / 2 + 1;

    r = r8vec_uniform_01_new ( 2*m, seed );

    for ( i = 0; i <= 2*m-4; i = i + 2 )
    {
      x[x_lo+i-1] = sqrt ( -2.0 * log ( r[i] ) ) * cos ( 2.0 * pi * r[i+1] );
      x[x_lo+i  ] = sqrt ( -2.0 * log ( r[i] ) ) * sin ( 2.0 * pi * r[i+1] );
    }

    i = 2*m - 2;

    x[x_lo+i-1] = sqrt ( -2.0 * log ( r[i] ) ) * cos ( 2.0 * pi * r[i+1] );
    y           = sqrt ( -2.0 * log ( r[i] ) ) * sin ( 2.0 * pi * r[i+1] );

    saved = 1;

    made = made + x_hi - x_lo + 2;

    delete [] r;
  }

  return x;
}

double *r8vec_uniform_01_new ( int n, int &seed )

{
  int i;
  int i4_huge = 2147483647;
  int k;
  double *r;

  if ( seed == 0 )
  {
    cerr << "\n";
    cerr << "R8VEC_UNIFORM_01_NEW - Fatal error!\n";
    cerr << "  Input value of SEED = 0.\n";
    exit ( 1 );
  }

  r = new double[n];

  for ( i = 0; i < n; i++ )
  {
    k = seed / 127773;

    seed = 16807 * ( seed - k * 127773 ) - k * 2836;

    if ( seed < 0 )
    {
      seed = seed + i4_huge;
    }

    r[i] = ( double ) ( seed ) * 4.656612875E-10;
  }

  return r;
}

void timestamp ( )

{
# define TIME_SIZE 40

  static char time_buffer[TIME_SIZE];
  const struct std::tm *tm_ptr;
  std::time_t now;

  now = std::time ( NULL );
  tm_ptr = std::localtime ( &now );

  std::strftime ( time_buffer, TIME_SIZE, "%d %B %Y %I:%M:%S %p", tm_ptr );

  std::cout << time_buffer << "\n";

  return;
# undef TIME_SIZE
}