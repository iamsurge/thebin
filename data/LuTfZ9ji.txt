let v = [];
let e = [];
let tri = [];

class Vertex {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
	draw(ctx) {
		ctx.beginPath();
		ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
		ctx.fill();
	}
}

class Edge {
	constructor(a, b) {
		if (a instanceof Vertex) {
			this.a = a;
		} else {
			this.a = v[a];
		}
		if (b instanceof Vertex) {
			this.b = b;
		} else {
			this.b = v[b];
		}
	}
	draw(ctx) {
		ctx.beginPath();
		if (a instanceof Vertex) {
			ctx.moveTo(v[this.a].x, v[this.a].y);
			ctx.lineTo(v[this.b].x, v[this.b].y);
		ctx.stroke();
	}
}

class Triangle {
	constructor(ABC, abc, tag) {
		this.ABC = ABC;
		this.abc = abc;
		this.tag = tag;
	}
	draw(ctx) {
		e[this.abc[0]].draw(ctx);
		e[this.abc[1]].draw(ctx);
		e[this.abc[2]].draw(ctx);
		v[this.ABC[0]].draw(ctx);
		v[this.ABC[1]].draw(ctx);
		v[this.ABC[2]].draw(ctx);
	}
}

function abstractTriangle(A, B, C, tag) {
	vlen = v.length;
	elen = e.length;
	verts = [
		new Vertex(A[0], A[1]),
		new Vertex(B[0], B[1]),
		new Vertex(C[0], C[1]),
	];
	edges = [
		new Edge(0 + vlen, 1 + vlen),
		new Edge(1 + vlen, 2 + vlen),
		new Edge(2 + vlen, 0 + vlen),
	];
	triangle = new Triangle(
		[0 + vlen, 1 + vlen, 2 + vlen],
		[0 + elen, 1 + elen, 2 + elen],
		tag
	);

	v = v.concat(verts);
	e = e.concat(edges);
	tri.push(triangle);
	return tri.length - 1;
}

random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);

function circumcentre(triangle) {
	// debugger
	A = v[triangle.ABC[0]];
	B = v[triangle.ABC[1]];
	C = v[triangle.ABC[2]];

	O = new Vertex(0, 0);

	mab = (A.y - B.y) / (A.x - B.x);
	mrab = -(1 / mab);
	crab = (A.y + B.y) / 2 - mrab * ((A.x + B.x) / 2);
	perp = (a) => mrab * a + crab;

	mbc = (B.y - C.y) / (B.x - C.x);
	mrbc = -(1 / mbc);
	crbc = (B.y + C.y) / 2 - mrbc * ((B.x + C.x) / 2);

	O.x = (crbc - crab) / (mrab - mrbc);
	O.y = perp(O.x);

	r = Math.sqrt((O.x - A.x) ** 2 + (O.y - A.y) ** 2);

	return [O, r];
}

function pointInCircle(point, O, r) {
	dist = Math.sqrt((point.x - O.x) ** 2 + (point.y - O.y) ** 2);
	if (dist < r) {
		return true;
	} else {
		return false;
	}
}

function edgeMatch(edge) {
	for (let test = 0; test < tri.length; test++) {
		for (let edge = 0; edge < 3; edge++) {
			console.log(e[tri[test].abc[edge]]);
		}
	}
}

window.onload = () => {
	const canvas = document.getElementById("canvas");
	const ctx = canvas.getContext("2d");
	canvas.width = 500;
	canvas.height = 500;
	let bad = [];
	let poly = [];
	let points = [];

	for (let i = 0; i < 16; i++) {
		points.push(new Vertex(random(10, 490), random(0, 490)));
	}

	//super tri
	let bigboi = abstractTriangle([1, 1], [1000, 2], [2, 1000]);
	ctx.fillStyle = "red";
	ctx.strokeStyle = "red";
	tri[bigboi].draw(ctx);
	ctx.fillStyle = "black";
	ctx.strokeStyle = "black";

	for (let i = 0; i < points.length; i++) {
		bad = [];
		for (let t = 0; t < tri.length; t++) {
			circumcircle = circumcentre(tri[t]);
			if (pointInCircle(points[i], circumcircle[0], circumcircle[1])) {
				bad.push(t);
			}
		}
		poly = [];
		for (let b = 0; b < bad.length; b++) {
			edgeMatch(new Edge(new Vertex()));
		}
	}
};
