forest = []

with open("08_input.txt") as infile:
    for line in infile.readlines():
        forest.append([]) # Make a row for every line...
        for char in line.strip("\r\n"):
            forest[-1].append(int(char)) # ...and a tree for every number in that row

def look(direction, forest, cur_row, cur_col): # Simulates looking in a direction (numeric for use with range), returns trees seen and whether it was obstructed before the edge
    own_height = forest[cur_row][cur_col]
    trees_seen = 0
    saw_to_edge = True
    
    # witchery to look in any direction without rewriting the whole for loop
    look_range = None
    if direction == 0: # left; look behind on left-right axis
        look_range = range(cur_col-1, -1, -1)
    elif direction == 1: # right; look ahead on left-right axis
        look_range = range(cur_col+1, len(forest[0]))
    elif direction == 2: # up; look behind on up-down axis
        look_range = range(cur_row-1, -1, -1)
    elif direction == 3: # down; look ahead on up-down axis
        look_range = range(cur_row+1, len(forest))
        
    for i in look_range:
        trees_seen += 1 # We're always gonna see another tree, so add 1, just stop here if that tree happens to be too big
        row = 0
        col = 0
        if direction == 0 or direction == 1: # left or right; row is static, column is variable
            row = cur_row
            col = i
        else: # up or down; row is variable, column is static
            row = i
            col = cur_col
        if forest[row][col] >= own_height: # If we see a tree of the same height as ours or higher, we're done
            saw_to_edge = False # We'll never reach this block when looking in a direction where the tree can see the edge
            break
    return [trees_seen, saw_to_edge]

max_tree_scenic_value = 0
trees_visible = 0

for row in range(len(forest)):
    for col in range(len(forest[0])): # For each tree, look all around
        cur_tree_scenic_value = 1
        visible_from_edge = False
        for direction in range(4): # Look in every direction
            result = look(direction, forest, row, col)
            cur_tree_scenic_value *= result[0]
            if result[1]: # Tree saw to edge, thus vice versa
                visible_from_edge = True
        max_tree_scenic_value = max(cur_tree_scenic_value, max_tree_scenic_value)
        if visible_from_edge: #If it was visible from any edge, count it
            trees_visible += 1

print("Trees visible from edge: "+str(trees_visible)+"\nBest scenic value: "+str(max_tree_scenic_value))