struct Node {
    int x, y;
    int val;
    Node() {}
    Node(int xx, int yy, int v) {
        x = xx;
        y = yy;
        val = v;
    }
};

bool operator<(const Node &a, const Node &b) {
    return a.val > b.val;
}

const int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};

class Solution {
public:
    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {
        int n = grid.size();
        int m = grid[0].size();
        priority_queue<Node> que;
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        que.push(Node(0, 0, grid[0][0]));
        vis[0][0] = true;
        int mx = 0;
        int cnt = 0;
        map<int, int> mp;
        while (!que.empty()) {
            Node tmp = que.top();
            que.pop();
            mx = max(mx, tmp.val);
            ++cnt;
            mp[mx] = cnt;
            for (int i = 0; i < 4; ++i) {
                int xx = tmp.x + dir[i][0];
                int yy = tmp.y + dir[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m && !vis[xx][yy]) {
                    que.push(Node(xx, yy, grid[xx][yy]));
                    vis[xx][yy] = true;
                }
            }
        }
        vector<int> ans;
        for (auto q: queries) {
            auto it = mp.lower_bound(q);
            if (it == mp.begin()) {
                ans.push_back(0);
            } else {
                --it;
                ans.push_back(it->second);
            }
        }
        return ans;
    }
};