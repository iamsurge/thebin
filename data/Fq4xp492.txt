Write program that generate Perlin noise map

#include <iostream> 
#include <cstdlib> 
#include <cmath>

using namespace std; 

// Constants 
const int WIDTH = 100; 
const int HEIGHT = 100; 

// Function prototypes 
float ** createNoiseMap(); 
float interpolate(float x0, float x1, float alpha); 
void generatePerlinNoise(float ** noiseMap, int octave);

// Main function 
int main() 
{ 
    // Create noise map 
    float ** noiseMap = createNoiseMap(); 
  
    // Generate Perlin noise 
    generatePerlinNoise(noiseMap, 4); 
  
    return 0; 
} 

// Function to create 2d noise map 
float ** createNoiseMap() 
{ 
    float ** noiseMap = new float*[HEIGHT]; 
  
    // Allocate memory 
    for (int i = 0; i < HEIGHT; i++) 
        noiseMap[i] = new float[WIDTH]; 
  
    // Generate random values in given range 
    for (int i = 0; i < HEIGHT; i++) 
        for (int j = 0; j < WIDTH; j++) 
            noiseMap[i][j] = rand() % 101 / 100.0f; 
  
    return noiseMap; 
} 

// Function to interpolate between two values 
float interpolate(float x0, float x1, float alpha) 
{ 
    return x0 * (1 - alpha) + alpha * x1; 
} 

// Function to generate Perlin noise 
void generatePerlinNoise(float ** noiseMap, int octave) 
{ 
    for (int i = 0; i < octave; i++) 
    { 
        int samplePeriod = 1 << i; // calculates 2 ^ k 
        float sampleFrequency = 1.0f / samplePeriod; 
  
        for (int j = 0; j < HEIGHT; j++) 
        { 
            //calculate the horizontal sampling indices 
            int sample_i0 = (j / samplePeriod) * samplePeriod; 
            int sample_i1 = (sample_i0 + samplePeriod) % HEIGHT; //wrap around 
            float horizontal_blend = (j - sample_i0) * sampleFrequency; 
  
            for (int k = 0; k < WIDTH; k++) 
            { 
                //calculate the vertical sampling indices 
                int sample_j0 = (k / samplePeriod) * samplePeriod; 
                int sample_j1 = (sample_j0 + samplePeriod) % WIDTH; //wrap around 
                float vertical_blend = (k - sample_j0) * sampleFrequency; 
  
                //blend the top two corners 
                float top = interpolate(noiseMap[sample_i0][sample_j0], 
                                        noiseMap[sample_i1][sample_j0], 
                                        horizontal_blend); 
  
                //blend the bottom two corners 
                float bottom = interpolate(noiseMap[sample_i0][sample_j1], 
                                        noiseMap[sample_i1][sample_j1], 
                                        horizontal_blend); 
  
                //final blend 
                noiseMap[j][k] = interpolate(top, bottom, vertical_blend); 
            } 
        } 
    } 
}