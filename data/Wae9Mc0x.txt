#!/usr/bin/python
# -*- coding: utf-8 -*-
from typing import List, Set, Dict
import networkx as nx
 
 
# Pomocnicza definicja podpowiedzi typu reprezentującego etykietę
# wierzchołka (liczba 1..n).
VertexID = int
 
# Pomocnicza definicja podpowiedzi typu reprezentującego listę sąsiedztwa.
AdjList = Dict[VertexID, List[VertexID]]
 
Distance = int
 
def neighbors(adjlist: AdjList, start_vertex_id: VertexID,
              max_distance: Distance) -> Set[VertexID]:

    colour = []
    for u in AdjList:
        colour[u] = 'WHITE'
    colour[VertexID] = 'GREY'
    Q = []
    Distance = u - VertexID
    Q.append({VertexID, Distance})
    while not Q :
        Q.pop([u])
        for v in colour[u]:
            if v == 'WHITE':
                colour[v] = 'GREY'
                Q.append(v)
        colour[u] = 'BLACK'
        

    return 

VertexID = int
EdgeID = int
 
 
# Nazwana krotka reprezentująca segment ścieżki.
class TrailSegmentEntry:
    pass  # FIXME: Uzupełnij!
 
 
Trail = List[TrailSegmentEntry]
 
 
def load_multigraph_from_file(filepath: str) -> nx.MultiDiGraph:
    """Stwórz multigraf na podstawie danych o krawędziach wczytanych z pliku.
 
    :param filepath: względna ścieżka do pliku (wraz z rozszerzeniem)
    :return: multigraf
    """
 
    return None
 
 
def find_min_trail(g: nx.MultiDiGraph, v_start: VertexID, v_end: VertexID) -> Trail:
    """Znajdź najkrótszą ścieżkę w grafie pomiędzy zadanymi wierzchołkami.
 
    :param g: graf
    :param v_start: wierzchołek początkowy
    :param v_end: wierzchołek końcowy
    :return: najkrótsza ścieżka
    """
    return None
 
 
def trail_to_str(trail: Trail) -> str:
    """Wyznacz reprezentację tekstową ścieżki.
 
    :param trail: ścieżka
    :return: reprezentacja tekstowa ścieżki
    """
    return None
