#!/usr/bin/python
# -*- coding: utf-8 -*-
from typing import List, Dict
import unittest
from math import sqrt
import random

def adjmat_to_adjlist(adjmat: List[List[int]]) -> Dict[int, List[int]]:
    adjlist = {}
    for key, i in enumerate(adjmat, start = 1): # wchodzi do slownika
        g = []   
        for key2, i2 in enumerate(i, start = 1):    # wchodzi do listy z klucza slownika
            if i2 != 0:
                for i3 in range (i2):   # ta petla mnozy jej zawartosc tylekroc, jaka wartosc ma dana wartosc listy (sciezki skierowane i nieskierowane)
                    g.append(key2)      # dodaje do g numer wartosci ktora  jest rozna od 0 
            adjlist[key] = g            # przekazuje liste do klucza
        if len(adjlist[key]) == 0:      # usuwa puste klucze
            adjlist.pop(key)            
    return adjlist

def dfs_recursive(G: Dict[int, List[int]], s: int) -> List[int]:
    visited = []
                            # wrap funkcji by ustalic stala wartosc odwiedzonych wierzch i zwracac wielokrotnie visited pokazujac sciezke
    def dfs_inplace(G, s, visited):     
        visited.append(s)           # kolejny wierzch
        for neighbor in G[s]:
            if neighbor not in visited:       # dodaje do funkcji kolejny wierzch w ktorym jeszcze nie byl(sprawdza w visited)
                visited = dfs_inplace(G, neighbor, visited)     #wywoluje rekurencje dopoki nie wykorzysta wszystkich "nowych" opcji
        return visited                  # zwraca kazdy etap sciezki

    return dfs_inplace(G, s, visited)


 
def dfs_iterative(G: Dict[int, List[int]], s: int) -> List[int]:
    stack, visited = [s], []
    while stack:
        vertex = stack.pop()
        if vertex in visited:
            continue
        visited.append(vertex)
        for neighbour in G[vertex]:
            stack.append(neighbour)
    return visited			# tego mi sie nie chce opisywac bo sam nw do konca co tu zdzialalem

def is_acyclic(G: Dict[int, List[int]]) -> bool:
    
    visited = []        #sciezka odwiedzonych wierzcholkow
    
    def visit(vertex):      
        visited.append(vertex)      #kolejny wierzch do sciezki
        for neighbour in G.get(vertex, ()):
            if neighbour in visited or visit(neighbour):    #sprawdza czy jest w siezce lub przechodzi na kolejny do momentu, az sprawdzi wszystkie wierzcholki
                return False
        visited.remove(vertex)
        return True # w ostatecznosci zwraca wartosc prawda, jesli zablokuje sie na jednym z wierzcholkow

    return any(visit(v) for v in G)

	# od teraz reszta sprawdza dzialanie funkcji
adjmat1 = [[0, 1, 1, 1, 0], [1, 0, 0, 1, 1],
          [1, 0, 0, 1, 0], [1, 1, 1, 0, 1],
          [0, 1, 0, 1, 0], [0, 0, 0, 0, 0]]
adjmat = [[random.randint(0,2) for i in range(7)], [random.randint(0,2) for i in range(7)],
           [random.randint(0,2) for i in range(7)], [random.randint(0,2) for i in range(7)],
           [random.randint(0,2) for i in range(7)], [random.randint(0,2) for i in range(7)],
           [random.randint(0,2) for i in range(7)]]

adjlist = adjmat_to_adjlist(adjmat1)
print (adjmat)

print('\n \n \t zadanie 1.adjamat to adlist:')
print (adjmat_to_adjlist(adjmat1))

print('\n \n \t zadanie 2.dfs_recursive(adlist):')
print (dfs_recursive(adjlist, 1))

print('\n\n \t zadanie 3.dfs_iterative(adlist):')
print (dfs_iterative(adjlist, 1))

print('\n\n \t zadanie 4.iscyclic(adlist):')
print(is_acyclic(adjlist))