import { createLibp2p } from 'libp2p'
import { webSockets } from '@libp2p/websockets'
import { webRTCStar } from '@libp2p/webrtc-star'
import { noise } from '@chainsafe/libp2p-noise'
import { mplex } from '@libp2p/mplex'
import { bootstrap } from '@libp2p/bootstrap'
import { peerIdFromString } from '@libp2p/peer-id'

document.addEventListener('DOMContentLoaded', async () => {
    const wrtcStar = webRTCStar()

    // Create our libp2p node
    const libp2p = await createLibp2p({
        addresses: {
            // Add the signaling server address, along with our PeerId to our multiaddrs list
            // libp2p will automatically attempt to dial to the signaling server so that it can
            // receive inbound connections from other peers
            listen: [
                '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',
                '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star'
            ]
        },
        transports: [
            webSockets(),
            wrtcStar.transport
        ],
        connectionEncryption: [noise()],
        streamMuxers: [mplex()],
        peerDiscovery: [
            wrtcStar.discovery,
            bootstrap({
                list:
                [
                    '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'
                ]
            })
        ]
    })

    // Listen for new peers
    libp2p.addEventListener('peer:discovery', (evt) =>
    {
        const peer = evt.detail
        // console.log("Discovered Peer " + peer.id.toString())

        if (!isConnectedTo(peer.id.toString()))
        {
            connectToPeer(peer.id.toString());
        }

        // Attempt to connect to the peer and open a connection.
        // libp2p.dial(evt.detail.id).catch(err =>
        // {
        //     console.error("Could not dial " + evt.detail.id)
        // })
    })

    // Listen for new connections to peers.
    libp2p.connectionManager.addEventListener('peer:connect', (evt) =>
    {
        const connection = evt.detail
        // console.log("Connected to" + connection.remotePeer.toString())
    })

    // Listen for peers disconnecting.
    libp2p.connectionManager.addEventListener('peer:disconnect', (evt) =>
    {
        const connection = evt.detail
        // console.log("Disconnected from " + connection.remotePeer.toString())
    })

    await libp2p.start() // Initialize the libp2p node.
    console.log('LibP2P Started')
    console.log("Node ID" + libp2p.peerId.toString())

    // Store the Node ID in the HTML.
    document.getElementById('node-id').innerHTML = 'Node ID: ' + libp2p.peerId.toString()

    window.libp2p = libp2p // Export the LibP2P node.
})

function isConnectedTo(peerID)
{
    return libp2p.connectionManager.connections.has(peerID);
}

function createPeerFromID(peerID)
{
    const peer = new peerIdFromString(peerID);
    return peer;
}

function connectToPeer(toID)
{
    var connectTo;
    if (toID === undefined)
    {
        toID = document.getElementById("peer-id").value;
        connectTo = createPeerFromID(toID);
    }
    else
    {
        connectTo = createPeerFromID(toID);
    }

    libp2p.dial(connectTo)
    .then(() =>
        {
            console.log("Connected to " + toID);
            document.getElementById("connect-result").innerHTML = "Connected!";
            return true;
        })
    .catch(err =>
        {
            console.error("Error Connecting to " + toID);
            console.error(err);
            document.getElementById("connect-result").innerHTML = "Error Connecting!";
            return false;
        })
}

window.isConnectedTo = isConnectedTo;
window.connectToPeer = connectToPeer;