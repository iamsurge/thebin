#include <iostream>
#include <vector>

using namespace std;



bool canGoToCell(vector<vector<int>>& matrix, int i, int j) { // проверяет, можно ли попасть в клетку
    if (i < 0 || j < 0 || i >= matrix.size() || j >= matrix[0].size()) {// если вышли за границы
        return false;
    }
    return matrix[i][j] == 0;// если клетка пустая
}

bool isFill(vector<vector<int>>& matrix) {// проверяет, заполнена ли матрица
    for (int i = 0; i < matrix.size(); ++i) {
        for (int j = 0; j < matrix[0].size(); ++j) {
            if (matrix[i][j] == 0) {
                return false;
            }
        }
    }
    return true;
}

bool solution(vector<vector<int>>& matrix, int i, int j, int count, int prev_i, int prev_j) {
    matrix[i][j] = count;// помечаем клетку

    if (count == 25) {// если все клетки заполнены
        return isFill(matrix);// проверяем, заполнена ли матрица
    }
    if (count > 25) {
        return false;
    }

    if (!(i + 3 == prev_i && prev_j == j) && canGoToCell(matrix, i + 3, j)) { // если можно пойти вниз
        if (solution(matrix, i + 3, j, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 3 == prev_i && prev_j == j) && canGoToCell(matrix, i - 3, j)) {// если можно пойти вверх
        if (solution(matrix, i - 3, j, count + 1, i, j)) {
            return true;
        }
    }

    if (!(i == prev_i && prev_j == j + 3) && canGoToCell(matrix, i, j + 3)) { // если можно пойти вправо
        if (solution(matrix, i, j + 3, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i == prev_i && prev_j == j - 3) && canGoToCell(matrix, i, j - 3)) { // если можно пойти влево
        if (solution(matrix, i, j - 3, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i + 2 == prev_i && prev_j == j + 2) && canGoToCell(matrix, i + 2, j + 2)) { // если можно пойти вниз-вправо
        if (solution(matrix, i + 2, j + 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i + 2 == prev_i && prev_j == j - 2) && canGoToCell(matrix, i + 2, j - 2)) { // если можно пойти вниз-влево
        if (solution(matrix, i + 2, j - 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 2 == prev_i && prev_j == j + 2) && canGoToCell(matrix, i - 2, j + 2)) { // если можно пойти вверх-вправо
        if (solution(matrix, i - 2, j + 2, count + 1, i, j)) {
            return true;
        }
    }
    if (!(i - 2 == prev_i && prev_j == j - 2) && canGoToCell(matrix, i - 2, j - 2)) { // если можно пойти вверх-влево
        if (solution(matrix, i - 2, j - 2, count + 1, i, j)) {
            return true;
        }
    }

    matrix[i][j] = 0;// если никуда не попасть, то отмечаем клетку как пустую
    return false;// и возвращаем false
}

int main() {
    int x, y;
    vector<vector<int>> matrix(5, vector<int>(5));
    cout << "Enter start cell of matrix(1-5): ";
    cin >> x >> y;
    solution(matrix, x - 1, y - 1, 1, -1, -1);// запускаем рекурсивную функцию
    for (auto x : matrix) {
        for (auto y : x) {
            printf("%4d\t", y);
        }
        cout << endl;
    }
    return 0;
}