//////////////
//   TEST   //
//  main.c  //
 
//////////////
// INCLUDES //
 
#include <stdio.h>
#include <dos.h>
#include <string.h>
#include <math.h>
 
#include "keyb.h"
 
//////////////
// DEFINES  //
 
#define VIDEO_INT           0x10 // BIOS video interrupt
#define SET_MODE            0x00 // BIOS call to set the video mode
#define VGA_256_COLOR_MODE  0x13 // 320x200 256-color mode
#define TEXT_MODE           0x03 // 80x25 text mode
 
#define VGA                 0xA0000000L
#define SCREEN_SIZE         64000u
#define SCREEN_WIDTH        320
#define SCREEN_HEIGHT       200
 
#define COLOR_BLACK         0
#define COLOR_BLUE          1
#define COLOR_GREEN         2
#define COLOR_CYAN          3
#define COLOR_RED           4
#define COLOR_PURPLE        5
#define COLOR_BROWN         6
#define COLOR_L_GREY        7
#define COLOR_D_GREY        8
#define COLOR_L_BLUE        9
#define COLOR_L_GREEN       10
#define COLOR_L_CYAN        11
#define COLOR_L_RED         12
#define COLOR_L_PURPLE      13
#define COLOR_YELLOW        14
#define COLOR_WHITE         15
 
#define DEG_360 (M_PI*2)
#define DEG_270 (M_PI*1.5)
#define DEG_180 (M_PI)
#define DEG_120 (M_PI/1.5)
#define DEG_90  (M_PI/2)
#define DEG_60  (M_PI/3)
#define DEG_45  (M_PI/4)
#define DEG_30  (M_PI/6)
#define DEG_15  (M_PI/12)
#define DEG_10  (M_PI/18)
#define DEG_5   (M_PI/36)
#define DEG_1   (M_PI/180)
 
#define BG_COLOR            COLOR_BLUE
#define BULLET_COLOR        COLOR_YELLOW

#define SHIP_RADIUS         8
#define SHIP_ACCELERATE     0.40
#define SHIP_SLOWDOWN       0.95
#define SHIP_TURN_RATE      DEG_10

#define MAX_ASTEROIDS       20
#define ASTEROID_RADIUS     20
#define ASTEROID_MIN_RADIUS (ASTEROID_RADIUS/2)
#define ASTEROID_COLOR      COLOR_GREEN

#define MAX_BULLETS             10
#define BULLET_SPEED            7
#define BULLET_SPAWN_DISTANCE   (SHIP_RADIUS + 2)

 
#if SCREEN_WIDTH == 320
#define Y_OFFSET(i) (((i)<<8)+((i)<<6))
#else
#define Y_OFFSET(i) ((i)*SCREEN_WIDTH)
#endif

#define DONT_INTERSECT 0
#define DO_INTERSECT   1
#define OUTCODE_INSIDE 0
#define OUTCODE_LEFT   0x1
#define OUTCODE_RIGHT  0x2
#define OUTCODE_TOP    0x4
#define OUTCODE_BOTTOM 0x8
 
#define MIN(a,b) (((a) < (b)) ? (a) : (b))
#define MAX(a,b) (((a) > (b)) ? (a) : (b))
#define SIGN(x)  (((x) < 0) ? -1 : (((x) > 0) ? 1 : 0))
#define ABS(x)   (((x) < 0) ? -(x) : (x))
#define N_ELEMS(x) (sizeof(x) / sizeof((x)[0]))
 
//////////////
// STRUCTS  //
 
struct Vec2
{
 
    float x;
    float y;
};

struct Polygon
{
    int num_vertices;
    struct Vec2* vertices;
};
 
struct Body
{
    struct Vec2 pos;
    struct Vec2 vel;
    struct Vec2 dir;
    float speed;
    float angle;
    float angvel;
    float radius;
    float scale;
    char color;
    struct Polygon* poly;
};

struct Bullet
{
    struct Vec2 pos;
    struct Vec2 vel;
};
 
//////////////
// GLOBALS  //
 
int quit = 0;
int asteroid_count = 0;
int bullet_count = 0;
 
unsigned char far *screen = (unsigned char *)VGA;
unsigned char far off_screen[SCREEN_SIZE];
 
///////////////
//  STRUCT   //
// INSTANCES //
 
struct Body Ship;
struct Body Asteroids[MAX_ASTEROIDS];
struct Bullet Bullets[MAX_BULLETS];

struct Vec2 vertices_ship[]     = { {1,0}, {-1,-1}, {-0.5,0}, {-1,1} };
struct Vec2 vertices_asteroid[] = { {1,1}, {1.3,0}, {1,-1}, {-1,-1}, {-1.3,0}, {-1,1} };

struct Polygon poly_ship = { N_ELEMS(vertices_ship), vertices_ship };
struct Polygon poly_asteroid = { N_ELEMS(vertices_asteroid), vertices_asteroid };
 
/////////////////
// INITIALIZER //
//  FUNCTIONS  //
 
struct Vec2 newVec2(float x, float y)
{
    struct Vec2 v; // initializes a struct
    v.x = x; // assigns the given parameters
    v.y = y; // --""--
 
    return v; // returns the struct to wherever it was called
}
 
struct Body newBody(float xpos, float ypos, float xvel, float yvel, float angvel, float radius, char color, struct Polygon* poly)
{
    struct Body b;
    b.pos = newVec2(xpos,ypos);
    b.vel = newVec2(xvel,yvel);
    b.angvel = angvel;
    b.radius = radius*0.8;
    b.scale = radius;
    b.color = color;
    b.poly = poly;
 
    return b;
}
 
///////////////
//   RENDER  //
// FUNCTIONS //
 
void setVideoMode(char mode)
{
    union REGS regs;
 
    regs.h.ah = SET_MODE;
    regs.h.al = mode;
    int86(VIDEO_INT, &regs, &regs);
}
 
void drawRectFill(int x, int y, int w, int h, unsigned char color)
{
    unsigned char far* pix;
 
    if (x < SCREEN_WIDTH && y < SCREEN_HEIGHT)
    {
        if (y < 0)
        {
            h += y;
            y = 0;
        }
        if (h > 0)
        {
            if (x < 0)
            {
                w += x;
                x = 0;
            }
            if (w > 0)
            {
                if (x+w > SCREEN_WIDTH)
                    w = SCREEN_WIDTH - x;
                if (y+h > SCREEN_HEIGHT)
                    h = SCREEN_HEIGHT - y;
                pix = off_screen + Y_OFFSET(y) + x;
                for (; (h--); pix += SCREEN_WIDTH)
                    _fmemset(pix, color, w);
            }
        }
    }
}

void setPixel(int x, int y, unsigned char color)
{
    *(off_screen+x + Y_OFFSET(y)) = color;
}

unsigned char pointInScreen(int x, int y)
{
    unsigned char outcode = OUTCODE_INSIDE;
 
    if      (x < 0)              outcode |= OUTCODE_LEFT;
    else if (x >= SCREEN_WIDTH)  outcode |= OUTCODE_RIGHT;
    if      (y < 0)              outcode |= OUTCODE_TOP;
    else if (y >= SCREEN_HEIGHT) outcode |= OUTCODE_BOTTOM;
 
    return outcode;
}
 
int clipLineToScreen(struct Vec2* p0, struct Vec2* p1)
{
    int x, y, dx, dy;
    int ax = p0->x;
    int ay = p0->y;
    int bx = p1->x;
    int by = p1->y;
    unsigned char outcode;
    unsigned char outcode0 = pointInScreen(ax, ay);
    unsigned char outcode1 = pointInScreen(bx, by);
 
    while (1)
    {
        if ((outcode0 | outcode1) == OUTCODE_INSIDE)
            return DO_INTERSECT;
        else if ((outcode0 & outcode1) != OUTCODE_INSIDE)
            return DONT_INTERSECT;
        else
        {
            outcode = MAX(outcode0, outcode1);
            dx = bx-ax;
            dy = by-ay;
 
            if (outcode & OUTCODE_LEFT)
            {
                y = ay + (-ax*dy + dx/2) / dx;
                x = 0;
            }
            else if (outcode & OUTCODE_RIGHT)
            {
                y = ay + ((SCREEN_WIDTH-ax)*dy + dx/2) / dx;
                x = SCREEN_WIDTH-1;
            }
            else if (outcode & OUTCODE_TOP)
            {
                x = ax + (-ay*dx + dy/2) / dy;
                y = 0;
            }
            else if (outcode & OUTCODE_BOTTOM)
            {
                x = ax + ((SCREEN_HEIGHT-ay)*dx + dy/2) / dy;
                y = SCREEN_HEIGHT-1;
            }
 
            if (outcode == outcode0)
            {
                p0->x = ax = x;
                p0->y = ay = y;
                outcode0 = pointInScreen(ax, ay);
            }
            else
            {
                p1->x = bx = x;
                p1->y = by = y;
                outcode1 = pointInScreen(bx, by);
            }
        }
    }
}

void drawLineSlope(int ax, int ay, int bx, int by, unsigned char color)
{
	int i, x, y, px, py;
	
	const int dx = bx - ax;
	const int dy = by - ay;
	const int dx_abs = ABS(dx);
	const int dy_abs = ABS(dy);
	const int x_sign = SIGN(dx);
	const int y_sign = SIGN(dy);
	
	x = dy_abs >> 1;
	y = dx_abs >> 1;
	
	// Starting point
	px = ax;
	py = ay;

	if (dx_abs > dy_abs)
	{
		for (i = 0; i <= dx_abs; i++)
		{
			setPixel(px, py, color);
			y += dy_abs;
			if (y >= dx_abs)
			{
				y -= dx_abs;
				py += y_sign;
			}
			px += x_sign;
		}
	}
	else
	{
		for (i = 0; i <= dy_abs; i++)
		{
			setPixel(px, py, color);
			x += dx_abs;
			if (x >= dy_abs)
			{
				x -= dy_abs;
				px += x_sign;
			}
			py += y_sign;
		}
	}
}
 
void drawLine(struct Vec2 p0, struct Vec2 p1, unsigned char color)
{
    if (clipLineToScreen(&p0, &p1) == DO_INTERSECT)
    {
        drawLineSlope(p0.x, p0.y, p1.x, p1.y, color);
    }
}

 
void drawPolygon(struct Vec2 pos, struct Polygon* poly, float angle, float scale, unsigned char color)
{
    int i;
    struct Vec2 line_start;
    struct Vec2 line_end;
    
    for (i = 0; i < poly->num_vertices-1; i++) // loop through all vertices except for the last one (hence 5-1)
    {
        line_start = newVec2(
            pos.x + scale * (cos(angle)*poly->vertices[i].x - sin(angle)*poly->vertices[i].y),
            pos.y + scale * (sin(angle)*poly->vertices[i].x + cos(angle)*poly->vertices[i].y));
        
        line_end = newVec2(
            pos.x + scale * (cos(angle)*poly->vertices[i+1].x - sin(angle)*poly->vertices[i+1].y),
            pos.y + scale * (sin(angle)*poly->vertices[i+1].x + cos(angle)*poly->vertices[i+1].y));
        
        drawLine(line_start, line_end, color);
    }
    
    // and draw the last line, between the first vertex and last vertex
    line_start = newVec2(
        pos.x + scale * (cos(angle)*poly->vertices[poly->num_vertices-1].x - sin(angle)*poly->vertices[poly->num_vertices-1].y),
        pos.y + scale * (sin(angle)*poly->vertices[poly->num_vertices-1].x + cos(angle)*poly->vertices[poly->num_vertices-1].y));
    
    line_end = newVec2(
        pos.x + scale * (cos(angle)*poly->vertices[0].x - sin(angle)*poly->vertices[0].y),
        pos.y + scale * (sin(angle)*poly->vertices[0].x + cos(angle)*poly->vertices[0].y));
                         
    drawLine(line_start, line_end, color);
}
 
void drawBody(struct Body b)
{
    drawPolygon(b.pos, b.poly, b.angle, b.radius,  b.color);
}            
 
void drawAsteroids()
{
    int i;
    for (i = 0; i < asteroid_count; i++)
    {
        drawBody(Asteroids[i]);
    }
}

void drawBullets()
{
    int i;
    for (i = 0; i < bullet_count; i++)
    {
        setPixel(Bullets[i].pos.x, Bullets[i].pos.y, BULLET_COLOR);
    }
}
 
void render()
{
    memset(off_screen, BG_COLOR, SCREEN_SIZE);
 
    drawBody(Ship);
    drawAsteroids();
    drawBullets();
 
    memcpy(screen,off_screen,SCREEN_SIZE);
    delay(1);
}
 
///////////////
//   LOGIC   //
// FUNCTIONS //

void moveBody(struct Body* b)
{
    (*b).pos.x += (*b).vel.x;
    (*b).pos.y += (*b).vel.y;
    (*b).angle += (*b).angvel;
    (*b).dir.x = cos((*b).angle);
    (*b).dir.y = sin((*b).angle);
}

void moveShip()
{
    moveBody(&Ship);
    Ship.vel.x *= SHIP_SLOWDOWN;
    Ship.vel.y *= SHIP_SLOWDOWN;
}

void moveAsteroids()
{
    int i;
    for (i = 0; i < asteroid_count; i++)
    {
        moveBody(&Asteroids[i]);
    }
}

void spawnBullet(struct Vec2 pos, struct Vec2 vel)
{
    if (bullet_count < MAX_BULLETS)
    {
        Bullets[bullet_count].pos = pos;
        Bullets[bullet_count].vel = vel;
        bullet_count++;
    }
}

void destroyBullet(int index)
{
    // overwrite bullet at index with the last bullet (bullet_count-1)
    Bullets[index] = Bullets[bullet_count-1];
    bullet_count--; // decrement the count
}

void moveBullets()
{
    int i;
    for (i = 0; i < bullet_count; i++)
    {
        Bullets[i].pos.x += Bullets[i].vel.x;
        Bullets[i].pos.y += Bullets[i].vel.y;
        
        if (pointInScreen(Bullets[i].pos.x, Bullets[i].pos.y) != OUTCODE_INSIDE)
            destroyBullet(i);
    }
}

void fireBullet()
{
    struct Vec2 bullet_spawn_position, bullet_velocity;

    bullet_spawn_position = newVec2(
        Ship.pos.x + Ship.dir.x * BULLET_SPAWN_DISTANCE,
        Ship.pos.y + Ship.dir.y * BULLET_SPAWN_DISTANCE);
        
    bullet_velocity = newVec2(
        Ship.dir.x * BULLET_SPEED,
        Ship.dir.y * BULLET_SPEED);
                                 
    spawnBullet(bullet_spawn_position, bullet_velocity);
}

void warpBody(struct Body* b)
{
    // detect ship going past left or right screen boundaries
    if ((*b).pos.x > SCREEN_WIDTH + (*b).radius)
        (*b).pos.x = -(*b).radius;
    if ((*b).pos.x < -(*b).radius)
        (*b).pos.x = SCREEN_WIDTH + (*b).radius;
 
    // detect ship going past top or bottom screen boundaries
    if ((*b).pos.y > SCREEN_HEIGHT + (*b).radius)
        (*b).pos.y = -(*b).radius;
    if ((*b).pos.y < -(*b).radius)
        (*b).pos.y = SCREEN_HEIGHT + (*b).radius;
 
}

void warpShip()
{
    warpBody(&Ship);
}
 
void warpAsteroids()
{
    int i;
    
    for (i = 0; i < asteroid_count; i++)
    {
        warpBody(&Asteroids[i]);
    }
}

void destroyAsteroid(int index)
{
    // overwrite asteroid at index with the last asteroid (asteroid_count-1)
    Asteroids[index] = Asteroids[asteroid_count-1];
    asteroid_count--; // decrement the count
}

void spawnAsteroid(float x, float y, float scale)
{
    float xvel = (rand()%100-50)/25.0;
    float yvel = (rand()%100-50)/25.0;
    float angvel = (rand()%100-50)/100.0;
    unsigned char color = rand()%16;
    
    if (color == BG_COLOR)
        color++;
    
    if (asteroid_count < MAX_ASTEROIDS)
    {
        Asteroids[asteroid_count] = newBody(x, y, xvel, yvel, angvel, scale, color, &poly_asteroid);
        asteroid_count++;
    }
}

void breakAsteroid(int index)
{
    if (Asteroids[index].radius < ASTEROID_MIN_RADIUS)
        destroyAsteroid(index);
    else
    {
        struct Vec2 old_asteroid_position;
        float new_asteroid_radius;
        
        old_asteroid_position = Asteroids[index].pos;
        new_asteroid_radius = Asteroids[index].radius/2; 
        
        destroyAsteroid(index);
        
        spawnAsteroid(old_asteroid_position.x - new_asteroid_radius, old_asteroid_position.y, new_asteroid_radius);
        spawnAsteroid(old_asteroid_position.x + new_asteroid_radius, old_asteroid_position.y, new_asteroid_radius);
    }
}

void collideShipAsteroids()
{
    int i;
    float dx, dy, distance;
    
    for (i = 0; i < asteroid_count; i++)
    {
        dx = Ship.pos.x - Asteroids[i].pos.x;
        dy = Ship.pos.y - Asteroids[i].pos.y;
        
        if (sqrt(dx*dx + dy*dy) < Ship.radius + Asteroids[i].radius)
            destroyAsteroid(i);
    }
}

void collideBulletsAsteroids()
{
    int i, j;
    float dx, dy, distance;
    
    for (j = 0; j < bullet_count; j++)
    {
        for (i = 0; i < asteroid_count; i++)
        {
            dx = Bullets[j].pos.x - Asteroids[i].pos.x;
            dy = Bullets[j].pos.y - Asteroids[i].pos.y;
            
            if (sqrt(dx*dx + dy*dy) < Asteroids[i].radius)
            {
                destroyBullet(j);
                breakAsteroid(i);
                
                i -= 2;
                
                if (j >= bullet_count)
                    break;
            }
        }
    }
}

void logic()
{
    /* MOVEMENT LOGIC */

    moveShip();
    moveAsteroids();
    moveBullets();
    
    warpAsteroids();
    warpShip();
    
    collideShipAsteroids();
    collideBulletsAsteroids();
}
 
///////////////
//   MAIN    //
// FUNCTIONS //
 
void input()
{
    /* INPUT */
 
    if (KEY_WAS_HIT(KEY_ESC))
        quit = 1;
    if (KEY_IS_PRESSED(KEY_UP))
    {
        Ship.vel.x += Ship.dir.x * SHIP_ACCELERATE;
        Ship.vel.y += Ship.dir.y * SHIP_ACCELERATE;
    }
    if (KEY_IS_PRESSED(KEY_DOWN))
    {
        Ship.vel.x -= Ship.dir.x * SHIP_ACCELERATE;
        Ship.vel.y -= Ship.dir.y * SHIP_ACCELERATE;
    }
 
    if (KEY_IS_PRESSED(KEY_LEFT))
        Ship.angle -= SHIP_TURN_RATE;
 
    if (KEY_IS_PRESSED(KEY_RIGHT))
        Ship.angle += SHIP_TURN_RATE;
    
    if (KEY_WAS_HIT(KEY_A))
        spawnAsteroid(0,0,ASTEROID_RADIUS);
    
     if (KEY_WAS_HIT(KEY_SPACEBAR))
        fireBullet();
 
    clearKeys();
}
 
void initGame()
{
    setVideoMode(VGA_256_COLOR_MODE);
    initKeyboard();
 
    Ship.pos.x = SCREEN_WIDTH/2; // start the ship from ...
    Ship.pos.y = SCREEN_HEIGHT/2; //... the center of the screen
    Ship.vel.x = 0;
    Ship.vel.y = 0;
    Ship.angvel = 0;
    Ship.radius = SHIP_RADIUS;
    Ship.color = COLOR_WHITE;
    Ship.poly = &poly_ship;
    
    spawnAsteroid(0,0,ASTEROID_RADIUS);
    spawnAsteroid(0,0,ASTEROID_RADIUS);
    spawnAsteroid(0,0,ASTEROID_RADIUS);
    spawnAsteroid(0,0,ASTEROID_RADIUS);
    spawnAsteroid(0,0,ASTEROID_RADIUS);
}
 
void quitGame()
{
    setVideoMode(TEXT_MODE);
    deinitKeyboard();
}
 
int main()
{
    initGame();
 
    while (quit == 0)
    {
        input();
        logic();
        render();
        delay(5);
    }
 
    quitGame();
 
    return 0;
}