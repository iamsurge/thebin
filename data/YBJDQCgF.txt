// clang-format off
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
#define sqrt sqrtl
#define F first
#define S second
#define endl '\n'
#define all(vc666) vc666.begin(), vc666.end()
#define allr(vc666) vc666.rbegin(), vc666.rend()
#define int long long
#define degug(x) cerr (#x) << " " << (x) << endl;

const ll INF = (ll)1e18 + 7;
const ll inf = 1e9 + 7;
const ll ONE = 1;
const ll MOD = 1e9 + 7;
ld EPS = 1e-12;
ld PI = 3.1415926535897932384;
mt19937_64 gen(3);

struct SegTree {
    struct Node {
        int val = 0;
    };
    int n;
    vector <Node> t;
    SegTree(int _n) {
        n = 4 * _n;
        t.resize(n);
    }
    void update(int v, int L, int R, int l, int r, int boost) {
        if (r < L || l > R) {
            return;
        }
        else {
            if (l <= L && r >= R) {
                t[v].val += boost;
            }
            else {
                int m = (L + R) / 2;
                update(2 * v, L, m, l, r, boost);
                update(2 * v + 1, m + 1, R, l, r, boost);
                t[v].val = t[v * 2].val + t[v * 2 + 1].val;
            }
        }
    }
    int query(int v, int L, int R, int l, int r) {
        if (r < L || l > R) {
            return 0;
        }
        else {
            if (l <= L && r >= R) {
                return t[v].val;
            }
            else {
                int m = (L + R) / 2;
                return query(2 * v, L, m, l, r) + query(2 * v + 1, m + 1, R, l, r);
            }
        }
    }
};

signed main() {
#ifdef _DEBUG 
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) {
        int n, p, i, j, ans = 0, l, r, m, banned = 0;
        cin >> n >> p;
        vector <int> a(n);
        for (i = 0; i < n; i++) {
            cin >> a[i];
        }
        vector <int> ps(n + 1), ps2(n + 1);
        for (i = 0; i < n; i++) {
            ps[i + 1] = ps[i] + a[i];
            ps2[i + 1] = ps[i + 1];
        }
        sort(all(ps2));
        ps2.resize(unique(all(ps2)) - ps2.begin());
        int N = ps2.size() + 100;
        SegTree tree(N);
        for (i = 1; i <= n; i++) {
            j = lower_bound(all(ps2), ps[i]) - ps2.begin();
            tree.update(1, 0, N - 1, j, j, 1);
        }
        for (i = 0; i < n; i++) {
            j = lower_bound(all(ps2), ps[i + 1]) - ps2.begin();
            l = -1, r = ps2.size();
            while (r - l > 1) {
                m = (l + r) / 2;
                if (ps2[m] - banned < p) {
                    l = m;
                }
                else {
                    r = m;
                }
            }
            ans += tree.query(1, 0, N - 1, 0, l);
            tree.update(1, 0, N - 1, j, j, -1);
            banned += a[i];
        }
        cout << ans << endl;
    }
}
//Deisgned by skimono