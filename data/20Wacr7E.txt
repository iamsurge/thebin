#NoTrayIcon
;FileInstall("F:\AUTOIT\ENVIRONMENT-VARIABLES\ENVIRONMENT-VARIABLES.au3", @ScriptDir & "\ENVIRONMENT-VARIABLES.au3")
;FileSetAttrib(@ScriptDir & "\ENVIRONMENT-VARIABLES.au3", "+H")
#Region    ;************ Includes ************
#Include <WindowsConstants.au3>
#Include <GUIConstantsEx.au3>
#Include <GuiListView.au3>
#Include <WinAPIMisc.au3>
#Include <GuiMenu.au3>
#EndRegion ;************ Includes ************

Opt ( 'GUIResizeMode', $GUI_DOCKAUTO )
Opt ( 'MustDeclareVars', 1 )

Global $hGui, $hListview, $iGuiWidth, $iGuiHeight, $aEnvVariables, $iIndex, $hLVMenu, $bRightClick = False
Global $iExport, $sExportFilePath, $sTxt, $hFile
Global Enum $iId_Copy = 3000, $Id_Save

$aEnvVariables = _WinApi_GetEnvironmentStringsA()
_Gui()
For $i = 0 To UBound ( $aEnvVariables ) -1
    $iIndex = _GUICtrlListView_AddItem ( $hListview, $aEnvVariables[$i][0], -1, 0 )
    _GUICtrlListView_AddSubItem ( $hListView, $iIndex, $aEnvVariables[$i][1], 1 )
Next

#Region ------ Main Loop ------------------------------
While 1
    Switch GUIGetMsg()
        Case $GUI_EVENT_CLOSE
            GUIDelete ( $hGui )
            Exit
        Case Else
            If $bRightClick = True Then
                $bRightClick = False
                $hLVMenu = _GUICtrlMenu_CreatePopup()
                If _GUICtrlMenu_IsMenu ( $hLVMenu ) Then
                    _GUICtrlMenu_InsertMenuItem ( $hLVMenu, 0, 'Copy Selected Variable Name', $iId_Copy )
                    _GUICtrlMenu_InsertMenuItem ( $hLVMenu, 1, 'Export Variables List', $Id_Save )
                    _GUICtrlMenu_SetMenuStyle ( $hLVMenu, BitOR ( $MNS_CHECKORBMP, $MNS_AUTODISMISS, $MNS_NOCHECK ) )
                    _GUICtrlMenu_TrackPopupMenu ( $hLVMenu, $hGui )
                    _GUICtrlMenu_DestroyMenu ( $hLVMenu )
                    $hLVMenu = 0
                EndIf
            EndIf
            If $iExport Then
                $iExport = 0
                $sExportFilePath = FileSaveDialog ( 'Export Variables List', '', 'Text Files (*.txt;*.csv)|All Files (*.*)', 2+16, 'Windows Environment Variables List', $hgui )
                If Not @error Then
                    $sTxt = ''
                    For $i = 0 To UBound ( $aEnvVariables ) -1
                        $sTxt &= StringStripWS ( $aEnvVariables[$i][0], 7 ) & ' : ' & StringStripWS ( $aEnvVariables[$i][1], 7 ) & @CRLF
                    Next
                    $hFile = FileOpen ( $sExportFilePath, 2+8+512 )
                    FileWrite ( $hFile, $sTxt )
                    FileClose ( $hFile )
                EndIf
            EndIf
    EndSwitch
    Sleep ( 10 )
WEnd
#EndRegion --- Main Loop ------------------------------

Func _Gui()
    $hGui = GUICreate ( 'Najeeb Windows Environment Variables Viewer', 700, 600, -1, -1, BitOR ( $WS_MINIMIZEBOX, $WS_MAXIMIZEBOX, $WS_SYSMENU, $WS_SIZEBOX ) )
    GUICtrlCreateListView ( 'Environment Variable Names|Values', 10, 10, 680, 555 )
    $hListview = GUICtrlGetHandle ( -1 )
    _GUICtrlListView_SetColumnWidth ( $hListview, 0, 220 )
    _GUICtrlListView_SetColumnWidth ( $hListview, 1, @DesktopWidth - 270 )
    Local $aPos = WinGetPos( $hGui )
    $iGuiWidth = $aPos[2]
    $iGuiHeight = $aPos[3]
    GUIRegisterMsg ( $WM_GETMINMAXINFO, '_WM_GETMINMAXINFO' )
    GUIRegisterMsg ( $WM_NOTIFY, '_WM_NOTIFY' )
    GUIRegisterMsg ( $WM_COMMAND, '_WM_COMMAND' )
    GUISetState()
EndFunc ;==> _Gui()

Func _WinApi_FreeEnvironmentStringsA ( $pEnv ) ; https://msdn.microsoft.com/en-us/library/windows/desktop/ms683151(v=vs.85).aspx
    Local $aRet = DllCall ( 'kernel32.dll', 'int', 'FreeEnvironmentStringsA', 'ptr', $pEnv )
    If Not @error And $aRet[1] <> 0 Then Return SetError ( 0, @extended, $aRet[1] )
    Return SetError ( @error, 0, 0 )
EndFunc ;==> _WinApi_FreeEnvironmentStringsA()

Func _WinApi_GetEnvironmentStringsA() ; https://msdn.microsoft.com/en-us/library/windows/desktop/ms683187(v=vs.85).aspx
    Local $pEnvBlock, $iPtrStringLen, $tEnvString, $aSplit, $aRet, $sEnvString, $aEnvString[0][2]
    $aRet = DllCall ( 'kernel32.dll', 'ptr', 'GetEnvironmentStringsA' ) ; GetEnvironmentStringsA returns OEM characters.
    If @error Then Return SetError ( @error, @extended, '' )
    $pEnvBlock = $aRet[0] ; pointer to a block of memory that contains the environment variables.
    If Not IsPtr ( $pEnvBlock ) Then Return SetError ( -1, 0, '' )
    While 1
        $iPtrStringLen = _WinAPI_StringLenA ( $pEnvBlock )
        If $iPtrStringLen > 0 Then
            $tEnvString = DllStructCreate ( 'char[' & $iPtrStringLen + 1 & ']', $pEnvBlock )
            $sEnvString = _WinAPI_OemToChar ( DllStructGetData ( $tEnvString, 1 ) ) ; Convert Oem to Ansi.
            If StringLeft ( $sEnvString, 1 ) <> '=' Then
                $aSplit = StringSplit ( $sEnvString, '=', 1+2 )
                If Not @error Then
                    ReDim $aEnvString[UBound ( $aEnvString )+1][2]
                    $aEnvString[UBound ( $aEnvString )-1][0] = $aSplit[0] ; name
                    $aEnvString[UBound ( $aEnvString )-1][1] = $aSplit[1] ; value
                EndIf
            EndIf
            $pEnvBlock += $iPtrStringLen + 1
        Else
            _WinApi_FreeEnvironmentStringsA ( $pEnvBlock ) ; Free memory block.
            $tEnvString = 0
            Return SetError ( 0, 0, $aEnvString )
        EndIf
    WEnd
EndFunc ;==> _WinApi_GetEnvironmentStringsA()

Func _WM_COMMAND ( $hWnd, $iMsg, $wParam, $lParam )
    #forceref $hWnd, $iMsg, $wParam, $lParam
    Switch $wParam
        Case $iId_Copy
            ClipPut ( _GUICtrlListView_GetItemText ( $hListview, _GUICtrlListView_GetSelectedIndices ( $hListview ), 0 ) )
        Case $Id_Save
            $iExport = 1
    EndSwitch
EndFunc ;==> _WM_COMMAND()

Func _WM_GETMINMAXINFO ( $hWnd, $iMsg, $wParam, $lParam )
    #forceref $hWnd, $iMsg, $wParam, $lParam
    Switch $hWnd
        Case $hGui
            Local $tMinMaxInfo = DllStructCreate ( 'int;int;int;int;int;int;int;int', $lParam )
            DllStructSetData ( $tMinMaxInfo, 7, $iGuiWidth )  ; min w
            DllStructSetData ( $tMinMaxInfo, 8, $iGuiHeight ) ; min h
            $tMinMaxInfo = 0 ; Release resource.
    EndSwitch
EndFunc ;==> _WM_GETMINMAXINFO()

Func _WM_NOTIFY ( $hWnd, $iMsg, $wParam, $lParam )
    #forceref $hWnd, $iMsg, $wParam, $lParam
    Local $hWndFrom, $iCode, $tNMHDR, $tInfo
    $tNMHDR = DllStructCreate ( $tagNMLISTVIEW, $lParam )
    $hWndFrom = HWnd ( DllStructGetData ( $tNMHDR, 'hWndFrom' ) )
    $iCode = DllStructGetData ( $tNMHDR, 'Code' )
    $tInfo = DllStructCreate ( $tagNMLISTVIEW, $lParam )
    Switch $hWndFrom
        Case $hListView
            Switch $iCode
                Case $NM_RCLICK
                    If DllStructGetData ( $tInfo, 'Item' ) >= 0 Then
                        If $hLVMenu <> 0 Then _GUICtrlMenu_DestroyMenu ( $hLVMenu )
                        $hLVMenu = 0
                        $bRightClick = True
                    EndIf
            EndSwitch
    EndSwitch
    $tInfo = 0
    $tNMHDR = 0
    Return $GUI_RUNDEFMSG
EndFunc ;==> _WM_NOTIFY()