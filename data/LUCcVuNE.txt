#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <string>


using namespace std;

typedef long long ll;

const int LOG = 17;
const int INF = 1000000000;
int timer = 0;
vector<vector<pair<int, int>>> g;
vector<int> tin, tout;
int up[50000][LOG];
int minn[50000][LOG];


void dfs(int v, int c = INF, int p = 0) {
	tin[v] = timer++;
	up[v][0] = p;
	minn[v][0] = c;
	for (int i = 1; i < LOG; i++) {
		up[v][i] = up[up[v][i - 1]][i - 1];
		minn[v][i] = min(minn[v][i - 1], minn[up[v][i - 1]][i - 1]);
	}

	for (auto u : g[v]) {
		if (u.first != p) {
			dfs(u.first, u.second, v);
		}
	}
	tout[v] = timer++;
}

bool isPar(int u, int v) {
	return tin[u] <= tin[v] && tout[v] <= tout[u];
}

int lca(int u, int v) {
	// так как мы будем искать минимум на двух частях пути
	// то нам нужен только один if с проверкой на родство
	if (isPar(u, v)) {
		return INF;
	}

	int ans = INF;
	for (int i = LOG - 1; i >= 0; i--) {
		if (!isPar(up[u][i], v)) {
			ans = min(ans, minn[u][i]);
			u = up[u][i];
		}
	}

	return min(ans, minn[u][0]);
}

int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	int n;
	cin >> n;

	g.resize(n, vector<pair<int, int>>());
	tin.resize(n);
	tout.resize(n);

	for (int i = 1; i < n; i++) {
		int v, c;
		cin >> v >> c;
		g[--v].push_back({ i, c });
	}
	
	dfs(0);

	int m;
	cin >> m;

	for (int i = 0; i < m; i++) {
		int x, y;
		cin >> x >> y;
		--x, --y;
		cout << min(lca(x, y), lca(y, x)) << '\n';
	}
}