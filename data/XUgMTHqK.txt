/*

Usergraph, graphical user interface for pixi.js.
Copyright (c) 2022 by Keith Weatherby II

Based on PIXI.JS 5.2.1
*/

import * as PIXI from "pixi.js";

export enum BtnState
{
    hover,
    normal,
    pressed,
}

// amt = percentage you want to darken in the range of 0-1 (eg: 50% darker should be .5)
export function darken( inColor : number, amt : number ) : number
{
    if( amt > 1 ) amt = 1;
    let r = PIXI.utils.hex2rgb( inColor )[ 0 ] * amt;
    let g = PIXI.utils.hex2rgb( inColor )[ 1 ] * amt;
    let b = PIXI.utils.hex2rgb( inColor )[ 2 ] * amt;

    return( PIXI.utils.rgb2hex( [ r, g, b ] ) );
}

export interface ButtonOptions
{
    x? : number;
    y? : number;
    w : number;
    h : number;
    color : number;
    label : string;
}

// TO DO:  The ability to add image/animation assets to buttons
export class Button extends PIXI.Container
{
    // these are animated sprites because in the future they'll allow animations
    //_aSprHover : PIXI.AnimatedSprite;  // sprite will highlight the button
    //_aSprNormal : PIXI.AnimatedSprite;  // Normal not pressed button state
    //_aSprPressed : PIXI.AnimatedSprite;  // When the button is touch/tapped/clicked

    // each will contain a seperate object for each state
    // hover, normal, and pressed.  can use same index
    _containers : PIXI.Container[] = [];
    _gBackgrounds : PIXI.Graphics[] = [];
    _gOverlays : PIXI.Graphics[] = [];
    _tLabels : PIXI.Text[] = [];

    _gMask : PIXI.Graphics;

    _gSelectionBox : PIXI.Graphics;
    _selectable : boolean;
    _selected : boolean;

    public set Selectable( isSelectable : boolean )
    {
        this._selectable = isSelectable
    }

    public Select( outlineColor : number = 0xFF0000 )
    {
        this._selected = true;
        this._gSelectionBox.clear();      
        this._gSelectionBox.beginFill( 0xff00ff, 0 );
        this._gSelectionBox.lineStyle( 1, outlineColor, 1, 0 );
        this._gSelectionBox.drawRect( 0, 0, this.W, this.H );
        this._gSelectionBox.endFill();
        this._gSelectionBox.visible = true;
    }

    public DeSelect()
    {
        this._selected = false;
        this._gSelectionBox.visible = false;
    }

    _w : number;
    public get W() : number
    {
        return this._w;
    }
    public set W( w : number )
    {
        this._w = w;
    }

    _h : number;
    public get H() : number
    {
        return this._h;
    }
    public set H( h : number )
    {
        this._h = h;
    }
 
    _color : number;
    public get Color() : number
    {
        return this._color;
    }
    public set Color( h : number )
    {
        this._color = h;
    }
    
    _renderer : PIXI.Renderer;

    _state : BtnState;
    public get State() : BtnState
    {
        return this._state;
    }
    public set State( state : BtnState )
    {
        this._state = state;
        if( this._containers )
        {
            if( this._containers.length == 3 )
            {
                switch( state )
                {
                    case BtnState.hover:
                        this._containers[ BtnState.hover ].visible = true;
                        this._containers[ BtnState.normal ].visible = false;
                        this._containers[ BtnState.pressed ].visible = false;                
                    break;

                    case BtnState.normal:
                        this._containers[ BtnState.hover ].visible = false;
                        this._containers[ BtnState.normal ].visible = true;
                        this._containers[ BtnState.pressed ].visible = false;                
                    break;

                    case BtnState.pressed:
                        this._containers[ BtnState.hover ].visible = false;
                        this._containers[ BtnState.normal ].visible = false;
                        this._containers[ BtnState.pressed ].visible = true;
                    break;
                }
            }
        }
    }

    _label : string;
    public get Label() : string
    {
        return this._label;
    }
    public set Label( label : string )
    {
        this._label = label;

        this.changeLabelText( label );
    }

    private changeLabelText( label: string )
    {
        if( Array.isArray( this._tLabels ) && this._tLabels.length > 0 )
        {
            for( var i = 0; i < 3; i++ )
            {
                // changing the text is easy but we must also recenter it
                this._tLabels[ i ].text = label;
                this._tLabels[ i ].x = ( this.W - this._tLabels[ i ].width ) / 2;
                // center y.
                this._tLabels[ i ].y = ( ( this.H - this._tLabels[ i ].height ) / 2 ) - ( this._tLabels[ i ].height / 8 );                   
            }
        }
    }

    // _id may be used more internally
    // but figured I would let them still
    // be publically accessible
    _id : number;
    public get ID() : number
    {
        return this._id;
    }

    // 100 button id's is kind of arbitrary in that I figure I might want to
    // designate different ranges for different types of ui elements, however
    // this isn't some hard and fast rule and could have virtually unlimited buttons.
    // So you could tell what kind of control it is just by dividing by 100;
    // a dialog that contains buttons might be in the range of 100-199 and other
    // kinds of controls like maybe scrollbar arrows set to 200-299, and so forth
    public set ID( id : number )
    {
        if( id >= 0 && id <= 99 ) this._id = id; 
        else
        {
            this._id = 99;
            console.error( "Button ID out of range (0-99).  Must be 0 - 99.\nAutomatically set to '99' but behavior undefined." );
        }
    }

    _pressed : boolean;
    public get Pressed() : boolean
    {
        //console.log( "pressed field value: " + this._pressed );

        return this._pressed;
    }
    
    // so since pressed is continuous, 
    // I decided to call clicked when you pressed
    // and then released the button.
    _clicked : boolean;
    public get Clicked() : boolean
    {
        // so we want to reset to false each
        // time this has been clicked, otherwise
        // it will show up continuously
        let hasBeenClicked = this._clicked;
        this._clicked = false;

        return hasBeenClicked;
    }
    _clickedCallback : Function;

    // this is like saying a dialog is open
    // but being a button it reads better if
    // I call it activation
    _isActivated : boolean;
    public get IsActivated() : boolean
    {
        return this._isActivated;
    }

    public activate()
    {
        this._isActivated = true;
        this.interactive = true;
        this.visible = true;
        this.State = BtnState.normal;
    }
    public deactivate()
    {
        this._isActivated = false;
        this.interactive = false;
        this.visible = false;
        this.State = BtnState.normal;
    }

    private Rebuild()
    {        
        // 0 = hover; 1 = normal; 2 = pressed;
        for( var i : number = 0; i < 3; i++ )
        {
            let tmpBackground = new PIXI.Graphics();
            tmpBackground.beginFill( this.Color );
            tmpBackground.drawRect( 0, 0, this.W, this.H );
            tmpBackground.endFill();
            this._gBackgrounds.push( tmpBackground );

            let tmpLabelText = new PIXI.Text( this.Label, { fill : 0xEEEECC, strokeThickness : 3, padding : 4 } ); 
            // let's center the text now.
            tmpLabelText.x = ( this.W - tmpLabelText.width ) / 2;
            // center y.
            tmpLabelText.y = ( ( this.H - tmpLabelText.height ) / 2 ) - ( tmpLabelText.height / 8 );
            this._tLabels.push( tmpLabelText );

            let tmpOverlay = new PIXI.Graphics(); 
            if( i == BtnState.hover )
            {
                tmpOverlay.blendMode = PIXI.BLEND_MODES.ADD;  // this will make it brighter
                tmpOverlay.beginFill( 0xffffff, 0.25 );       
            }
            else
            if( i == BtnState.normal )
            {            
                // this overlay should never show up, but doing it for completeness
                //tmpOverlay.visible = false;
                tmpOverlay.blendMode = PIXI.BLEND_MODES.NORMAL;
                tmpOverlay.beginFill( 0xff00ff, 0 );       
            }
            if( i == BtnState.pressed )
            {            
                tmpOverlay.blendMode = PIXI.BLEND_MODES.MULTIPLY;  // this will make it darker
                tmpOverlay.beginFill( 0x000000, 0.35 );       
            }        
            tmpOverlay.drawRect( 0, 0, this.W, this.H );
            tmpOverlay.endFill();

            // we're creating two outlines, white and black
            // so when we put it on a panel that has the same
            // color, it will be visible.
            tmpOverlay.blendMode = PIXI.BLEND_MODES.NORMAL;
            tmpOverlay.beginFill( 0xff00ff, 0 );       
            tmpOverlay.lineStyle( 1, 0xFFFFFF, 1, 0 );
            tmpOverlay.drawRect( 0, 0, this.W, this.H );
            tmpOverlay.lineStyle( 1, 0x000000, 1, 0 );
            tmpOverlay.drawRect( 1, 1, this.W - 2, this.H - 2 );
            tmpOverlay.endFill();
            
            this._gOverlays.push( tmpOverlay );

            let tmpContainer = new PIXI.Container();
            tmpContainer.addChild( tmpBackground );
            tmpContainer.addChild( tmpLabelText );
            tmpContainer.addChild( tmpOverlay );

            this._gMask = new PIXI.Graphics();
            this._gMask.beginFill( 0xffffff );
            this._gMask.drawRect( 0, 0, this.W, this.H );
            this._gMask.endFill();
            
            tmpContainer.addChild( this._gMask );
            tmpContainer.mask = this._gMask;
            this._gSelectionBox = new PIXI.Graphics();
            tmpContainer.addChild( this._gSelectionBox );
            this._containers.push( tmpContainer );
        }
    }
    /*
    export interface ButtonOptions
    {
        x? : number;
        y? : number;
        w : number;
        h : number;
        color : number;
        label : string;
    }
    */

    constructor( r : PIXI.Renderer, btnOpts : ButtonOptions, callback? : Function )
    {
        super();
        this._renderer = r;
        this.ID = 0;
 
        this.Label = btnOpts.label;
        this.W = btnOpts.w;
        this.H = btnOpts.h;
        this.Color = btnOpts.color;

        if( btnOpts.x ) 
            this.x = btnOpts.x;
        else
            this.x = 0;

        if( btnOpts.y ) 
            this.y = btnOpts.y;
        else
            this.y = 0;

        this.Rebuild();

        for( var i = 0; i < 3; i++ )
        {
            this.addChild( this._containers[ i ] );
        }

        this.interactive = true;

        this.State = BtnState.normal;
        this._pressed = false;

        // Don't forget to bind this in the constructor of the
        // calling class if you want to access any fields from it.
        // this.BtnCallback = this.BtnCallback.bind( this );
        this._clickedCallback = callback;

        this
        // Mouse & touch events are normalized into
        // the pointer* events for handling different
        // button events.
            .on('pointerdown', this.onPointerDown)
            .on('pointerup', this.onPointerUp)
            .on('pointerupoutside', this.onPointerOut)
            .on('pointerover', this.onPointerOver)
            .on('pointerout', this.onPointerOut)
            .on('pointertap', this.onPointerTap)
            .on('pointerleave', this.onPointerOut)
            ;

        this.activate();

        this.Selectable = false;
    }
  
    private onPointerDown() 
    {
        this.State = BtnState.pressed;
        this._pressed = true;
    }
    
    private onPointerUp() 
    {
        console.log( "*onPointerUp");
        this.State = BtnState.hover;
        this._pressed = false;
    }
    
    private onPointerOver() 
    {
        console.log( "onto button" );
        this.State = BtnState.hover;
        this._pressed = false;
    }
    
    private onPointerOut() 
    {
        console.log( "off of button" );
        this.State = BtnState.normal;
        this._pressed = false;
    }

    private onPointerTap() 
    {
        if( !this.Selectable )
        {
            this._clicked = true;
            if( this._clickedCallback )
                this._clickedCallback( this.ID );
        }
    }
}

export interface PanelOptions
{
    x? : number;
    y? : number;
    w : number;
    h : number;
    color : number;
    title? : string;
    backgroundVisible : boolean;
}

export class Panel extends PIXI.Container
{
    _buttons : Button[] = [];
    _floatingLabels : PIXI.Text[] = [];

    _textpages : PIXI.Text[] = [];
    _currentTextpage : number;

    _gBackground : PIXI.Graphics;
    _gMask : PIXI.Graphics;

    _w : number;
    public get W() : number
    {
        return this._w;
    }
    public set W( w : number )
    {
        this._w = w;
    }

    _h : number;
    public get H() : number
    {
        return this._h;
    }
    public set H( h : number )
    {
        this._h = h;
    }
 
    _color : number;
    public get Color() : number
    {
        return this._color;
    }
    public set Color( h : number )
    {
        this._color = h;
    }
    
    _renderer : PIXI.Renderer;

    _tTitle : PIXI.Text;
    _title : string;
    public get Title() : string
    {
        return this._title;
    }
    public set Title( title : string )
    {
        this._title = title;
        if( this._tTitle != null )
            this._tTitle.text = title;
    }

    // _id may be used more internally
    // but figured I would let them still
    // be publically accessible
    _id : number;
    public get ID() : number
    {
        return this._id;
    }

    public set ID( id : number )
    {
        if( id >= 100 && id <= 199 ) this._id = id; 
        else
        {
            this._id = 199;
            console.error( "ID out of range (100-199).  Must be 100 - 199.\nAutomatically set to '199' but behavior undefined." );
        }
    }    

    _isOpen : boolean;
    public get IsOpen() : boolean
    {
        return this._isOpen;
    }

    public open()
    {
        this._wasOpen = false;
        this._isOpen = true;
        this.interactive = true;
        this.visible = true;
        if( this._buttons )
        {
            this._buttons.forEach( button => { button.activate(); } );
        }
    }

    public close()
    {
        this._wasOpen = true;
        this._isOpen = false;
        this.interactive = false;
        this.visible = false;
        if( this._buttons )
        {
            this._buttons.forEach( button => { button.deactivate(); } );
        }
    }

    _panelButtonClickCallback : Function;

    // since callbacks are asynchronous, you could
    // be processing input as soon as your code allows
    // with this wasOpen property, if you check it as
    // well as isOpen for false, it will wait a loop
    // before being cleared again.  Which means if you do
    // something such as:
    // if( !IsOpen && !WasOpen ){ // process code here }
    // _wasOpen will be cleared by the next call
    // might integrate this into the IsOpen call
    _wasOpen : boolean;
    public get WasOpen() : boolean
    {
        if( this._wasOpen )
        {
            this._wasOpen = false;
            return true;
        }

        return false;
    }

    _titlebarHeight : number;
    public get TitlebarHeight() : number
    {
        return this._titlebarHeight;
    }
    public set TitlebarHeight( height : number )
    {
        this._titlebarHeight = height;
    }

    _displayTitle : boolean;

    /*
    export interface paneloptions
    {
        x? : number;
        y? : number;
        w : number;
        h : number;
        color : number;
        title? : string;
        backgroundVisible : boolean;
    }
    */
    constructor( r : PIXI.Renderer, panelopts : PanelOptions, callback? : Function )
    {
        super();
        this._renderer = r;
        this.ID = 100;
 
        this._displayTitle = false;
        if( panelopts.title ) 
        {
            this._displayTitle = true;
            this.Title = panelopts.title;
        }
        else
        {
            this.Title = "no title";
            this._displayTitle = false;
        }

        this.W = panelopts.w;
        this.H = panelopts.h;
        this.Color = panelopts.color;

        if( panelopts.x ) 
            this.x = panelopts.x;
        else
            this.x = 0;

        if( panelopts.y ) 
            this.y = panelopts.y;
        else
            this.y = 0;

        this.interactive = true;
       
        if( panelopts.backgroundVisible )
        {
            if( !this._displayTitle )
            {
                this._gBackground = new PIXI.Graphics();
                this._gBackground.beginFill( this.Color )
                this._gBackground.drawRect( 0, 0, this.W, this.H );
                this._gBackground.endFill();
                this.addChild( this._gBackground );
            }
            else
            if( this._displayTitle )
            {
                // create the text, but don't show it yet.
                this._tTitle = new PIXI.Text( this.Title, { fill : 0xFFFFEE, strokeThickness : 2, fontSize : "20px" } );
                this._tTitle.x = ( ( this.W - this._tTitle.width ) / 2 ) - 2;
                this._gBackground = new PIXI.Graphics();
                this.TitlebarHeight = this._tTitle.height + ( this._tTitle.height / 4 );
                // subtracting 2 to account for the stroke thickness
                this._tTitle.y = ( ( this.TitlebarHeight - this._tTitle.height ) / 2 ) - 2;
                if( this._tTitle )
                {
                    this._gBackground.beginFill( darken( this.Color, .75 ) )
                    this._gBackground.drawRect( 0, 0, this.W, this.TitlebarHeight );
                    this._gBackground.endFill();    
                }
                this._gBackground.beginFill( this.Color )
                this._gBackground.drawRect( 0, this.TitlebarHeight, this.W, this.H - this.TitlebarHeight );
                this._gBackground.endFill();
                this.addChild( this._gBackground );
                this.addChild( this._tTitle );
            }
            this._gBackground.blendMode = PIXI.BLEND_MODES.NORMAL;
            this._gBackground.beginFill( 0xff00ff, 0 );       
            this._gBackground.lineStyle( 1, 0xFFFFFF, 1, 0 );
            this._gBackground.drawRect( 0, 0, this.W, this.H );
            this._gBackground.lineStyle( 1, 0x000000, 1, 0 );
            this._gBackground.drawRect( 1, 1, this.W - 2, this.H - 2 );
            this._gBackground.endFill();

        }

        this._gMask = new PIXI.Graphics();
        this._gMask.beginFill( this.Color )
        this._gMask.drawRect( 0, 0, this.W, this.H );
        this._gMask.endFill();
        this.addChild( this._gMask );
        this.mask = this._gMask;

        this._panelButtonClickCallback = callback;
        
        // We only need to capture this for the time being
        //this.on('pointertap', this.onPointerTap);

        this.hitArea = new PIXI.Rectangle(0, 0, this.W, this.H );

        this._currentTextpage = 0;

        this.close();
        this._isOpen = false;
        this._wasOpen =false;

        this
            .on('pointerout', this.onPointerOut)
            .on('pointertap', this.onPointerTap)
            .on('pointerover', this.onPointerOver)
            ;
   
    }

    private onPointerOver() 
    {
        console.log("onto panel");
        for( let i = 0; i < this._buttons.length; i++ )
        {
            if( this._buttons[ i ].Label == "stats" )
                console.log( "Button: " + this._buttons[ i ].Label + " = " + BtnState[ this._buttons[ i ].State ] );
        //    this._buttons[ i ].interactive = true;
        }
        
    }

    // we needed the panel class to handle this in case
    // the mouse leaves the panel area.
    private onPointerOut() 
    {
        console.log("off of panel");
        
        for( let i = 0; i < this._buttons.length; i++ )
        {
            //this._buttons[ i ].interactive = false;
            //this._buttons[ i ].State = BtnState.normal;
            //this._buttons[ i ]._pressed = false;
            if( this._buttons[ i ].Label == "stats" )
                console.log( "Button: " + this._buttons[ i ].Label + " = " + BtnState[ this._buttons[ i ].State ] );
        }
        
    }

    private onPointerTap() 
    {
        let id = this.getClicked();

        if( this._panelButtonClickCallback )
        {
            // the original callback call
            //this._panelButtonClickCallback( id );
            
            // vv these didn't seem to help vv
            //requestAnimationFrame(() => this._buttonClickCallback( id ));
            setImmediate( this._panelButtonClickCallback( id ) );
            //process.nextTick( this._buttonClickCallback, id );
            
            // this seems to be the only thing that delays closing so no extra input is received
            //setTimeout( this._buttonClickCallback, 50, id );
        }

    }

    /*
    export interface ButtonOptions
    {
        x? : number;
        y? : number;
        w : number;
        h : number;
        color : number;
        label : string;
    }
    */

    public addButton( r : PIXI.Renderer, btnOpts : ButtonOptions ) : number
    {
        let x = 0;
        let y = 0;
        let buttonID = -1;

        // x and y relative to the panels coordinates
        if( btnOpts.x )
            x = btnOpts.x;
        if( btnOpts.y )
            y = btnOpts.y;

        let newButton = new Button( r, btnOpts );
        this._buttons.push( newButton );
        if( this._buttons.length > 0 )
        {
            newButton.x = x;
            newButton.y = y;
            // relying on the length to set the id of the buttons
            buttonID = newButton.ID = this._buttons.length - 1;
        }

        // commented this out because we want to add
        // them in a specific order, buttons will be added
        // last, panel text will be added before
        //this.addChild( newButton );

        // if it returns a -1 then something went wrong
        return( buttonID );
    }

    /*
    export interface ButtonOptions
    {
        x? : number;
        y? : number;
        w : number;
        h : number;
        color : number;
        label : string;
    }
    */

    public addFloatingLabel( r : PIXI.Renderer, labelOpts : ButtonOptions )
    {
        let x = 0;
        let y = 0;

        if( labelOpts.x )
            x = labelOpts.x;
        if( labelOpts.y )
            y = labelOpts.y;

        let newLabel = new PIXI.Text( labelOpts.label, { fill : labelOpts.color } );
        this._floatingLabels.push( newLabel );
        if( this._floatingLabels.length > 0 )
        {
            newLabel.x = x;
            newLabel.y = y;
        }
    }

    public getClicked() : number
    {
        // run through each button
        for( var i = 0; i < this._buttons.length; i++ )
        {
            // if it's been clicked then return the button id
            if( this._buttons[ i ].Clicked )
            {
                return this._buttons[ i ].ID;
            }
        }

        // nothing clicked so -1
        return -1;
    }

    public addTextpage( text : string, textstyle : any )
    {
        textstyle.wordWrap = true;
        textstyle.wordWrapWidth = this.W - 8;

        let tempText = new PIXI.Text( text, textstyle );

        tempText.x = 4;
        tempText.y = 4;

        if( this._displayTitle )
        {
            tempText.y = this._titlebarHeight + ( this._titlebarHeight / 8 );
        }
        
        this._textpages.push( tempText );
    }

    public get NumTextpages() : number
    {
        return this._textpages.length;
    }

    // we don't want all of them to show up at once
    // although presumably they're all on the stage
    private updateVisiblePage()
    {
        for( var i = 0; i < this.NumTextpages; i++ )
        {
            this._textpages[ i ].visible = false;
        }

        // make sure the new current page is visible
        this._textpages[ this._currentTextpage ].visible = true;
    }

    public incrementTextpage()
    {
        // are there any pages?
        if( this.NumTextpages > 0 )
        {
            // since an array is 0 based, then, checking against numpages - 1.
            // so if there's only one page, then it won't execute since 1-1 = 0;
            // if there's two pages, you can go from 0 to 1, and so on.
            if( this._currentTextpage < this.NumTextpages - 1 )
            {
                this._currentTextpage++;
                this.updateVisiblePage();
            }
        }
    }

    public decrementTextpage()
    {
        // are there any pages?
        if( this.NumTextpages > 0 )
        {
            if( this._currentTextpage > 0 )
            {
                this._currentTextpage--;
                this.updateVisiblePage();
            }
        }
    }

    public ModifyTextPage( pageNumber : number, newText : string ) : number
    {
        let status = 0;

        let numPages = this._textpages.length;
        if( numPages > 0 && pageNumber < numPages )
            this._textpages[ pageNumber ].text = newText;
        else
            status = 1;

        return status;
    }

    public addAllChildren()
    {
        if( this._textpages.length > 0 )
        {
            for( var i = 0; i < this._textpages.length; i++ )
            {
                // if it's been clicked then return the button id
                this.addChild( this._textpages[ i ] );
                this._textpages[ i ].visible = false;
            } 

            this._textpages[ this._currentTextpage ].visible = true;
        }

        if( this._floatingLabels.length > 0 )
        {
            for( var i = 0; i < this._floatingLabels.length; i++ )
            {
                this.addChild( this._floatingLabels[ i ] );
            }
        }
        
        if( this._buttons.length > 0 )
        {
            for( var i = 0; i < this._buttons.length; i++ )
            {
                // if it's been clicked then return the button id
                this.addChild( this._buttons[ i ] );
            }    
        }
    }
 }
