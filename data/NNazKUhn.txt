//
// Created by Dan Kulakovich on 25.10.22.
//

#include <iostream>
#include "ExceptionEmpty.h"

template <typename T> class Queue;
template <typename T> std::ostream& operator << (std::ostream&, Queue<T>);

template <typename T>
class Queue {

    struct Node {
        Node *next;
        T value;
        explicit Node(T value = T(), Node *next = nullptr){
            this -> value = value;
            this -> next = next;
        }
    };
    Node *node;
    int size;

public:

    explicit Queue();
    Queue(const Queue&);
    ~Queue();

    void push(T value);
    T pop();
    T& front();
    T& back();
    int length();
    bool isEmpty();

    friend std::ostream& operator << <> (std::ostream& out, Queue<T> queue) {
        out << "[";
        if (queue.size > 0) {
            Node* tmp = queue.node -> next;
            for (int i = 0; i < queue.length() - 1; i++) {
                out << tmp -> value << ", ";
                tmp = tmp -> next;
            }
            out << tmp -> value << "]";
        } else {
            out << "]";
        }
        return out;
    }
};

template <typename T>
Queue<T>::Queue(){
    node = new Node;
    this -> size = 0;
}

template <typename T>
Queue<T>::Queue(const Queue& queue) {
    this -> node = new Node(queue.node -> value);
    Node *temp = queue.node, *head = this -> node;
    for (int i = 0; i < queue.size; ++i) {
        head -> next = new Node(temp -> value);
        head = head -> next;
        temp = temp -> next;
    }
    this -> size = queue.size;
}

template <typename T>
Queue<T>::~Queue() {
    while (!isEmpty()) {
        Node* temp = this -> node;
        this -> node = this -> node -> next;
        delete temp;
        this -> size--;
    }
}

template <typename T>
void Queue<T>::push(T value) {
    if (this -> size == 0) {
        this -> node = new Node(value);
        this -> size++;
        return;
    }
    Node* tmp = this -> node;
    while (tmp -> next != nullptr) tmp = tmp -> next;
    tmp -> next = new Node(value);
    this -> size++;
}

template <typename T>
T Queue<T>::pop() {
    try {
        if (isEmpty())
            throw ExceptionEmpty();
        T ret = this->node->value;
        this->node = this->node->next;
        this->size--;
        return ret;
    }
    catch (ExceptionEmpty& e) {
        e.getError();
    }
}

template <typename T>
T& Queue<T>::front() {
    return node -> value;
}

template <typename T>
T& Queue<T>::back() {
    Node* back = this -> node;
    while (back -> next != nullptr) {
        back = back -> next;
    }
    return back -> value;
}

template <typename T>
int Queue<T>::length() {
    return this->size;
}

template <typename T>
bool Queue<T>::isEmpty() {
    return size == 0;
}
