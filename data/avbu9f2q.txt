
#include "cuda.h"
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include <device_functions.h>

#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <chrono>
#include <iostream>

using namespace std::chrono;

#define BLOCK_SIZE 16

__global__ void gpu_matrix_mult(float* a, float* b, float* c, int m, int n, int k)
{
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    float sum = 0;
    if (col < k && row < m)
    {
        for (int i = 0; i < n; i++)
        {
            sum += a[row * n + i] * b[i * k + col ];
        }
        c[row * k + col] = sum;
    }
}

__global__ void gpu_matrix_mult_opt(float* d_a, float* d_b, float* d_result, int m, int n, int k)
{
    __shared__ float tile_a[BLOCK_SIZE][BLOCK_SIZE];
    __shared__ float tile_b[BLOCK_SIZE][BLOCK_SIZE];

    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;
    float tmp = 0;
    int idx;

    for (int sub = 0; sub < n; sub += BLOCK_SIZE)
    {
        idx = row * n + sub + threadIdx.x;
        tile_a[threadIdx.y][threadIdx.x] = d_a[idx];

        idx = (sub + threadIdx.y) * k + col;
        tile_b[threadIdx.y][threadIdx.x] = d_b[idx];
        __syncthreads();

        for (int k = 0; k < BLOCK_SIZE; ++k)
        {
            tmp += tile_a[threadIdx.y][k] * tile_b[k][threadIdx.x];
        }
        __syncthreads();
    }
    d_result[row * k + col] = tmp;
}

void seq_matrix_mult(float* h_a, float* h_b, float* h_result, int m, int n, int k) {
    for (int i = 0; i < m; ++i)
    {
        for (int j = 0; j < k; ++j)
        {
            float tmp = 0.0;
            for (int h = 0; h < n; ++h)
            {
                tmp += h_a[i * n + h] * h_b[h * k + j];
            }
            h_result[i * k + j] = tmp;
        }
    }
}

void omp_matrix_mult(float* h_a, float* h_b, float* h_result, int m, int n, int k) {
#pragma omp parallel for
    for (int i = 0; i < m; ++i)
    {
        for (int j = 0; j < k; ++j)
        {
            float tmp = 0.0;
            for (int h = 0; h < n; ++h)
            {
                tmp += h_a[i * n + h] * h_b[h * k + j];
            }
            h_result[i * k + j] = tmp;
        }
    }
}

bool checkResults(float* first, float* second, int m, int k) {
    bool check = true;
    float eps = 5e-1;
    for (int i = 0; i < m; ++i)
    {
        for (int j = 0; j < k; ++j)
        {
            if (fabs(first[i * k + j] - second[i * k + j]) > eps) {
                std::cout << first[i * k + j] << " " << second[i * k + j] << std::endl;
                check = false;
            }
        }
    }
    return check;
}

int main(int argc, char const* argv[])
{
    int m = 1600;
    int n = 1440;
    int k = 1440;

    float* h_a, * h_b, * h_seq, * h_omp, *h_gpu, *h_gpu_opt;
    cudaMallocHost((void**)&h_a, sizeof(float) * m * n);
    cudaMallocHost((void**)&h_b, sizeof(float) * n * k);
    cudaMallocHost((void**)&h_seq, sizeof(float) * m * k);
    cudaMallocHost((void**)&h_omp, sizeof(float) * m * k);
    cudaMallocHost((void**)&h_gpu, sizeof(float) * m * k);
    cudaMallocHost((void**)&h_gpu_opt, sizeof(float) * m * k);

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            h_a[i * n + j] = (float)rand()/1024;
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < k; ++j) {
            h_b[i * k + j] = (float)rand()/1024;
        }
    }

    auto start = high_resolution_clock::now();
    seq_matrix_mult(h_a, h_b, h_seq, m, n, k);
    auto stop = high_resolution_clock::now();
    std::cout << "SEQ CPU: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

    omp_set_num_threads(omp_get_num_procs());
    start = high_resolution_clock::now();
    omp_matrix_mult(h_a, h_b, h_omp, m, n, k);
    stop = high_resolution_clock::now();
    std::cout << "OMP CPU: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;

    float* d_a, * d_b, * d_c;
    float* d_a_opt, * d_b_opt, * d_c_opt;
    cudaMalloc((void**)&d_a, sizeof(float) * m * n);
    cudaMalloc((void**)&d_b, sizeof(float) * n * k);
    cudaMalloc((void**)&d_c, sizeof(float) * m * k);
    cudaMalloc((void**)&d_a_opt, sizeof(float) * m * n);
    cudaMalloc((void**)&d_b_opt, sizeof(float) * n * k);
    cudaMalloc((void**)&d_c_opt, sizeof(float) * m * k);

    // copy matrix A and B from host to device memory
    cudaMemcpy(d_a, h_a, sizeof(float) * m * n, cudaMemcpyHostToDevice);
    cudaMemcpy(d_b, h_b, sizeof(float) * n * k, cudaMemcpyHostToDevice);
    cudaMemcpy(d_a_opt, h_a, sizeof(float) * m * n, cudaMemcpyHostToDevice);
    cudaMemcpy(d_b_opt, h_b, sizeof(float) * n * k, cudaMemcpyHostToDevice);

    unsigned int grid_rows = (m + BLOCK_SIZE - 1) / BLOCK_SIZE;
    unsigned int grid_cols = (k + BLOCK_SIZE - 1) / BLOCK_SIZE;
    dim3 dimGrid(grid_cols, grid_rows);
    dim3 dimBlock(BLOCK_SIZE, BLOCK_SIZE);

    start = high_resolution_clock::now();
    gpu_matrix_mult <<<dimGrid, dimBlock >> > (d_a, d_b, d_c, m, n, k);
    cudaDeviceSynchronize();
    stop = high_resolution_clock::now();
    std::cout << "(non-optimized) GPU: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl;
    cudaMemcpy(h_gpu, d_c, sizeof(float) * m * k, cudaMemcpyDeviceToHost);
    cudaThreadSynchronize();

    start = high_resolution_clock::now();
    gpu_matrix_mult_opt <<<dimGrid, dimBlock >>>(d_a_opt, d_b_opt, d_c_opt, m, n, k);
    cudaDeviceSynchronize();
    stop = high_resolution_clock::now();
    std::cout << "(    optimized) GPU: " << duration_cast<milliseconds>(stop - start).count() << " ms " << std::endl; 
    cudaMemcpy(h_gpu_opt, d_c_opt, sizeof(float) * m * k, cudaMemcpyDeviceToHost);
    cudaThreadSynchronize();
    
    std::cout << std::endl;
    if (checkResults(h_seq, h_omp, m, k))
    {
        std::cout << "Results (Sequental & OMP) are equal." << std::endl;
    }

    if (checkResults(h_omp, h_gpu, m, k))
    {
        std::cout << "Results (OMP & GPU) are equal." << std::endl;
    }
    if (checkResults(h_gpu, h_gpu_opt, m, k))
    {
        std::cout << "Results (GPU & GPU) are equal." << std::endl;
    }
    return 0;
}