/// Build a passage, then flow sand through it
/// 1) until it is "filled" - any more flows out
/// 2) until the pile reaches the source

import 'dart:math';
import 'package:collection/collection.dart';
import 'package:more/more.dart';

var grid = <Point<int>>{};
void drawLine(List<String> ps) {
  var l1 = ps.first.split(',').map(int.parse);
  var p1 = Point<int>(l1.first, l1.last);
  var l2 = ps.last.split(',').map(int.parse);
  var p2 = Point<int>(l2.first, l2.last);
  var d = p2 - p1;
  d = Point(d.x.sign, d.y.sign);
  for (var i = p1; i != p2; i += d) {
    grid.add(i);
  }
  grid.add(p2);
}

var drops = [Point(0, 1), Point(-1, 1), Point(1, 1)];
late int maxX, minX, maxY, minY;
addLines(List<String> lines) {
  grid = <Point<int>>{};
  lines
      .map((e) => e.split(' -> ').window(2))
      .flattened
      .forEach((e) => drawLine(e));
  maxX = grid.map((e) => e.x).max;
  minX = grid.map((e) => e.x).min;
  maxY = grid.map((e) => e.y).max;
  minY = grid.map((e) => e.y).min;
}

var sourcePoint = Point(500, 0);

part1(List<String> lines) {
  addLines(lines);
  var s = sourcePoint;
  var grains = 0;
  nextdrop:
  while (true) {
    var sn = s;
    var canMove = false;
    for (var d in drops) {
      sn = s + d;
      if (sn.x < minX || sn.x > maxX || sn.y > maxY) break nextdrop;
      if (!grid.contains(sn)) {
        canMove = true;
        break;
      }
    }
    if (canMove) {
      s = sn;
    } else {
      grid.add(s);
      s = sourcePoint;
      grains += 1;
    }
  }
  return grains;
}

var shade = [Point(-1, 0), Point(0, 0), Point(1, 0)];

// Find the 'shadow' cast by all the lines above, and remove this
// from the natural triangular pile.
part2(List<String> lines) {
  addLines(lines);
  maxY += 2;
  var ps = [
    for (var y in 1.to(maxY))
      for (var x in (500 - maxY).to(500 + maxY + 1)) Point(x, y)
  ];
  ps
      .where((p) => shade.every((e) => grid.contains(e + p)))
      .forEach((e) => grid.add(e + Point(0, 1)));
  var grains = 0;
  for (var y in 0.to(maxY)) {
    var line = 2 * y + 1;
    for (var x in (500 - y).to(500 + y + 1)) {
      if (grid.contains(Point(x, y))) line -= 1;
    }
    grains += line;
  }
  return grains;
}
