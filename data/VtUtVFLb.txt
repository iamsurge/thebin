#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;

const ll INF = (ll) 1e18 + 7;

ld EPS = 1e-6;

struct Point {
	ld x, y;
};

struct Line {
	ld a, b, c;
};

ld dist(Point a, Point b) {
	return sqrtl(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}

ld h(ld x1, ld y1, ld x2, ld y2, ld x3, ld y3, ld a) {
	ld s = abs((x2 - x1) * (y1 + y2) + (x3 - x2) * (y3 + y2) + (x1 - x3) * (y1 + y3)) / 2;
	return 2.0 * s / a;
}

Line ur_pr(Point A, Point B) {
	ld a, b, c;
	a = B.y - A.y;
	b = A.x - B.x;
	c = (-1) * (a * A.x + b * A.y);
	return { a, b, c };
}

Point get_pr(Line u, Line v) {
	ld a1, a2, b1, b2, c1, c2;
	a1 = u.a;
	b1 = u.b;
	c1 = u.c;
	a2 = v.a;
	b2 = v.b;
	c2 = v.c;
	ld helper = a1 * b2 - a2 * b1;
	ld x, y;
	x = (b1 * c2 - b2 * c1) / helper;
	y = (a2 * c1 - a1 * c2) / helper;
	return { x, y };
}

vector<Point> get_cyrcle(Line u, Point O, ld R) {
	ld a = u.a;
	ld b = u.b;
	ld c = u.c;
	ld x = O.x;
	ld y = O.y;
	vector<Point> res;
	if (fabs(a) <= EPS) {
		ld A = 1, Y = -c / b;
		ld B = (-2) * x;
		ld C = x * x - R * R + pow(Y - y, 2);
		ld D = B * B + ((-4) * A * C);
		if (D < 0) {
			return res;
		} else if (D <= EPS) {
			Point ans;
			ans.x = (-B) / (2 * A);
			ans.y = Y;
			res.push_back(ans);
		} else {
			Point f, s;
			f.x = ((-B) + sqrt(D)) / (2 * A);
			s.x = ((-B) - sqrt(D)) / (2 * A);
			f.y = Y;
			s.y = Y;
			res.push_back(f);
			res.push_back(s);
		}
	} else {
		ld A = ((b * b) / (a * a) + 1.0);
		ld B = ((2 * b * c) / (a * a) + ((2 * b * x) / a) - 2 * y);
		ld C = (c * c) / (a * a) + (2 * c * x) / a + x * x + y * y - R * R;
		ld D = B * B + ((-4) * A * C);
		if (D < 0) {
			return res;
		} else if (D <= EPS) {
			Point ans;
			ans.y = (-B) / (2 * A);
			ans.x = ((-b) * ans.y - c) / a;
			res.push_back(ans);
		} else {
			Point f, s;
			f.y = ((-B) + sqrt(D)) / (2 * A);
			s.y = ((-B) - sqrt(D)) / (2 * A);
			f.x = ((-b) * f.y - c) / a;
			s.x = ((-b) * s.y - c) / a;
			res.push_back(f);
			res.push_back(s);
		}
	}
	return res;
}

signed main() {
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	ios_base::sync_with_stdio(0);
	cin.tie(NULL);
	cout.tie(NULL);
	cout << fixed << setprecision(9);
	ll t;
	cin >> t;
	while (t--) {
		Point C1, C2, S;
		ld R1, R2;
		cin >> C1.x >> C1.y >> R1 >> C2.x >> C2.y >> R2;
		if (C1.x == C2.x && C1.y == C2.y && R1 == R2) {
			cout << 3 << endl;
		} else {
			pair<ld, ld> rzn;
			rzn.first = C1.x;
			rzn.second = C1.y;
			C2.x -= C1.x;
			C2.y -= C1.y;
			Line sup;
			sup.a = -2 * C2.x;
			sup.b = -2 * C2.y;
			sup.c = C2.x * C2.x + C2.y * C2.y + R1 * R1 - R2 * R2;
			ld d = R1 * R1 - sup.c * sup.c / (sup.a * sup.a + sup.b * sup.b);
			ld mult = sqrt(d / (sup.a * sup.a + sup.b * sup.b));
			S.x = -sup.a * sup.c / (sup.a * sup.a + sup.b * sup.b);
			S.y = -sup.b * sup.c / (sup.a * sup.a + sup.b * sup.b);
			if (sup.c * sup.c > R1 * R1 * (sup.a * sup.a + sup.b * sup.b) + EPS) {
				cout << 0 << endl;
			} else if (fabs(sup.c * sup.c - R1 * R1 * (sup.a * sup.a + sup.b * sup.b)) <= EPS) {
				cout << 1 << endl;
				cout << S.x + rzn.first << " " << S.y + rzn.second << endl;
			} else {
				cout << 2 << endl;
				Point f, s;
				f.x = S.x + sup.b * mult + rzn.first;
				s.x = S.x - sup.b * mult + rzn.first;
				f.y = S.y - sup.a * mult + rzn.second;
				s.y = S.y + sup.a * mult + rzn.second;
				if (s.y > f.y) {
					swap(s, f);
				}
				Point h;
				h.x = min(f.x, s.x) + fabs(f.x - s.x) / 2.0;
				h.y = min(f.y, s.y) + fabs(f.y - s.y) / 2.0;
				cout << h.x << " " << h.y << endl << dist(C1, h) << " " << dist(h, f) << endl;
				cout << f.x << " " << f.y << endl << s.x << " " << s.y << endl;
			}
		}
	}
}