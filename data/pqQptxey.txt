// clang-format off
#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
#define sqrt sqrtl
#define F first
#define S second
#define endl '\n'
#define all(vc666) vc666.begin(), vc666.end()
#define allr(vc666) vc666.rbegin(), vc666.rend()
#define int long long
#define degug(x) cerr (#x) << " " << (x) << endl;

const ll INF = (ll)1e18 + 7;
const ll inf = 1e10 + 7;
const ll ONE = 1;
const ll MOD = 1e9 + 7;
const ll max_sz = 1e5 + 1;
ld EPS = 1e-6;
ld PI = 3.1415926535897932384;
mt19937_64 gen(rand() % 100);

struct Node {
    int mx = -1, cnt = 0;
};

struct SegTree {
    vector <Node> t;
    SegTree(int n) {
        t.resize(4 * n);
    }
    void unite(const Node& l, const Node& r, Node& m) {
        if (l.mx == r.mx) {
            m = l;
            m.cnt += r.cnt;
        }
        else if (l.mx > r.mx) {
            m = l;
        }
        else {
            m = r;
        }
        m.cnt %= MOD;
    }
    void build(int v, int L, int R) {
        if (L == R) {
            t[v].mx = -1;
            t[v].cnt = 0;
        }
        else {
            int M = (L + R) / 2;
            build(2 * v, L, M);
            build(2 * v + 1, M + 1, R);
        }
    }
    void update(int v, int L, int R, int l, int r, int mx, int cnt) {
        if (L > r || R < l) {
            return;
        }
        else if (L >= l && R <= r) {
            t[v] = { mx, cnt };
        }
        else {
            int M = (L + R) / 2;
            update(2 * v, L, M, l, r, mx, cnt);
            update(2 * v + 1, M + 1, R, l, r, mx, cnt);
            unite(t[v * 2], t[v * 2 + 1], t[v]);
        }
    }
    Node query(int v, int L, int R, int l, int r) {
        if (L > r || R < l) {
            return { -1, 0 };
        }
        else if (L >= l && R <= r) {
            return t[v];
        }
        else {
            int M = (L + R) / 2;
            Node LL = query(2 * v, L, M, l, r);
            Node RR = query(2 * v + 1, M + 1, R, l, r);
            Node res;
            unite(LL, RR, res);
            return res;
        }
    }
};

signed main() {
#ifdef _DEBUG 
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) {
        int n, N, i, j;
        cin >> n;
        vector <int> a(n), b(n);
        for (i = 0; i < n; i++) {
            cin >> a[i];
            b[i] = a[i];
        }
        sort(all(b));
        b.resize(unique(all(b)) - b.begin());
        map <int, int> keys;
        for (i = 0; i < b.size(); i++) {
            keys[b[i]] = i + 1;
        }
        N = b.size() + 1;
        Node res, it;
        SegTree tree(N);
        tree.build(1, 0, N - 1);
        tree.update(1, 0, N - 1, 0, 0, 0, 1);
        for (i = 0; i < n; i++) {
            j = keys[a[i]];
            res = tree.query(1, 0, N - 1, 0, j - 1);
            it = tree.query(1, 0, N - 1, j, j);
            tree.update(1, 0, N - 1, j, j, res.mx + 1, (res.cnt + it.cnt) % MOD);
        }
        vector <pair <int, int> > c(N);
        int mx = 0, ans = 0;
        for (i = 1; i < N; i++) {
            res = tree.query(1, 0, N - 1, i, i);
            c[i] = { res.mx, res.cnt };
            if (c[i].first == mx) {
                ans += c[i].second;
                ans %= MOD;
            }
            else {
                if (c[i].first > mx) {
                    mx = c[i].first;
                    ans = c[i].second;
                }
            }
            //cout << c[i].first << " " << c[i].second << endl;
        }
        ans %= MOD;
        cout << ans << endl;
    }
}
//Deisgned by skimonoint fst = 0;