//  main.cpp

                             //                               Паттерн Шаблонный метод
							 //                              - - - - - - - - - - - - -
#include  <iostream>
using namespace std; 

#include     "ptm.h"

							 //        Назначение: Определяет общую схему алгоритма, перекладывая реализацию
							 //           некоторых шагов на подклассы. Шаблонный метод позволяет подклассам
							 //    переопределять отдельные шаги алгоритма без изменения структуры алгоритма.
							 //    
							 //   Абстрактный Класс определяет шаблонный метод, содержащий скелет некоторого
							 //   алгоритма, состоящего из вызовов (обычно) абстрактных примитивных операций.
							 //
							 //        Конкретные подклассы должны реализовать эти операции, но оставить сам
							 //                                                шаблонный метод без изменений.
                             //    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


							 // Клиентский код вызывает шаблонный метод для выполнения алгоритма. Клиентский
							 //        код не должен знать конкретный класс объекта, с которым работает, при
							 //      условии, что он работает с объектами через интерфейс их базового класса.

//////////////////////////////////////////////////////// 
void ClientCode( AbstractClass *class_ )              //   
{
  // ...
  class_ -> TemplateMethod();
  // ...
}


////////////////////////////////////////////////////////
int main()                                            //
{
    
	ConcreteClass1 *concreteClass1 = new ConcreteClass1;
    ClientCode(concreteClass1);
 
    ConcreteClass2 *concreteClass2 = new ConcreteClass2;
    ClientCode(concreteClass2);

    delete concreteClass1;
    delete concreteClass2;

	system("pause");
 
return 0;
}

//  ptm.h



///////////////////////////////////////////////                  Шаблонный метод определяет скелет алгоритма.
class AbstractClass                                        
{
    public:

    void TemplateMethod() const 
	{
		this->BaseOperation();
		this->RequiredOperations();
		this->Hook_1();
		this->Hook_2();
    }
                                                                       //  Эти операции уже имеют реализации.
    protected:
    void BaseOperation() const 
    {
        cout << "AbstractClass   says: I am doing the bulk of the work\n";
    }

	                                                //   А эти операции должны быть реализованы в подклассах.
    virtual void RequiredOperations() const = 0;
 
									//  Это «хуки». Подклассы могут переопределять их, но это не обязательно,
									//  поскольку у хуков уже есть стандартная (но пустая) реализация.  Хуки
									//  предоставляют дополнительные точки расширения в некоторых критических
									//  местах алгоритма.
    virtual void Hook_1() const {}
    virtual void Hook_2() const {}
};




									//         Конкретные классы должны реализовать все абстрактные операции
									//  базового класса. Они также могут переопределить некоторые операции с
									//                                              реализацией по умолчанию.
//////////////////////////////////////////////////  
class ConcreteClass1 : public AbstractClass 
{

    protected:
    void RequiredOperations() const override 
	{
		cout << "ConcreteClass 1 says: optional newline. \n\n";
    }
};



 // Обычно конкретные классы переопределяют только часть операций базового
 // класса.
////////////////////////////////////////////////////////// 
class ConcreteClass2 : public AbstractClass 
{
    protected:
    void RequiredOperations() const override 
	{
        cout << "ConcreteClass 2 says...\n";
    }


    void Hook_1() const override 
	{
       cout << "ConcreteClass 2 says: Overridden Hook_1 \n\n";
    }
};

