#include <iostream>
#include <vector>
#include <queue>
using namespace std;
vector<pair<int, int > > graph[205];

struct node {
    int idx;
    int dist;
    int k_left;
    int len;
    node() {}
    node(int _idx, int _dist, int _k_left, int _len) {
        idx = _idx;
        dist = _dist;
        k_left = _k_left;
        len = _len;
    }
    bool operator < (const node &tmp) const {
        return dist > tmp.dist;
    }
};
int d[111][11][555];
int main()
{
    int n, x;
    cin >> n >> x;
    int K, L;
    cin >> K >> L;
    int m;
    cin >> m;
    
    for(int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        a--; b--;
        graph[a].push_back({b, c});
        graph[b].push_back({a, c});
    }
    for(int i = 0; i <= n; i++) {
        for(int j = 0; j <= K; j++) {
            for(int x = 0; x <= L; x++) {
                d[i][j][x] = 1e9;
            }
        }
    }
    d[0][0][0] = 0;
    priority_queue<node> pq;
    pq.push(node(0, 0, K, L));
    
    while(!pq.empty()) {
        node c = pq.top();
        pq.pop();
        int new_l = c.len;
        if(c.idx <= x and c.len > 0) {
            new_l = 0;
        }
        if(new_l > 0) {
            for(int i = 0; i < (int) graph[c.idx].size(); i++) {
                int neighbour = graph[c.idx][i].first;
                int weight = graph[c.idx][i].second;
                if(new_l - weight >= 0 and c.dist < d[neighbour][c.k_left][new_l - weight]) {
                    d[neighbour][c.k_left][new_l - weight] = c.dist;
                    pq.push(node(neighbour, c.dist, c.k_left, new_l - weight));
                }
            }
            new_l = 0;
        }
        for(int i = 0; i < (int) graph[c.idx].size(); i++){
            int neighbour = graph[c.idx][i].first;
            int weight = graph[c.idx][i].second;
            if(c.dist + weight < d[neighbour][c.k_left][new_l]) {
                d[neighbour][c.k_left][new_l] = c.dist + weight;
                pq.push(node(neighbour, c.dist + weight, c.k_left, new_l));
            }
        }
        if(c.k_left > 0) {
            int new_k = c.k_left - 1;
            new_l = L;
            for(int i = 0; i < (int) graph[c.idx].size(); i++) {
                int neighbour = graph[c.idx][i].first;
                int weight = graph[c.idx][i].second;
                if(new_l - weight >= 0 and c.dist < d[neighbour][new_k][new_l - weight]) {
                    d[neighbour][new_k][new_l - weight] = c.dist;
                    pq.push(node(neighbour, c.dist, new_k, new_l - weight));
                }
            }
        }
        
    }
    int result = 1e9;
    for(int i = 0; i <= K; i++) {
        for(int j = 0; j <= L; j++) {
            result = min(result, d[n - 1][i][j]);
        }
    }
    cout << result << endl;
    return 0;
}
// 3 8 2 1 5m;

// kuli: 3 8
