#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <stack>
#include <iomanip>
#include <fstream>
#include <string>
#include <set>
#include <deque>
#include <queue>
#include <map>
#include <bitset>
#include <random>
#include <list>
#include <unordered_map>
#include <unordered_set>
#include <cassert>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
typedef string str;
//typedef __int128 ultraint;
//#define sqrt sqrtl
#define F first
#define S second
#define all(vc666) vc666.begin(), vc666.end()

const ll INF = (ll) 1e9 + 7;
const ll MOD = (ll) 1e9;
ld EPS = 1e-6;
ld PI = 3.1415926535897932384;
mt19937_64 gen(time(0));


struct Vec {
    ld x, y;
    Vec(ld _x = 0, ld _y = 0) {
        x = _x;
        y = _y;
    }
    Vec(Vec a, Vec b) {
        x = b.x - a.x;
        y = b.y - a.y;
    }
};

int sign(ld res) {
    if (fabs(res) <= EPS) {
        return 0;
    } else if (res > EPS) {
        return 1;
    } else {
        return -1;
    }
}

ld dot_product(Vec& a, Vec& b) {
    return a.x * b.x + a.y * b.y;
}

ld cross_product(Vec& a, Vec& b) {
    return a.x * b.y - a.y * b.x;
}

ld point_to_point(Vec& a, Vec& b) {
    return sqrtl((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

bool segment_point_cross(Vec& a, Vec& b, Vec& c) {
    if (fabs(point_to_point(a, b) - point_to_point(a, c) - point_to_point(b, c)) <= EPS) {
        return true;
    } else {
        return false;
    }
}

bool segment_cross(Vec& a, Vec& b, Vec& c, Vec& d) {
    Vec da(d, a), db(d, b), dc(d, c), ac(a, c), ad(a, d), ab(a, b);
    if (a.x == b.x && a.y == b.y) {
        return segment_point_cross(c, d, a);
    }
    if (c.x == d.x && c.y == d.y) {
        return segment_point_cross(a, b, c);
    }
    if (sign(cross_product(dc, da)) * sign(cross_product(dc, db)) <= 0 && sign(cross_product(ab, ac)) * sign(cross_product(ab, ad)) <= 0) {
        return true;
    } else {
        return false;
    }
}

int main() {
#ifdef _DEBUG
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    cout.tie(NULL);
    int t = 1;
    //cin >> t;
    while (t--) {
        int n, i, j, cnt = 0;
        cin >> n;
        Vec p1(0, 0), p2(0, 0);
        cin >> p1.x >> p1.y;
        p2.x = 1e6;
        p2.y = p1.y + 1;
        vector<Vec> a(n);
        bool flag = false;
        for (i = 0; i < n; i++) {
            cin >> a[i].x >> a[i].y;
        }
        for (i = 0; i < n; i++) {
            if (segment_point_cross(a[i], a[(i + 1) % n], p1)) {
                flag = true;
            }
            if (segment_cross(a[i], a[(i + 1) % n], p1, p2)) {
                cnt++;
            }
        }
        if (cnt % 2 == 1 || flag) {
            cout << "YES" << endl;
        } else {
            cout << "NO" << endl;
        }
    }
}
//Deisgned by skimono