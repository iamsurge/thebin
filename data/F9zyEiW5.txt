clear all
close all
clc




%% 1. kmeans clustering - Define aggregators positions
% *************************************************************************
% *************************************************************************
% *************************************************************************
% *************************************************************************

% Define the number of sensors and their positions
LEN_X = 250;
LEN_Y = 160;
N_sens = 100;
x_sens = -LEN_X/2 + rand(1, N_sens) * LEN_X;
y_sens = -LEN_Y/2 + rand(1, N_sens) * LEN_Y;
% My kmeans - Split sensors into clusters and define aggregators
K = 3;
epsilon_thr = 0.005;
points = [x_sens; y_sens];
colors1 = ["red", "green", "blue", "yellow", "cyan", "magenta", "black"];
colors2 = zeros(K, 3);
for k = 1 : K
    colors2(k, :) = [rand, rand, rand];
end

colors = [];
if K <= length(colors1)
    colors = colors1;
else
    colors = colors2;
end
[aggregators, groups] = my_kmeans(x_sens, y_sens, N_sens, K, epsilon_thr, colors, colors1, colors2);
aggregators = [20 -20 25; 10 0 -15];



%% 2. Fixed data about position and frequency
% *************************************************************************
% *************************************************************************
% *************************************************************************
% *************************************************************************

% BS's location
xb = (1+60/100) * LEN_X / 2;    yb = 0;    h_b = 15;    qb = [xb, yb];
% CP's location
x_cp = xb;    y_cp = 0;    q_cp = [x_cp, y_cp];


% Data EM waves
f = 5.8 * 10^9;    c = 3 * 10^8;    lambda = c / f;    B = 10^6;
Gt = 1;    Gr = 1;
Gt_dB = natural_to_dB(Gt);    Gr_dB = natural_to_dB(Gr);
P_aggr_max = 0.01;                       % 0.01 W = 10 dBm
P_tr = P_aggr_max / 2;

% Formulas for noise
sigma_dBm = -174 + 10 * log10(B);
sigma_dB = sigma_dBm - 30;
P_noise = dB_to_natural(sigma_dB);

% Calculations
Gt_dB = natural_to_dB(Gt);    Gr_dB = natural_to_dB(Gr);
% FSPL
d0 = 1;
rho_1m_dB = - (20 * log10(d0 * f) + 20 * log10(4*pi/c) - Gt_dB - Gr_dB);
rho_1m = dB_to_natural(rho_1m_dB);

% Data of UAV-RIS
H = 30;
d = lambda / 2;
delta_t = 2;
v_max_kmh = 62;
v_max = v_max_kmh / 3.6;                          % 16.67 m/s                 
a_max = 8.2;                                      % 8.2 m/s^2

% SNR Threshold
SNR_thr = 1;
rate_thr = B * log2(1 + SNR_thr);




%% 3. UAV Components - Find flight time
% *************************************************************************
% *************************************************************************
% *************************************************************************
% *************************************************************************

display('**********************************************************');
display('Technical UAV stats');
display(' ');
M_max = 600;
M = 500;
m_list = 1 : M;

name = "Tattu 30.000 mAh";
B_c = 666 * 3600;               % Wh  ---> W * s = Joule
B_w = 4.67;                     % kgr
UAV_w = 3.25;                   % kgr
E_w = 7.76 / 1000;              % kgr
T_max = 20;                     % kgr

rho_air = 1.225;                % kgr/m^3
v_a = 2.5;                      % 2.5 m/s
C_d = 0.005;
g = 9.81;                       % m/s^2


% This Case Scenario  (M)
logos_max = 0.4;                % (v / vmax)_max
v_max_mine = v_max * logos_max;
[Lt_minutes, P_tot] = find_Lt_minutes(M, logos_max, lambda, UAV_w, E_w, T_max, rho_air, v_a, C_d, g, v_max, B_w, B_c);
Lt_sec = floor(Lt_minutes * 60);
N = floor(Lt_sec / delta_t);
pretty_Lt(M, logos_max, P_tot, Lt_minutes, N);
display('**********************************************************');
display(' ');







%% 4. Technical RIS Stats - Weights and Dimensions
display('**********************************************************');
W = technical_RIS_stats(f, B, M, logos_max, lambda, UAV_w, E_w, T_max, rho_air, v_a, C_d, g, v_max, B_w, B_c);
display('**********************************************************');
display(' ');
display(' ');
display(' ');




%% 5. Initialize A, P, Q, Theta
% *************************************************************************
% *************************************************************************
% *************************************************************************
% *************************************************************************

display('**********************************************************');
display('---------------------------------');
display('---- Benchmarks trajectories ----');
display('---------------------------------');
display(' ');
n_list = 1 : N;
iter = 0;

%% 5a. Ellipsis
fprintf('<strong>a) Ellipsis </strong> \n');
Q1 = traj_ellipsis(q_cp, LEN_X, LEN_Y, N);
traj_INFO(Q1, K, N, M, aggregators, delta_t, P_tr, H, h_b, qb, ...
lambda, d, rho_1m, P_noise, B, SNR_thr, rate_thr, Lt_sec);

%% 5b. Traveling Salesman Cheapest Insertion
fprintf('<strong>b) Traveling Salesman Cheapest Insertion </strong> \n');
Q2 = traj_traveling_salesman(q_cp, N, aggregators, K);
traj_INFO(Q2, K, N, M, aggregators, delta_t, P_tr, H, h_b, qb, ...
lambda, d, rho_1m, P_noise, B, SNR_thr, rate_thr, Lt_sec);

%% 5c. Straight line
fprintf('<strong>c) Straight Line </strong> \n');
Q3 = traj_straight_line(q_cp, LEN_X, LEN_Y, N);
traj_INFO(Q3, K, N, M, aggregators, delta_t, P_tr, H, h_b, qb, ...
lambda, d, rho_1m, P_noise, B, SNR_thr, rate_thr, Lt_sec);

%% 5d. Romvos
fprintf('<strong>d) Romvos </strong> \n');
Q4 = traj_romvos(q_cp, LEN_X, LEN_Y, N);
traj_INFO(Q4, K, N, M, aggregators, delta_t, P_tr, H, h_b, qb, ...
lambda, d, rho_1m, P_noise, B, SNR_thr, rate_thr, Lt_sec);




%% 6. Plotting
Q_list = {};
Q_list{1} = Q1;
Q_list{2} = Q2;
Q_list{3} = Q3;
Q_list{4} = Q4;
trajectories = ["Ellipsis", "Traveling Salesman", "Straight Line", "Romvos"];
traj_COMPARE_PLOTS(LEN_X, LEN_Y, aggregators, ...
    x_cp, y_cp, xb, yb, K, colors);

for index = 1 : length(Q_list)
    Q = Q_list{index};
    x = Q(1, :);
    y = Q(2, :);
    plot(x, y, colors(index));
end
LEGEND = ["Field", "Aggregators", "CP", "BS"];
LEGEND = [LEGEND trajectories];
legend(LEGEND);


