-- print here to see if program was run successfully
print("counting!")

-- "wraping" peripherals basically means tying them
-- to variables. you could name them "my_monitor"
-- or "the_modem" if you wanted, you just have to
-- reference them 

-- Here im using "top" and "back" in reference to the
-- front of the computer when looking at it
monitor = peripheral.wrap("top")
modem = peripheral.wrap("back")

-- term.redirect redirects the text to the monitor
term.redirect(monitor)
-- clearing the previous text
term.clear()
-- setting the cursor to type text
term.setCursorPos(1,1)

-- applying first two list items from term.getSize()
-- to screenX and screenY
screenX, screenY = term.getSize()
--print(screenX)
--print(screenY)

--Opening the modems that I assign variables to
chan0 = 8650
chan1 = 8651
modem.open(chan0)
modem.open(chan1)

-- setting up my variables I will use in the future
-- Not sure which ones I actually use but doesn't matter
counting = 1
counts = {}
averages = {}
trueaverage = 0
total = 0
items = 0

-- First function I intend to run, second
-- is run later in the code.
local function countingf ()
    -- I want this to allways run so I put it in
    -- a while true loop
    while true do
        -- Lua lists index at 1 rather than 0
        -- I have this set up to take the input
        -- from the first computer which is
        -- periodically sending the total
        -- amount of blaze rods that are in the
        -- black hole unit.

        -- If the counter variable "counting" is
        -- less than or equal to two, then it will
        -- search for more input values using the
        -- os.pullEvent, and insert that into the
        -- table counts. At the end it will increase
        -- "counting" by one.
        if counting <= 2 then
            a, b, c, d, e = os.pullEvent("modem_message")
            --print(counting)
            --print(e .. " " .. counting)
            table.insert(counts, counting, e)
            if counting == 2 then
            sleep(0.5)
            --print("sleep1")
            else
            sleep(10)
            --print("sleep10")
            end
            counting = counting + 1
        else
            -- After we have gained the values and counter
            -- is greater than 2, we move on to totaling

            -- Here I add the two to get the total of both
            -- I dont know why but I add total here with
            -- both counts, I reset total at the end of this
            -- so there is no reason for it.
            total = total + counts[1] + counts[2]
            -- print for debugging
            --print(total)

            -- Taking away first count for total change in
            -- total of blaze rods
            total = total - counts[1]
            -- prints for debugging
            --print(total)
            --print(total)
            --sleep(2)

            -- Putting the total into my average gain of
            -- Blaze Rods Table
            table.insert(averages, #averages, total)
            -- Gets the total number of items in the averages
            -- list
            items = #averages
            -- sets the true average gain of blaze rods to 0
            trueaverage = 0
            -- For every item in my averages list (dont know
            -- how to do for loops :(    )
            while items > 0 do
                trueaverage = trueaverage + averages[items]
                items = items - 1
            end
        -- Calculates the average gain of blaze rods
        -- for all the rates
        trueaverage = trueaverage / #averages

        -- Clears the terminal of the past information
        term.clear()
        -- This is the math for the rates, calculated every 10
        -- seconds or about so multiply by 6 to get a minute
        print("Average Yeild/Minute : " .. math.ceil(trueaverage * 6) .. " Rods")
        -- EMC of a blaze rod is 1536 so input that into the equation
        print("Average EMC/Minute : " .. math.ceil(trueaverage * 6 * 1536 / 1000) .. "K")
        -- Display the total from the original message
        print("Current Total : " .. e .. " Rods")
        -- Displays the current EMC stored in blaze rods, but
        -- in millions because the number is high. Includes one
        -- decimal place for the hundred thousands.
        print("Current EMC : " .. (math.ceil(((e * 1536)/100000)))/10 .. "M EMC")
        --Resets cursor position
        term.setCursorPos(1,1)
    
        --Resets counter variable, table, and total
        counting = 1
        counts = {}
        total = 0
    
    --sleep(1)
    end
    
    -- This is all dead code that im not sure what it does,
    -- it can be ignored
    -----------------------------------------------------
    -----------------------------------------------------
    --if counting < 10 then
        --a, b, c, d, e = os.pullEvent("modem_message")
        --print(counting)
        --print(e)
        --table.insert(counts, counting, e)
        --print(counts[counting])
        --counting = counting + 1
    --else
    --term.setCursorPos(screenX/2, screenY/2)
        
    --total = total + counts[2] + counts[3] + counts[4] + counts[5] + counts[6]
    --total = total / 5
    --total = total - counts[1]
    --print(total)
    --term.setCursorPos(1,1)
    
    --counting = 1
    --counts = {}
    --sleep(1)
    --total = 0
    --end

    -----------------------------------------------------
    -----------------------------------------------------

    -- end of dead code
    end
end
----------- end counting function

local function onOff ()
    -- This is the code for toggling the
    -- turtle telling it to move backward or
    -- forward depending on what state it is in
    -- State is stored in this computer, why I
    -- dont know, but it transmits "turnOn" or
    -- "turnOff" depending on what it said last.

    -- The turtle then recieves this and moves
    -- back or forward depending on the message it
    -- recieves.

    toggle = 0
    while true do
        while redstone.getInput("top") do
            --sleep(1)
           if toggle == 0 then
               modem.transmit(chan1, chan1, "turnOn")
               --sleep(1) 
               toggle = 1
               print("toggle")
               sleep(1)
           else
           
           if toggle == 1 then
               modem.transmit(chan1, chan1, "turnOff")
               --sleep(1) 
               toggle = 0
               print("toggle")
               sleep(1)
           end
           end
           --sleep(2)
        end
        -- sleep so computer doesnt die
        sleep(0.25)
    end    






end

------------ Run Both Functions at the same time using parallel function
parallel.waitForAll(countingf, onOff)


