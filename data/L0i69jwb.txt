from fractions import Fraction as f

# Данные импорты нужны сугубо для удобства работы с матрицами
import numpy as np
import sympy as sy


def make_inverse_matrix(a):
    # Находим обратную матрицу с помощью Метода Гаусса
    n = len(a)
    m = len(a[0])
    # Единичная матрица размера N x N
    ones = np.eye(n, dtype=f)
    # Ведущая строка a[k], ведущий элемент a[k][k]
    for k in range(n):
        # Идем сверху вниз по всем элементам главной диагонали
        if not any(a[k]):
            # Если матрица имеет нулевую строку, то вызываем ошибку
            raise ValueError('Невозможно найти обратную матрицу от заданной!')

        for i in range(1+k, n):
            x = -a[i][k]/a[k][k]
            for j in range(m):
                # В зависимости от ведущей строки изменяются
                # все нижние строки
                # (1)2 3 ↴ x4    (1) 2  3 ↴ x7   (1) 2  3
                #  4 5 6 ↲ -  ->  0 -3 -6      -> 0 -3 -6
                #  7 8 9          7  8  9 ↲ -     0 -6 -12
                a[i][j] += a[k][j]*x
                # Симметрично изменяем единичную матрицу
                ones[i][j] += ones[k][j]*x

    for k in range(n-1, -1, -1):
        # Идём снизу вверх по всем элементам главной диагонали

        x = a[k][k]
        # Превращаем ведущий элемент в единицу
        a[k][k] /= x
        # Делим симметрично строку в единичной матрице на
        # предыдущее число ведущего элемента
        ones[k] = (lambda i: i/x)(ones[k])
        for i in range(k-1, -1, -1):
            x = -a[i][k]
            # Обнуляем все элементы в колонке выше
            a[i][k] += x
            # Попутно изменяя соответствующие строки в едичной матрице, где
            # ones[i] - "текущая" строка, которую нужно изменить
            # ones[k] - "изменяющая" строка, которая изменяет все строки выше
            # x - на какое число умножается изменяющая строка
            for j in range(m):
                # Поэлементно изменяем "текущую" строку
                ones[i][j] += ones[k][j]*x
    # Возвращаем изменненую изначальную матрицу(стала единичной)
    # и обратную матрицу от изначальной
    return a, ones

n = int(input())
A = np.array([[f(x) for x in input().split()] for i in range(n)])
print('\nA:')
sy.pprint(sy.Matrix(A))

E, inv_A = make_inverse_matrix(A)

print('\nA -> E:')
sy.pprint(sy.Matrix(E))
print('\nE -> A^-1:')
sy.pprint(sy.Matrix(inv_A))
