package lab53;

import java.util.*;

public class ckfGauss {
    public static double a;
    public static double b;

    public static int N;
    public static int m;

    public static double h;

    public static double p_pred;
    public static double p_pred_pred;

    public static void main(String[] args) {
        start();
        task3ForN();
    }

    public static double fi(double x) {
        return Math.sin(x) / Math.pow(x, 1 / 4.0);
    }

    public static double integrand(double x) {
        if (x == 0) {
            return 0;
        }
        return fi(x);
    }

    public static double integral() {
        double h = (b - a) / 5000;
        double z = integrand(a) + integrand(b);

        double sumValues = 0;
        for (int j = 0; j < 5000; j++) {
            double yj = a + j * h;
            sumValues += integrand(yj + h / 2);
        }
        double q = sumValues;

        double sum = 0;
        for (int j = 1; j < 5000; j++) {
            double yj = a + j * h;
            sum += integrand(yj);
        }
        double w = sum;

        return (h / 6) * (z + 2 * w + 4 * q);
    }

    public static void start() {
        System.out.println("Начальные данные:");
        System.out.println("Подынтегральная функция: sin(x) * x^(-1/4)");
        System.out.println("Весовая функция p(x) = x^(-1/4)");
        System.out.println("                f(x) = sin(x)");
        System.out.println("Введите границы интегрирования a, b:");
        Scanner scanner1 = new Scanner(System.in);
        a = scanner1.nextDouble();
        b = scanner1.nextDouble();

        System.out.println("Введите число узлов N и число промежутков деления отрезка m:");
        Scanner scanner2 = new Scanner(System.in);
        N = scanner2.nextInt();
        m = scanner2.nextInt();

        h = (b - a) / m;

        System.out.println("a = " + a + "; b = " + b + "; N = " + N + "; m = " + m + "; h = " + h);
    }

    public static void task3ForN() {
        System.out.println("Узлы и коэффициенты КФ Гаусса при N = " + N);
        double[] tk = findNodesX();
        Map<Double, Double> tkCk = calculateCk(tk);

        int num = 1;
        double sum = 0;
        for (var tC : tkCk.entrySet()) {
            System.out.println("t" + num + " = " + tC.getKey() + "; C" + num + " = " + tC.getValue());
            num++;
            sum += tC.getValue();
        }

        System.out.println("Контроль: сумма всех коэффициентов Ck = " + sum);
        double srcValueIntegral = integral();
        System.out.println("Точное значение интеграла: " + srcValueIntegral);

        double result = calcIntegral(tkCk);
        System.out.println("Найденное приближенное значение интеграла: " + result);
        System.out.println("Разница с точным значением: " + Math.abs(srcValueIntegral - result));
        System.out.println();
    }

    public static double[] findNodesX() {
        double[] x = new double[N];

        var intervals = separateRoots(100);
        int num = 0;

        for (List<Double> interval : intervals) {
            x[num] = bisectionMethod(interval.get(0), interval.get(1), 0.000000000001);
            num++;
        }

        return x;
    }

    public static List<List<Double>> separateRoots(int count) {
        double a1 = -1;
        double b1 = 1;

        List<List<Double>> intervals = new LinkedList<>();
        double H = (b1 - a1) / count;
        double x1 = a1;
        double x2 = a1 + H;
        double y1 = PnLegendre(N, x1);
        double y2;

        while (x2 <= b1) {
            y2 = PnLegendre(N, x2);
            if (y1 * y2 < 0) {
                intervals.add(List.of(x1, x2));
            }
            x1 = x2;
            x2 = x1 + H;
            y1 = y2;
        }

        return intervals;
    }

    public static double bisectionMethod(double a1, double b1, double e) {
        double c;
        while (b1 - a1 > 2 * e) {
            c = (a1 + b1) / 2;
            if (PnLegendre(N, a1) * PnLegendre(N, c) < 0) {
                b1 = c;
            } else {
                a1 = c;
            }
        }

        return (a1 + b1) / 2;
    }

    public static Map<Double, Double> calculateCk(double[] x) {
        Map<Double, Double> xkCk = new HashMap<>();

        for (int k = 0; k < x.length; k++) {
            double xk = x[k];
            double Ck = 2 * (1 - Math.pow(xk, 2)) / (Math.pow(N, 2) * Math.pow(PnLegendre(N - 1, xk), 2));

            xkCk.put(xk, Ck);
        }

        return xkCk;
    }

    public static double calcIntegral(Map<Double, Double> tkCk) {
        double result = 0;
        for (int j = 0; j < m; j++) {
            double oneSlag = 0;
            for (var tC : tkCk.entrySet()) {
                double tk = tC.getKey();
                double zj = a + j * h;
                double zj1 = a + (j + 1) * h;

                double xkj = (h / 2.0) * tk + (zj + zj1) / 2.0;
                oneSlag += tC.getValue() * fi(xkj);
            }
            result += oneSlag;
        }

        return (h / 2.0) * result;
    }

    public static double PnLegendre(int n, double x) {
        if (n == 0) {
            return 1;
        }

        if (n == 1) {
            return x;
        }

        p_pred = x;
        p_pred_pred = 1;

        double k = 2;
        while (true) {
            double p_current_k;

            double c1 = (2 * k - 1) / k;
            double c2 = (k - 1) / k;

            p_current_k = c1 * p_pred * x - c2 * p_pred_pred;

            if (k == n) {
                return p_current_k;
            }

            k++;

            double tmp = p_pred;
            p_pred = p_current_k;
            p_pred_pred = tmp;
        }
    }
}
