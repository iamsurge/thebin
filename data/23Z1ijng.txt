/*
Un program C care primeste 2 argumente. Primul argument e path-ul catre
un director si al doilea argument e un sir de optiuni (ex "-a","-u","-n").
Cerinte:
- testul de argumente
- parcurgere nerecursuva de director
- identificare fisisere cu extensia .c
- caz particular pentru fiecare optiune
*/
#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(int argc, char *argv[])
{
    if (argc != 3)
    {
        printf("Number of arguments is different from 2!\n");
        exit(1);
    }

    printf("\nThe program gets 2 arguments: a path (%s) and a string of options (%s)\n\n", argv[1], argv[2]);

    DIR *dir;
    struct dirent *dp;
    if ((dir = opendir(argv[1])) == NULL)
    {
        printf("Non-existent directory at the given path!");
        exit(1);
    }

    while ((dp = readdir(dir)) != NULL)
    {

        char path[30];
        strcpy(path, argv[1]);
        strcat(path, "/");
        strcat(path, dp->d_name);

        struct stat statRes;

        if (lstat(path, &statRes) == -1)
        {
            exit(1);
        }

        mode_t bits = statRes.st_mode;

        if (S_ISDIR(bits) && dp->d_name[0] != '.')
        {
            printf("%s is a directory!\n\n", dp->d_name);
        }

        int l = strlen(dp->d_name);
        if (dp->d_name[l - 2] == '.' && dp->d_name[l - 1] == 'c')
        {
            char opt[20], prog[500], exe[500];
            int pid, pid_g, pid_p, pid_filter, status;
            int pipe_send_lines[2], pipe_send_output[2];

            if ((pid = fork()) < 0)
            {
                printf("Error");
                exit(1);
            }

            if (pid == 0)
            {
                strcpy(opt, argv[2]);

                if (opt[0] == '-')
                    for (int i = 1; i <= strlen(opt); i++)
                    {
                        switch (opt[i])
                        {
                        case 'n':
                            printf("Name of file: %s\n", dp->d_name);
                            break;

                        case 'u':
                            printf("User ID of the owner:%d\n", statRes.st_uid);
                            break;

                        case 'a':
                            printf("Access rights:\n");
                            printf("User:\n");
                            printf("Read: ");
                            if ((bits & S_IRUSR) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Write: ");
                            if ((bits & S_IWUSR) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Execute: ");
                            if ((bits & S_IXUSR) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Group:\n");
                            printf("Read: ");
                            if ((bits & S_IRGRP) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Write: ");
                            if ((bits & S_IWGRP) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Execute: ");
                            if ((bits & S_IXGRP) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Other:\n");
                            printf("Read: ");
                            if ((bits & S_IROTH) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Write: ");
                            if ((bits & S_IWOTH) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            printf("Execute: ");
                            if ((bits & S_IXOTH) != 0)
                                printf("YES\n");
                            else
                                printf("NO\n");
                            break;

                        case 'd':
                            printf("File size: %ld bytes\n", statRes.st_size);
                            break;

                        case 'c':
                            printf("Number of hardlinks: %lu\n", statRes.st_nlink);
                            break;

                        case 'g':
                            if ((pid_g = fork()) < 0)
                            {
                                printf("Error");
                                exit(1);
                            }

                            if (pid_g == 0)
                            {
                                sprintf(prog, "%s/%s", argv[1], dp->d_name);
                                sprintf(exe, "%s/%s", argv[1], dp->d_name);
                                exe[strlen(exe) - 2] = '\0';
                                execlp("gcc", "gcc", prog, "-o", exe, NULL);

                                printf("Compilation failed");
                                exit(0);
                            }
                            pid_g = wait(&status);
                            if (status == 0)
                            {
                                printf("%s compiled successfully\n", dp->d_name);
                            }
                            printf("Child process with PID %d exited with code %d\n", pid_g, status);
                            break;

                        case 'p':
                            if (pipe(pipe_send_lines) < 0)
                            {
                                printf("Error");
                                exit(1);
                            }

                            if (pipe(pipe_send_output) < 0)
                            {
                                printf("Error");
                                exit(1);
                            }

                            if ((pid_p = fork()) < 0)
                            {
                                printf("Error");
                                exit(1);
                            }

                            if (pid_p == 0)
                            {
                                if ((pid_filter = fork()) < 0)
                                {
                                    printf("Error");
                                    exit(1);
                                }

                                if (pid_filter == 0)
                                {
                                    close(pipe_send_lines[0]);
                                    close(pipe_send_output[1]);

                                    dup2(pipe_send_output[0], 0);
                                    dup2(pipe_send_lines[1], 1);

                                    execlp("grep", "grep", "\\(warning\\|error\\)", NULL);

                                    printf("Execution error");
                                }
                                close(pipe_send_lines[0]);
                                close(pipe_send_lines[1]);
                                close(pipe_send_output[0]);

                                dup2(pipe_send_output[1], 2);

                                sprintf(prog, "%s/%s", argv[1], dp->d_name);
                                sprintf(exe, "%s/%s", argv[1], dp->d_name);
                                exe[strlen(exe) - 2] = '\0';
                                execlp("gcc", "gcc", prog, "-o", exe, "-Wall", NULL);

                                printf("Compilation failed");
                                exit(1);
                            }
                            close(pipe_send_output[0]);
                            close(pipe_send_output[1]);
                            close(pipe_send_lines[1]);

                            FILE *stream = fdopen(pipe_send_lines[0], "r");
                            char line[100];
                            int err = 0, war = 0, points = 0;

                            while (fgets(line, sizeof(line) / sizeof(char), stream))
                            {
                                if (strstr(line, "error") != NULL)
                                {
                                    err++;
                                }
                                if (strstr(line, "warning") != NULL)
                                {
                                    war++;
                                }
                            }

                            if (err == 0 && war == 0)
                            {
                                points = 10;
                            }
                            if (err > 0)
                            {
                                points = 1;
                            }
                            if (err == 0)
                            {
                                if (war > 10)
                                {
                                    points = 2;
                                }
                                else
                                {
                                    points = 2 + 8 * (10 - war) / 10;
                                }
                            }

                            printf("Errors:%d, Warnings:%d, Points:%d\n", err, war, points);

                            pid_p = wait(&status);
                            if (status == 0)
                            {
                                printf("%s compiled successfully\n", dp->d_name);
                            }
                            printf("Child process with PID %d exited with code %d\n", pid_p, status);
                            break;
                        }
                    }
                exit(0);
            }
            pid = wait(&status);
            printf("Child process with PID %d exited with code %d\n", pid, status);

            if ((pid = fork()) < 0)
            {
                printf("Error");
                exit(1);
            }

            if (pid == 0)
            {
                if (statRes.st_size < 102400)
                {
                    char s_link[20];
                    strcpy(s_link, dp->d_name);
                    s_link[strlen(s_link) - 2] = '\0';
                    int sl = symlink(path, s_link);
                    if (sl == 0)
                    {
                        printf("Soft link created successfully\n");
                    }
                    else
                    {
                        printf("Soft link already exists or cannot be created\n");
                    }
                }
                exit(0);
            }
            pid = wait(&status);
            printf("Child process with PID %d exited with code %d\n", pid, status);

            printf("\n");
        }
    }

    closedir(dir);

    return 0;
}