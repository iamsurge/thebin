typedef struct _PCI_CLASSCODETABLE
{
	int BaseClass;
	int SubClass;
	int ProgIf;
	const char* BaseDesc;
	const char* SubDesc;
	const char* ProgDesc;
} PCI_CLASSCODETABLE, * PPCI_CLASSCODETABLE;

PCI_CLASSCODETABLE PciClassCodeTable[] =
{
	{ 0x00, 0x00, 0x00, "Pre-2.0 PCI Specification Device", "Non-VGA","" } ,
	{ 0x00, 0x01, 0x00, "Pre-2.0 PCI Specification Device", "VGA Compatible", "" } ,

	{ 0x01, 0x00, 0x00, "Mass Storage Controller", "SCSI", "" } ,
	{ 0x01, 0x01, 0x00, "Mass Storage Controller", "IDE", "" } ,
	{ 0x01, 0x02, 0x00, "Mass Storage Controller", "Floppy", "" } ,
	{ 0x01, 0x03, 0x00, "Mass Storage Controller", "IPI", "" } ,
	{ 0x01, 0x04, 0x00, "Mass Storage Controller", "RAID", "" } ,
	{ 0x01, 0x05, 0x00, "Mass Storage Controller", "ATA Controller", "" } ,
	{ 0x01, 0x06, 0x00, "Mass Storage Controller", "Serial ATA Controller", "" } ,
	{ 0x01, 0x07, 0x00, "Mass Storage Controller", "Serial Attached SCSI Controller", "" } ,
	{ 0x01, 0x80, 0x00, "Mass Storage Controller", "Other", "" } ,

	{ 0x02, 0x00, 0x00, "Network Controller", "Ethernet/WiFi", "" } ,
	{ 0x02, 0x01, 0x00, "Network Controller", "Token Ring", "" } ,
	{ 0x02, 0x02, 0x00, "Network Controller", "FDDI", "" } ,
	{ 0x02, 0x03, 0x00, "Network Controller", "ATM", "" } ,
	{ 0x02, 0x80, 0x00, "Network Controller", "Other", "" } ,

	{ 0x03, 0x00, 0x00, "Display Controller", "VGA Compatible", "VGA" } ,
	{ 0x03, 0x00, 0x01, "Display Controller", "IBM Compatible", "8514" } ,
	{ 0x03, 0x01, 0x00, "Display Controller", "XGA", "" } ,
	{ 0x03, 0x02, 0x00, "Display Controller", "3D Graphics", "" } ,
	{ 0x03, 0x80, 0x00, "Display Controller", "Other", "" } ,

	{ 0x04, 0x00, 0x00, "Multimedia Device", "Video Controller", "" } ,
	{ 0x04, 0x01, 0x00, "Multimedia Device", "Audio Controller", "" } ,
	{ 0x04, 0x02, 0x00, "Multimedia Device", "Telephony Controller", "" } ,
	{ 0x04, 0x03, 0x00, "Multimedia Device", "Audio Device", "" } ,
	{ 0x04, 0x80, 0x00, "Multimedia Device", "Other", "" } ,

	{ 0x05, 0x00, 0x00, "Memory Controller", "RAM", "" } ,
	{ 0x05, 0x01, 0x00, "Memory Controller", "Flash", "" } ,
	{ 0x05, 0x80, 0x00, "Memory Controller", "Other", "" } ,

	{ 0x06, 0x00, 0x00, "Bridge Device", "Host/PCI", "" } ,
	{ 0x06, 0x01, 0x00, "Bridge Device", "PCI/ISA", "" } ,
	{ 0x06, 0x02, 0x00, "Bridge Device", "PCI/EISA", "" } ,
	{ 0x06, 0x03, 0x00, "Bridge Device", "PCI/Micro Channel", "" } ,
	{ 0x06, 0x04, 0x00, "Bridge Device", "PCI/PCI", "" } ,
	{ 0x06, 0x05, 0x00, "Bridge Device", "PCI/PCMCIA", "" } ,
	{ 0x06, 0x06, 0x00, "Bridge Device", "PCI/NuBus", "" } ,
	{ 0x06, 0x07, 0x00, "Bridge Device", "PCI/CardBus", "" } ,
	{ 0x06, 0x08, 0x00, "Bridge Device", "PCI/RACEway", "" } ,
	{ 0x06, 0x09, 0x00, "Bridge Device", "PCI/PCI", "" } ,
	{ 0x06, 0x0A, 0x00, "Bridge Device", "PCI/InfiniBand", "" } ,
	{ 0x06, 0x80, 0x00, "Bridge Device", "Other", "" } ,

	{ 0x07, 0x00, 0x00, "Simple Communications Controller", "Serial", "Generic XT Compatible" } ,
	{ 0x07, 0x00, 0x01, "Simple Communications Controller", "Serial", "16450 Compatible" } ,
	{ 0x07, 0x00, 0x02, "Simple Communications Controller", "Serial", "16550 Compatible" } ,
	{ 0x07, 0x00, 0x03, "Simple Communications Controller", "Serial", "16650 Compatible" } ,
	{ 0x07, 0x00, 0x04, "Simple Communications Controller", "Serial", "16750 Compatible" } ,
	{ 0x07, 0x00, 0x05, "Simple Communications Controller", "Serial", "16850 Compatible" } ,
	{ 0x07, 0x00, 0x06, "Simple Communications Controller", "Serial", "16950 Compatible" } ,

	{ 0x07, 0x01, 0x00, "Simple Communications Controller", "Parallel", "Standard" } ,
	{ 0x07, 0x01, 0x00, "Simple Communications Controller", "Parallel", "Bidirectional" } ,
	{ 0x07, 0x01, 0x01, "Simple Communications Controller", "Parallel", "ECP 1.X Compliant" } ,
	{ 0x07, 0x01, 0x02, "Simple Communications Controller", "Parallel", "ECP 2.X Compliant" } ,
	{ 0x07, 0x01, 0x03, "Simple Communications Controller", "Parallel", "IEEE1284 Compliant" } ,

	{ 0x07, 0x02, 0x00, "Simple Communications Controller", "Multiport Serial Controller", "" } ,
	{ 0x07, 0x03, 0x00, "Simple Communications Controller", "Dial-up modem", "" } ,
	{ 0x07, 0x80, 0x02, "Simple Communications Controller", "Other", "" } ,

	{ 0x08, 0x00, 0x00, "Base Systems Peripheral", "PIC (Programmable Interrupt Controller)", "Generic 8259" } ,
	{ 0x08, 0x00, 0x01, "Base Systems Peripheral", "PIC (Programmable Interrupt Controller)", "ISA" } ,
	{ 0x08, 0x00, 0x02, "Base Systems Peripheral", "PIC (Programmable Interrupt Controller)", "EISA/PCI" } ,
	{ 0x08, 0x00, 0x10, "Base Systems Peripheral", "PIC (Programmable Interrupt Controller)", "IO APIC" } ,
	{ 0x08, 0x00, 0x20, "Base Systems Peripheral", "PIC (Programmable Interrupt Controller)", "IO(X) APIC" } ,

	{ 0x08, 0x01, 0x00, "Base Systems Peripheral", "DMA (Direct Memory Access)", "Generic 8259" } ,
	{ 0x08, 0x01, 0x01, "Base Systems Peripheral", "DMA (Direct Memory Access)", "ISA" } ,
	{ 0x08, 0x01, 0x02, "Base Systems Peripheral", "DMA (Direct Memory Access)", "EISA" } ,
	{ 0x08, 0x02, 0x00, "Base Systems Peripheral", "System Timer", "Generic 8259" } ,
	{ 0x08, 0x02, 0x01, "Base Systems Peripheral", "System Timer", "ISA" } ,
	{ 0x08, 0x02, 0x02, "Base Systems Peripheral", "System Timer", "EISA" } ,
	{ 0x08, 0x03, 0x00, "Base Systems Peripheral", "RTC (Real Time Clock)", "Generic" } ,
	{ 0x08, 0x03, 0x01, "Base Systems Peripheral", "RTC (Real Time Clock)", "ISA" } ,
	{ 0x08, 0x04, 0x00, "Base Systems Peripheral", "PCI Hot-plug controller", "" } ,
	{ 0x08, 0x05, 0x00, "Base Systems Peripheral", "SD Host Controller", "" } ,
	{ 0x08, 0x80, 0x00, "Base Systems Peripheral", "Other", "" } ,

	{ 0x09, 0x00, 0x00, "Input Device", "Keyboard", "" } ,
	{ 0x09, 0x01, 0x00, "Input Device", "Digitizer (Pen)", "" } ,
	{ 0x09, 0x02, 0x00, "Input Device", "Mouse", "" } ,
	{ 0x09, 0x80, 0x00, "Input Device", "Other", "" } ,

	{ 0x0A, 0x00, 0x00, "Docking Station", "Generic", "" } ,
	{ 0x0A, 0x80, 0x00, "Docking Station", "Other", "" } ,

	{ 0x0B, 0x00, 0x00, "Processor", "i386", "" } ,
	{ 0x0B, 0x01, 0x00, "Processor", "i486", "" } ,
	{ 0x0B, 0x02, 0x00, "Processor", "Pentium", "" } ,
	{ 0x0B, 0x10, 0x00, "Processor", "Alpha", "" } ,
	{ 0x0B, 0x20, 0x00, "Processor", "Power PC", "" } ,
	{ 0x0B, 0x30, 0x00, "Processor", "MIPS", "" } ,
	{ 0x0B, 0x80, 0x00, "Processor", "Co-processor", "" } ,

	{ 0x0C, 0x00, 0x00, "Serial Bus Controller", "Firewire (IEEE 1394)", "" } ,
	{ 0x0C, 0x01, 0x00, "Serial Bus Controller", "ACCESS.bus", "" } ,
	{ 0x0C, 0x02, 0x00, "Serial Bus Controller", "SSA (Serial Storage Archetecture)", "" } ,
	{ 0x0C, 0x03, 0x00, "Serial Bus Controller", "USB 1.1 UHCI", "" } ,
	{ 0x0C, 0x03, 0x10, "Serial Bus Controller", "USB 1.1 OHCI", "" } ,
	{ 0x0C, 0x03, 0x20, "Serial Bus Controller", "USB 2.0 EHCI", "" } ,
	{ 0x0C, 0x03, 0x80, "Serial Bus Controller", "USB", "Unknown" } ,
	{ 0x0C, 0x03, 0xFE, "Serial Bus Controller", "USB", "USB Device" } ,

	{ 0x0C, 0x04, 0x00, "Serial Bus Controller", "Fibre Channel", "" } ,
	{ 0x0C, 0x05, 0x00, "Serial Bus Controller", "SMbus", "" } ,
	{ 0x0C, 0x06, 0x00, "Serial Bus Controller", "InfiniBand", "" } ,
	{ 0x0C, 0x07, 0x00, "Serial Bus Controller", "IPMI (SMIC)", "" } ,
	{ 0x0C, 0x08, 0x00, "Serial Bus Controller", "SERCOS", "" } ,

	{ 0x0D, 0x00, 0x00, "Wireless Controller", "IrDA", "" } ,
	{ 0x0D, 0x01, 0x00, "Wireless Controller", "Consumer IR", "" } ,
	{ 0x0D, 0x10, 0x00, "Wireless Controller", "Custom RF", "" } ,
	{ 0x0D, 0x11, 0x00, "Wireless Controller", "Bluetooth", "" } ,
	{ 0x0D, 0x12, 0x00, "Wireless Controller", "Broadband", "" } ,
	{ 0x0D, 0x20, 0x00, "Wireless Controller", "WiFi 802.11a", "" } ,
	{ 0x0D, 0x21, 0x00, "Wireless Controller", "WiFi 802.11b", "" } ,


	{ 0xFF, 0x00, 0x00, "Unknown", "Device Does Not Fit In Class Codes", "UDF" } ,
};

#define PCI_CLASSCODETABLE_LEN (sizeof(PciClassCodeTable)/sizeof(PCI_CLASSCODETABLE))
#include <stdio.h>
#include <dos.h>
#include <Windows.h>

typedef unsigned char BYTE;
typedef unsigned int WORD;
typedef unsigned long DWORD;

#define PDI_BUS_SHIFT 8
#define PDI_BUS_SIZE 8
#define PDI_BUS_MAX 0xFF
#define PDI_BUS_MASK 0xFF00
#define PDI_DEVICE_SHIFT 3
#define PDI_DEVICE_SIZE 5
#define PDI_DEVICE_MAX 0x1F
#define PDI_DEVICE_MASK 0x00F8
#define PDI_FUNCTION_SHIFT 0
#define PDI_FUNCTION_SIZE 3
#define PDI_FUNCTION_MAX 0x7
#define PDI_FUNCTION_MASK 0x0007
//int fl1 = 0, fl2 = 0, fl3 = 0;


#define PCI_CONFIG_ADDRESS 0xCF8
#define PCI_CONFIG_DATA 0xCFC




DWORD inpd(int portid)
{
DWORD dwRet;
_asm mov dx, portid;
_asm lea bx, dwRet;
__emit__ (
0x66, 0x50, // push EAX
0x66, 0xED, // in EAX,DX
0x66, 0x89, 0x07, // mov [BX],EAX
0x66, 0x58); // pop EAX
return dwRet;
}


void outpd(int portid, DWORD dwVal)
{
_asm mov dx, portid;
_asm lea bx, dwVal;
__emit__(
0x66, 0x50, // push EAX
0x66, 0x8B, 0x07, // mov EAX,[BX]
0x66, 0xEF, // out DX,EAX
0x66, 0x58
);// pop EAX
return;
}

int main(void)
{
	int bus, dev, func;
	int i,l = 0;
	DWORD dwAddr;
	DWORD dwData;
	BYTE* datadw;
	printf("\n");
	printf("?\tVendor\tDevice\tBaseDevName\t\tSubDevName\n");

	for (bus = 0; bus <= PDI_BUS_MAX; ++bus) {
		for (dev = 0; dev <= PDI_DEVICE_MAX; ++dev) {
			for (func = 0; func <= PDI_FUNCTION_MAX; ++func) {

				dwAddr = (DWORD)(0x80000000L | 
					(DWORD)(WORD)((bus & PDI_BUS_MAX) <<  PDI_BUS_SHIFT |
					(dev & PDI_DEVICE_MAX) << PDI_DEVICE_SHIFT |
					(func & PDI_FUNCTION_MAX) << 8));

				
				outpd(PCI_CONFIG_ADDRESS, dwAddr);
				dwData = inpd(PCI_CONFIG_DATA);

				if ((WORD)dwData != 0xFFFF) {
						if ((WORD)dwData != 0000) {
							printf("%i",l); printf("\t");
							/* Vendor/Device */
							printf("%4.4X\t%4.4X\t", (WORD)dwData, dwData >> 16);
							/* Class Code */
							outpd(PCI_CONFIG_ADDRESS, dwAddr | 0x8);
							dwData = inpd(PCI_CONFIG_DATA);
							datadw = new BYTE[sizeof(dwData)];
							memcpy(datadw, &dwData, 4);
							for (int z = 0; z < 107; z++) {
								if ((int)datadw[1] == PciClassCodeTable[z].ProgIf) {
									if ((int)datadw[2] == PciClassCodeTable[z].SubClass) {
										if ((int)datadw[3] == PciClassCodeTable[z].BaseClass) {
											for (int o1 = 0; o1 < strlen(PciClassCodeTable[z].SubDesc); o1++) {
												printf("%c", PciClassCodeTable[z].SubDesc[o1]);
											}
											printf("\t");
											printf("\t");
											for (int o = 0; o < strlen(PciClassCodeTable[z].BaseDesc); o++){
												printf("%c", PciClassCodeTable[z].BaseDesc[o]);
											}
											break;
										}
									}
								}
			
							}
							printf("\n");
							Sleep(1);
							l++;
						}
					}
			}
		}
	}
	return 0;
}