import numpy as np

a = np.array([[10**-4,1,1],
              [1,2,4]])

a1 = np.array([[10**-4,1],[1,2]])
a2 = np.array([1,4])

b = np.array([[2.34,-4.21,-11.61,14.41],
                [8.04,5.22,0.27,-6.44],
                [3.92,-7.99,8.37,55.56]])

b1 = np.array([[2.34,8.04,3.92],[-4.21,5.22,-7.99],[-11.61,0.27,8.37]])
b2 = np.array([14.41,-6.44,55.56])

c = np.array([[4.43,-7.21,8.05,1.23,-2.56,2.62],
                [-1.29,6.47,2.96,3.22,6.12,-3.97],
                [6.12,8.31,9.41,1.8,-2.88,-9.12],
                [-2.57,6.93,-3.74,7.41,5.55,8.11],
                [1.46,3.62,7.83,6.25,-2.35,7.23]])
c1 = c[:,:-1]
c2 = c[:,-1]


def make_identity(matrix):
    # перебор строк в обратном порядке 
    for nrow in range(len(matrix)-1,0,-1):
        row = matrix[nrow]
        for upper_row in matrix[:nrow]:
            factor = upper_row[nrow]
            upper_row -= factor*row
    return matrix

def gaussPivotFunc(matrix):
    for nrow in range(len(matrix)):
        # nrow равен номеру строки
        # np.argmax возвращает номер строки с максимальным элементом в уменьшенной матрице
        # которая начинается со строки nrow. Поэтому нужно прибавить nrow к результату
        pivot = nrow + np.argmax(abs(matrix[nrow:, nrow]))
        if pivot != nrow:
            # swap
            # matrix[nrow], matrix[pivot] = matrix[pivot], matrix[nrow] - не работает.
            # нужно переставлять строки именно так, как написано ниже
            matrix[[nrow, pivot]] = matrix[[pivot, nrow]]
        row = matrix[nrow]
        divider = row[nrow] # диагональный элемент
        if abs(divider) < 1e-10:
            # почти нуль на диагонали. Продолжать не имеет смысла, результат счёта неустойчив
            raise ValueError(f"Матрица несовместна. Максимальный элемент в столбце {nrow}: {divider:.3g}")
        # делим на диагональный элемент.
        row /= divider
        # теперь надо вычесть приведённую строку из всех нижележащих строчек
        for lower_row in matrix[nrow+1:]:
            factor = lower_row[nrow] # элемент строки в колонке nrow
            lower_row -= factor*row # вычитаем, чтобы получить ноль в колонке nrow
    # приводим к диагональному виду
    make_identity(matrix)
    return matrix

def neuv(matrix1,matrix2):
    for i in matrix1:
        sum = 0
        for iq,j in np.ndenumerate(matrix2):
            sum += i[iq] * j
        print(sum)
        print(i[-1])

print("First")
print(gaussPivotFunc(a))
print(a)
matrix = np.linalg.solve(a1,a2)
print(matrix)
print(neuv(a,matrix))
print("Second")
print(gaussPivotFunc(b))
print(np.linalg.solve(b1,b2))
print("Third")
print(gaussPivotFunc(c))
print(neuv(c,np.linalg.solve(c1,c2)))