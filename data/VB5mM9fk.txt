import math
import numpy as np

def func(c, v=40, t=10, g=9.8, m=68.1):
    return v - (g*m*(1 - np.e**(-(c/m)*t)))/c

def dih (func1, eps, left, right):
    while (right - left > eps):
        c = (left+right)/2
        if (func1(left)*func1(c)<0):
            right = c
        elif (func1(left)*func1(c)>0):
            left = c
        else:
            return c
    return c

x_dih = dih(func, 10 ** -10, 5, 20)
y = func(x_dih)
print (x_dih, y)

def func1(x):
    return np.e**x - 4*(1 - x**2)

x_dih = dih(func1, 10**-10, 0, 1)
print(x_dih)


def derivative(func, x0):
    delta = 1e-10

    return (func(x0 + delta) - func(x0)) / delta


def newton(func, x0, eps):
    iteration = 1

    x1 = x0

    print(f'x by biecection {x1}')

    der = derivative(func, x1)

    print(f'derivative is {der}')

    x2 = x1 - (func(x1) / der)

    print("new x", x2)

    while abs(x2 - x1) > eps:
        iteration += 1
        x1 = x2
        der = derivative(func, x1)
        x2 = x1 - (func(x1) / der)
    print("iteration", iteration)
    return x2

x_newt = newton(func1, x_dih, 10**-10)
print(x_newt)

def secant (func, x_first, x_second, eps):
    iteration = 1
    x0 = x_first
    x1 = x_second
    x2 = x1 - (x1-x0)*func(x1)/(func(x1)-func(x0))
    while abs(x2-x1) > eps:
        x0 = x1
        x1 = x2
        x2 = x1 - (x1-x0)*func(x1)/(func(x1)-func(x0))
        iteration += 1
    print ("iterations", iteration)
    return x2

x_sec = secant(func1, x_dih, x_newt, 10**-10)
print (x_sec)

