local times = ""
local FuelNeeded = 0   -- Minimum level of fuel allowed for turtle to start
local Chest = 0    -- Declaring a chest value to determine if chest should be place in the end

local valArray = {}
local aUpdate = {}
mLog = {x = 100, y = 100, z = 100, d = 0}
--quickStart = {x = 10, y = 10, z = 10}
quickStart = nil

local GlobalLog = {}

File = fs.open("Turtle_output.txt", "w")
table.insert(GlobalLog, {x = 0, y = 0, z = 0, block = "minecraft:void"})
table.insert(mLog, {x = 100, y = 100, z = 100, d = 0})
table.insert(valArray, {x = 100, y = 100, z = 100})

-- Functions

local function tablelength(T)
	local count = 0
	for _ in pairs(T) do count = count + 1 end
	return count
end

local function valuable(success, data )
	
	if not success then
		return false
	end

	local ignore={
	["minecraft:chest"] = true,
	}
	
	if ignore[data.name] then --# quick access trick: we have the name of the block now, if it's in the list we will get true for the if
		return false
	else
		return true
	end
end


function Move(command)
	File.writeLine("---------------------")

	function Fwd(shouldLog)
		turtle.dig()
		turtle.forward()

		if shouldLog == true then
			table.insert(mLog, {x = 0, y = 1, z = 0})
			File.writeLine("Move('fwd')")
		else
			print("Rtn_Fwd")
		end
		
	end
	function Bwd(shouldLog)
		turtle.back()

		if shouldLog == true then
			table.insert(mLog, {x = 0, y = -1, z = 0})
			File.writeLine("Move('bwd')")
		else
			print("Rtn_Bwd")
		end
		
	end
	local function Left(shouldLog)
		turtle.turnLeft()

		if shouldLog == true then

			table.insert(mLog, {x = 0, y = 0, z = 0, d = -1})
			File.writeLine("Move('Left')")
		else
			print("Rtn_Left")
		end
	end
	local function Right(shouldLog)
		turtle.turnRight()

		if shouldLog == true then
			table.insert(mLog, {x = 0, y = 0, z = 0, d = 1})
			File.writeLine("Move('Right')")
		else
			print("Rtn_Right")
		end
	end
	local function Up(shouldLog)
		turtle.digUp()
		turtle.up()

		if shouldLog == true then
			table.insert(mLog, {x = 0, y = 0, z = 1, d = 0})
			File.writeLine("Move('Up')")
		else
			print("Rtn_Up")
		end

	end
	local function Down(shouldLog)
		turtle.digDown()
		turtle.down()

		if shouldLog == true then
			table.insert(mLog, {x = 0, y = 0, z = -1, d = 0})
			File.writeLine("Move('Down')")
		else
			print("Rtn_Down")
		end

	end

	function Tscan(shouldLog)
		
		print("TurtleScan")
		File.writeLine("Move('Tscan')")
		Move("right")
		Move("right")
		Move("right")
		Move("right")		
	end

	if command == "fwd" then Fwd(true)
	elseif command == "bwd" then Bwd(true)
	elseif command == "left" then Left(true)
	elseif command == "right" then Right(true)
	elseif command == "up" then Up(true)
	elseif command == "down" then Down(true)
	elseif command == "tscan" then Tscan(true)

	elseif command == "fwd_NoLog" then Fwd(false)
	elseif command == "bwd_NoLog" then Bwd(false)
	elseif command == "left_NoLog" then Left(false)
	elseif command == "right_NoLog" then Right(false)
	elseif command == "up_NoLog" then Up(false)
	elseif command == "down_NoLog" then Down(false)
	elseif command == "tscan_NoLog" then Tscan(false)

	end
	
end


function InsertFilter(tab)
	File.writeLine("---------------------")
	File.writeLine("InsertFilter()")
	if #valArray > 0 then

		counter = 0

		for k,v in ipairs(valArray) do

			tx = tab.x
			ty = tab.y
			tz = tab.z

			vx = v.x
			vy = v.y
			vz = v.z

			if tx == vx and (ty == vy and tz == vz) then
				counter = counter +1
				File.writeLine("Count: " .. counter)
			end
		end

		if counter < 1 then
			table.insert(valArray, tab)
			File.writeLine("ins_" .. " " .. tab.x .. " " .. tab.y .. " " .. tab.z)
		end
	else
		table.insert(valArray, tab)
		File.writeLine("ins_" .. " " .. tab.x .. " " .. tab.y .. " " .. tab.z)
	end
end

function GetDiffToCoord(ix,iy,iz)

	local cPos = GetPos()
    File.writeLine("GetDiffToCoord_Get: " .. cPos.x .. ", " .. cPos.y .. ", " .. cPos.z .. ", " .. cPos.d)

	xDiff = ix - cPos.x
	yDiff = iy - cPos.y
	zDiff = iz - cPos.z

    File.writeLine("GetDiff_Get: " .. xDiff .. ", " .. yDiff .. ", " .. zDiff)

	return {x = xDiff, y = yDiff, z = zDiff}
end

function GetMoveDir(iDiff)

	idir = 0
	if iDiff < 0 then
		idir = -1
	elseif iDiff > 0 then
		idir = 1
	end

	return idir
end

function Vec2Move(coord)

	idir = 0

	if coord < 0 then
		idir = -1
	elseif coord > 0 then
		idir = 1
	end

	return idir
end

function ResetDir()
	--while not (GetPos().d == 0 ) do
	File.writeLine("---------------------")
	File.writeLine("ResetDir()")
		
	local d = GetPos().d

	if d == 0 then
		return true
	elseif d < 2 then
		Move("left")
		return true
	elseif d > 2 then
		Move("right")
		return true
	else
		Move("right")
		Move("right")
		return true
	end

end

function ArrayRemove(t, fnKeep)
    local j, n = 1, #t;

    for i=1,n do
        if (fnKeep(t, i, j)) then
            -- Move i's kept value to j's position, if it's not already there.
            if (i ~= j) then
                t[j] = t[i];
                t[i] = nil;
            end
            j = j + 1; -- Increment position of where we'll place the next kept value.
        else
            t[i] = nil;
        end
    end

    return t;
end


function Dir2Vec3(y, d)

    --File.writeLine("---------------------")
	--File.writeLine("Dir2Vec3(" .. y .. "," .. d .. ")")
    
    d = (d+4)%4

	mY = 0
	mX = 0

	y = Vec2Move(y)

	if y == 1 and d == 0 then
		mY = 1
	elseif y == 1 and d == 1 then
		mX = 1
	elseif y == 1 and d == 2 then
		mY = -1
	elseif y == 1 and d == 3 then
		mX = -1
	end

	return {x = mX, y = mY}

end

function MoveTo(x,y,z)
	File.writeLine("---------------------")
	File.writeLine("MoveTo(" .. x .. "," .. y .. "," .. z .. ")")
	--d = GetPos().d
	
	if z == 1 then
		Move("up")
	elseif z == -1 then
		Move("down")
	elseif y == 1 and x == 1 then
		Move("fwd")
		Move("right")
		Move("fwd")
	elseif y == -1 and x == 1 then
		Move("right")
		Move("fwd")
		Move("right")
		Move("fwd")
	elseif y == 1 and x == -1 then
		Move("fwd")
		Move("left")
		Move("fwd")
	elseif y == -1 and x == -1 then
		Move("left")
		Move("fwd")
		Move("left")
		Move("fwd")
	elseif y == 0 and x == -1 then
		Move("left")
		Move("fwd")
	elseif y == 0 and x == 1 then
		Move("right")
		Move("fwd")
	elseif y == 1 and x == 0 then
		--ResetDir()
		Move("fwd")
	elseif y == -1 and x == 0 then
		File.writeLine("bwd ->")
		Move("left")
		Move("left")
		Move("fwd")
	else
		File.writeLine("Reached: " .. x .. ", " .. y .. ", " .. z)
		return true
	end

end

function GetPos(iX,iY,iZ)

	local tPos = {}	

	tX = mLog[1].x
	tY = mLog[1].y
	tZ = mLog[1].z
	tD = mLog[1].d

	--vec = 0
	lD = 0

	for k, v in ipairs(mLog) do

		--File.writeLine("Key: " .. k)
		--File.flush()

		if k > 1 then

			d = v.d or nil

			if type(v.d) == "number" then

				lD = lD + v.d
				d = (lD+4)%4
				
			end

			dCorr = Dir2Vec3(v.y, lD)

			tX = tX + dCorr.x
			tY = tY + dCorr.y

			d = v.d or lD

			d = (d+4)%4

			tZ = tZ + v.z
			tD = tD + d
		end

	end	
	
	iX = iX or 0
	iY = iY or 0
	iZ = iZ or 0

	oX = 0
	oY = 0

	tD = (lD+4)%4
	
	dCorr = Dir2Vec3(iY, tD)

	tX = tX + dCorr.x
	tY = tY + dCorr.y
	tZ = tZ + iZ

	tPos = {x = tX, y = tY, z = tZ, d = tD}
	
	return tPos
end

function GoTo(x,y,z)
	
	File.writeLine("GoTo(" .. x .. ", " .. y .. ", " .. z .. ")" )
	isReached = false 

	while isReached == false do

		local dif = GetDiffToCoord(x,y,z)

		local ix = GetMoveDir(dif.x)
		local iy = GetMoveDir(dif.y)
		local iz = GetMoveDir(dif.z)

		File.writeLine("Dir = " .. GetPos().d)
	
		ResetDir()

		File.writeLine("Dir = " .. GetPos().d)

		if MoveTo(ix,iy,iz) == true then
			isReached = true 
			File.writeLine("REACHED")
		end
		File.flush()
		
	end

	File.writeLine("GoTo()_DONE")
	return isReached

end

function RemoveNils(Objects)
	local tbl = {}
	for I = 1, #Objects do

		if(Objects[I] ~= nil) then
			table.insert(tbl, Objects[I])
		end
	end
	Objects = tbl
end

function UpTilClear()
	
	local pos = GetPos()
	local success, data = turtle.inspectUp()
 	local upCounter = 0

	while success do
		success, data = turtle.inspectUp()
		Move("up")
		upCounter = upCounter+1
	end

	for i = 1, upCounter do
		Move("down")
	end

end


--sleep (2)
--print ("Type: {Width, Length, Height}")
print ("------------")
print ("Less Stupid: Planer")
print ("------------")
print ("Place: Items to use as filling blocks in inventory (Optional)")
print (" ")
print ("Y = Forward, X = Right")
print ("---------------------------")

if quickStart == nil then
    print ("Y = ")
    tX01 = read()
    tX01 = tonumber(tX01)
    print ("X = ")
    tY01 = read()
    tY01 = tonumber(tY01)
    print ("Z = to highest connected block")
    --tZ01 = read()
    --tZ01 = tonumber(tZ01)
	tZ01 = 4
else
    tX01 = quickStart.x
    tY01 = quickStart.y
    tZ01 = quickStart.z    
end

print("MineCoords: " .. tX01 .. "," .. tY01 .. "," .. tZ01)

times = tX01

FuelNeeded = times*tY01*tZ01
print ("Fuel needed to dig is "..FuelNeeded)

if turtle.getFuelLevel() < FuelNeeded then
	turtle.select(1)
	turtle.refuel()
  print ("Fuel level is: "..turtle.getFuelLevel())
  print ("Turtle is low on fuel. Do you wish to refuel? y/n")
  local event, param1 = os.pullEvent("char")
  if param1 == "y" then
	 turtle.select(1)
	 turtle.refuel()
	 
  else
	 print ("!Too low fuel for program to initiate!")
	 print ("Turtle rebooting!")
	 sleep (2)
	 os.reboot()
	 
  end
end

olPos = GetPos()

for y = 1, tY01 do

	originalPos = GetPos()
	--ResetDir()

	File.writeLine("------------------------------------------")
	
	for x = 1, tX01 do
		
		UpTilClear()
		turtle.select(1) 
		turtle.placeDown()
		Move("fwd")

	end

	if y%2 == 1 then
		Move("right")
		Move("fwd")
		Move("right")
		Move("fwd")
	else
		Move("left")
		Move("fwd")
		Move("left")
		Move("fwd")
	end

	File.writeLine("---------------------------------------------------------------")
end

GoTo(olPos.x, olPos.y, olPos.z)

ResetDir()

turtle.turnLeft()
turtle.turnLeft()

local success, data = turtle.inspect()

if data.name == "minecraft:chest" then

	print("Chest Found!")

	for i = 1, 16 do
		turtle.select(i)
		turtle.drop()
	end

	isDone = true
else
	
	print("No Chest found, Searching inventory...")
	turtle.select(16)
	local data = turtle.getItemDetail()

	if not(data == nil) and data.name == "minecraft:chest" then
		
		print("Chest Found!")
		sleep (1)
	
		for i = 1, 16 do
			turtle.select(i)
			turtle.drop()   
		end

		isDone = true
	end
end


turtle.turnLeft()
turtle.turnLeft()

for index, value in pairs(valArray) do
	File.writeLine("Fin: " .. valArray[index].x .. ", " .. valArray[index].y .. ", " .. valArray[index].z)
end

File.close()